/*! For license information please see createVectorTilePolylines.js.LICENSE.txt */
import{createTaskProcessorWorker_default}from"./chunk-AI3KSNM6.js";import{AttributeCompression_default}from"./chunk-I6TVJ6T7.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{combine_default}from"./chunk-HSW63JN4.js";import{Rectangle_default}from"./chunk-RSWBNJPT.js";import"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import"./chunk-C53JYYKX.js";import"./chunk-7FEGZO3D.js";import"./chunk-YS4KPNLC.js";var maxShort=32767,scratchBVCartographic=new Cartographic_default,scratchEncodedPosition=new Cartesian3_default;function decodeVectorPolylinePositions(t,e,a,r,n){const s=t.length/3,c=t.subarray(0,s),i=t.subarray(s,2*s),o=t.subarray(2*s,3*s);AttributeCompression_default.zigZagDeltaDecode(c,i,o);const u=new Float64Array(t.length);for(let t=0;t<s;++t){const s=c[t],l=i[t],f=o[t],d=Math_default.lerp(e.west,e.east,s/maxShort),h=Math_default.lerp(e.south,e.north,l/maxShort),p=Math_default.lerp(a,r,f/maxShort),_=Cartographic_default.fromRadians(d,h,p,scratchBVCartographic),C=n.cartographicToCartesian(_,scratchEncodedPosition);Cartesian3_default.pack(C,u,3*t)}return u}var decodeVectorPolylinePositions_default=decodeVectorPolylinePositions,scratchRectangle=new Rectangle_default,scratchEllipsoid=new Ellipsoid_default,scratchCenter=new Cartesian3_default,scratchMinMaxHeights={min:void 0,max:void 0};function unpackBuffer(t){t=new Float64Array(t);let e=0;scratchMinMaxHeights.min=t[e++],scratchMinMaxHeights.max=t[e++],Rectangle_default.unpack(t,e,scratchRectangle),e+=Rectangle_default.packedLength,Ellipsoid_default.unpack(t,e,scratchEllipsoid),e+=Ellipsoid_default.packedLength,Cartesian3_default.unpack(t,e,scratchCenter)}function getPositionOffsets(t){const e=t.length,a=new Uint32Array(e+1);let r=0;for(let n=0;n<e;++n)a[n]=r,r+=t[n];return a[e]=r,a}var scratchP0=new Cartesian3_default,scratchP1=new Cartesian3_default,scratchPrev=new Cartesian3_default,scratchCur=new Cartesian3_default,scratchNext=new Cartesian3_default;function createVectorTilePolylines(t,e){const a=new Uint16Array(t.positions),r=new Uint16Array(t.widths),n=new Uint32Array(t.counts),s=new Uint16Array(t.batchIds);unpackBuffer(t.packedBuffer);const c=scratchRectangle,i=scratchEllipsoid,o=scratchCenter,u=scratchMinMaxHeights.min,l=scratchMinMaxHeights.max,f=decodeVectorPolylinePositions_default(a,c,u,l,i),d=f.length/3,h=4*d-4,p=new Float32Array(3*h),_=new Float32Array(3*h),C=new Float32Array(3*h),P=new Float32Array(2*h),k=new Uint16Array(h);let m,b=0,y=0,g=0,w=0,x=n.length;for(m=0;m<x;++m){const t=n[m],e=r[m],a=s[m];for(let r=0;r<t;++r){let n;if(0===r){const t=Cartesian3_default.unpack(f,3*w,scratchP0),e=Cartesian3_default.unpack(f,3*(w+1),scratchP1);n=Cartesian3_default.subtract(t,e,scratchPrev),Cartesian3_default.add(t,n,n)}else n=Cartesian3_default.unpack(f,3*(w+r-1),scratchPrev);const s=Cartesian3_default.unpack(f,3*(w+r),scratchCur);let c;if(r===t-1){const e=Cartesian3_default.unpack(f,3*(w+t-1),scratchP0),a=Cartesian3_default.unpack(f,3*(w+t-2),scratchP1);c=Cartesian3_default.subtract(e,a,scratchNext),Cartesian3_default.add(e,c,c)}else c=Cartesian3_default.unpack(f,3*(w+r+1),scratchNext);Cartesian3_default.subtract(n,o,n),Cartesian3_default.subtract(s,o,s),Cartesian3_default.subtract(c,o,c);const i=r===t-1?2:4;for(let t=0===r?2:0;t<i;++t){Cartesian3_default.pack(s,p,b),Cartesian3_default.pack(n,_,b),Cartesian3_default.pack(c,C,b),b+=3;const r=t-2<0?-1:1;P[y++]=t%2*2-1,P[y++]=r*e,k[g++]=a}}w+=t}const A=IndexDatatype_default.createTypedArray(h,6*d-6);let E=0,M=0;for(x=d-1,m=0;m<x;++m)A[M++]=E,A[M++]=E+2,A[M++]=E+1,A[M++]=E+1,A[M++]=E+2,A[M++]=E+3,E+=4;e.push(p.buffer,_.buffer,C.buffer),e.push(P.buffer,k.buffer,A.buffer);let V={indexDatatype:2===A.BYTES_PER_ELEMENT?IndexDatatype_default.UNSIGNED_SHORT:IndexDatatype_default.UNSIGNED_INT,currentPositions:p.buffer,previousPositions:_.buffer,nextPositions:C.buffer,expandAndWidth:P.buffer,batchIds:k.buffer,indices:A.buffer};if(t.keepDecodedPositions){const t=getPositionOffsets(n);e.push(f.buffer,t.buffer),V=combine_default(V,{decodedPositions:f.buffer,decodedPositionOffsets:t.buffer})}return V}var createVectorTilePolylines_default=createTaskProcessorWorker_default(createVectorTilePolylines);export{createVectorTilePolylines_default as default};