/*! For license information please see createVectorTileClampedPolylines.js.LICENSE.txt */
import{createTaskProcessorWorker_default}from"./chunk-AI3KSNM6.js";import{AttributeCompression_default}from"./chunk-I6TVJ6T7.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{combine_default}from"./chunk-HSW63JN4.js";import{Rectangle_default}from"./chunk-RSWBNJPT.js";import"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import"./chunk-C53JYYKX.js";import"./chunk-7FEGZO3D.js";import"./chunk-YS4KPNLC.js";var MAX_SHORT=32767,MITER_BREAK=Math.cos(Math_default.toRadians(150)),scratchBVCartographic=new Cartographic_default,scratchEncodedPosition=new Cartesian3_default;function decodePositions(t,e,a,r,s,n,i){const o=t.length,c=new Float64Array(3*o);for(let l=0;l<o;++l){const o=t[l],d=e[l],f=a[l],u=Math_default.lerp(r.west,r.east,o/MAX_SHORT),h=Math_default.lerp(r.south,r.north,d/MAX_SHORT),p=Math_default.lerp(s,n,f/MAX_SHORT),_=Cartographic_default.fromRadians(u,h,p,scratchBVCartographic),C=i.cartographicToCartesian(_,scratchEncodedPosition);Cartesian3_default.pack(C,c,3*l)}return c}function getPositionOffsets(t){const e=t.length,a=new Uint32Array(e+1);let r=0;for(let s=0;s<e;++s)a[s]=r,r+=t[s];return a[e]=r,a}var previousCompressedCartographicScratch=new Cartographic_default,currentCompressedCartographicScratch=new Cartographic_default;function removeDuplicates(t,e,a,r){const s=r.length,n=t.length,i=new Uint8Array(n),o=previousCompressedCartographicScratch,c=currentCompressedCartographicScratch;let l=0;for(let a=0;a<s;a++){const s=r[a];let n=s;for(let a=1;a<s;a++){const r=l+a,s=r-1;c.longitude=t[r],c.latitude=e[r],o.longitude=t[s],o.latitude=e[s],Cartographic_default.equals(c,o)&&(n--,i[s]=1)}r[a]=n,l+=s}let d=0;for(let r=0;r<n;r++)1!==i[r]&&(t[d]=t[r],e[d]=e[r],a[d]=a[r],d++)}function VertexAttributesAndIndices(t){const e=8*t,a=3*e,r=4*e;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(r),this.startFaceNormalAndVertexCornerIds=new Float32Array(r),this.endPositionAndHeights=new Float32Array(r),this.endFaceNormalAndHalfWidths=new Float32Array(r),this.vertexBatchIds=new Uint16Array(e),this.indices=IndexDatatype_default.createTypedArray(e,36*t),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}var towardCurrScratch=new Cartesian3_default,towardNextScratch=new Cartesian3_default;function computeMiteredNormal(t,e,a,r,s){const n=Cartesian3_default.subtract(a,e,towardNextScratch);let i=Cartesian3_default.subtract(e,t,towardCurrScratch);return Cartesian3_default.normalize(n,n),Cartesian3_default.normalize(i,i),Cartesian3_default.dot(n,i)<MITER_BREAK&&(i=Cartesian3_default.multiplyByScalar(i,-1,towardCurrScratch)),Cartesian3_default.add(n,i,s),Cartesian3_default.equals(s,Cartesian3_default.ZERO)&&(s=Cartesian3_default.subtract(t,e)),Cartesian3_default.cross(s,r,s),Cartesian3_default.cross(r,s,s),Cartesian3_default.normalize(s,s),s}var REFERENCE_INDICES=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],REFERENCE_INDICES_LENGTH=REFERENCE_INDICES.length,positionScratch=new Cartesian3_default,scratchStartEllipsoidNormal=new Cartesian3_default,scratchStartFaceNormal=new Cartesian3_default,scratchEndEllipsoidNormal=new Cartesian3_default,scratchEndFaceNormal=new Cartesian3_default;VertexAttributesAndIndices.prototype.addVolume=function(t,e,a,r,s,n,i,o,c,l){let d=Cartesian3_default.add(e,c,positionScratch);const f=l.geodeticSurfaceNormal(d,scratchStartEllipsoidNormal);d=Cartesian3_default.add(a,c,positionScratch);const u=l.geodeticSurfaceNormal(d,scratchEndEllipsoidNormal),h=computeMiteredNormal(t,e,a,f,scratchStartFaceNormal),p=computeMiteredNormal(r,a,e,u,scratchEndFaceNormal),_=this.startEllipsoidNormals,C=this.endEllipsoidNormals,m=this.startPositionAndHeights,E=this.startFaceNormalAndVertexCornerIds,N=this.endPositionAndHeights,A=this.endFaceNormalAndHalfWidths,g=this.vertexBatchIds;let I,S=this.batchIdOffset,w=this.vec3Offset,b=this.vec4Offset;for(I=0;I<8;I++)Cartesian3_default.pack(f,_,w),Cartesian3_default.pack(u,C,w),Cartesian3_default.pack(e,m,b),m[b+3]=s,Cartesian3_default.pack(a,N,b),N[b+3]=n,Cartesian3_default.pack(h,E,b),E[b+3]=I,Cartesian3_default.pack(p,A,b),A[b+3]=i,g[S++]=o,w+=3,b+=4;this.batchIdOffset=S,this.vec3Offset=w,this.vec4Offset=b;const k=this.indices,P=this.volumeStartIndex,R=this.indexOffset;for(I=0;I<REFERENCE_INDICES_LENGTH;I++)k[R+I]=REFERENCE_INDICES[I]+P;this.volumeStartIndex+=8,this.indexOffset+=REFERENCE_INDICES_LENGTH};var scratchRectangle=new Rectangle_default,scratchEllipsoid=new Ellipsoid_default,scratchCenter=new Cartesian3_default,scratchPrev=new Cartesian3_default,scratchP0=new Cartesian3_default,scratchP1=new Cartesian3_default,scratchNext=new Cartesian3_default;function createVectorTileClampedPolylines(t,e){const a=new Uint16Array(t.positions),r=new Uint16Array(t.widths),s=new Uint32Array(t.counts),n=new Uint16Array(t.batchIds),i=scratchRectangle,o=scratchEllipsoid,c=scratchCenter,l=new Float64Array(t.packedBuffer);let d=0;const f=l[d++],u=l[d++];let h;Rectangle_default.unpack(l,d,i),d+=Rectangle_default.packedLength,Ellipsoid_default.unpack(l,d,o),d+=Ellipsoid_default.packedLength,Cartesian3_default.unpack(l,d,c);let p=a.length/3;const _=a.subarray(0,p),C=a.subarray(p,2*p),m=a.subarray(2*p,3*p);AttributeCompression_default.zigZagDeltaDecode(_,C,m),removeDuplicates(_,C,m,s);const E=s.length;let N=0;for(h=0;h<E;h++)N+=s[h]-1;const A=new VertexAttributesAndIndices(N),g=decodePositions(_,C,m,i,f,u,o,c);p=_.length;const I=new Float32Array(3*p);for(h=0;h<p;++h)I[3*h]=g[3*h]-c.x,I[3*h+1]=g[3*h+1]-c.y,I[3*h+2]=g[3*h+2]-c.z;let S=0,w=0;for(h=0;h<E;h++){const t=s[h]-1,e=.5*r[h],a=n[h],i=S;for(let r=0;r<t;r++){const s=Cartesian3_default.unpack(I,S,scratchP0),n=Cartesian3_default.unpack(I,S+3,scratchP1);let l=m[w],d=m[w+1];l=Math_default.lerp(f,u,l/MAX_SHORT),d=Math_default.lerp(f,u,d/MAX_SHORT),w++;let h=scratchPrev,p=scratchNext;if(0===r){const e=i+3*t,a=Cartesian3_default.unpack(I,e,scratchPrev);if(Cartesian3_default.equals(a,s))Cartesian3_default.unpack(I,e-3,h);else{const t=Cartesian3_default.subtract(s,n,scratchPrev);h=Cartesian3_default.add(t,s,scratchPrev)}}else Cartesian3_default.unpack(I,S-3,h);if(r===t-1){const t=Cartesian3_default.unpack(I,i,scratchNext);if(Cartesian3_default.equals(t,n))Cartesian3_default.unpack(I,i+3,p);else{const t=Cartesian3_default.subtract(n,s,scratchNext);p=Cartesian3_default.add(t,n,scratchNext)}}else Cartesian3_default.unpack(I,S+6,p);A.addVolume(h,s,n,p,l,d,e,a,c,o),S+=3}S+=3,w++}const b=A.indices;e.push(A.startEllipsoidNormals.buffer),e.push(A.endEllipsoidNormals.buffer),e.push(A.startPositionAndHeights.buffer),e.push(A.startFaceNormalAndVertexCornerIds.buffer),e.push(A.endPositionAndHeights.buffer),e.push(A.endFaceNormalAndHalfWidths.buffer),e.push(A.vertexBatchIds.buffer),e.push(b.buffer);let k={indexDatatype:2===b.BYTES_PER_ELEMENT?IndexDatatype_default.UNSIGNED_SHORT:IndexDatatype_default.UNSIGNED_INT,startEllipsoidNormals:A.startEllipsoidNormals.buffer,endEllipsoidNormals:A.endEllipsoidNormals.buffer,startPositionAndHeights:A.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:A.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:A.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:A.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:A.vertexBatchIds.buffer,indices:b.buffer};if(t.keepDecodedPositions){const t=getPositionOffsets(s);e.push(g.buffer,t.buffer),k=combine_default(k,{decodedPositions:g.buffer,decodedPositionOffsets:t.buffer})}return k}var createVectorTileClampedPolylines_default=createTaskProcessorWorker_default(createVectorTileClampedPolylines);export{createVectorTileClampedPolylines_default as default};