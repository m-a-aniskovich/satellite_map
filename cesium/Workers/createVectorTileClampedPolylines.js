define(["./AttributeCompression-f9f6c717","./Matrix3-41c58dde","./combine-d9581036","./IndexDatatype-2643aa47","./Math-0a2ac845","./Matrix2-e1298525","./createTaskProcessorWorker","./ComponentDatatype-cf1fa08e","./defaultValue-fe22d8c0","./Check-6ede7e26","./WebGLConstants-0b1ce7ba","./RuntimeError-ef395448"],(function(t,e,a,s,n,r,i,o,c,d,l,f){"use strict";const h=32767,u=Math.cos(n.CesiumMath.toRadians(150)),C=new e.Cartographic,p=new e.Cartesian3,m=new e.Cartographic,b=new e.Cartographic;function A(t){const e=8*t,a=3*e,n=4*e;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(n),this.startFaceNormalAndVertexCornerIds=new Float32Array(n),this.endPositionAndHeights=new Float32Array(n),this.endFaceNormalAndHalfWidths=new Float32Array(n),this.vertexBatchIds=new Uint16Array(e),this.indices=s.IndexDatatype.createTypedArray(e,36*t),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}const w=new e.Cartesian3,g=new e.Cartesian3;function y(t,a,s,n,r){const i=e.Cartesian3.subtract(s,a,g);let o=e.Cartesian3.subtract(a,t,w);return e.Cartesian3.normalize(i,i),e.Cartesian3.normalize(o,o),e.Cartesian3.dot(i,o)<u&&(o=e.Cartesian3.multiplyByScalar(o,-1,w)),e.Cartesian3.add(i,o,r),e.Cartesian3.equals(r,e.Cartesian3.ZERO)&&(r=e.Cartesian3.subtract(t,a)),e.Cartesian3.cross(r,n,r),e.Cartesian3.cross(n,r,r),e.Cartesian3.normalize(r,r),r}const N=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],k=N.length,x=new e.Cartesian3,I=new e.Cartesian3,E=new e.Cartesian3,F=new e.Cartesian3,H=new e.Cartesian3;A.prototype.addVolume=function(t,a,s,n,r,i,o,c,d,l){let f=e.Cartesian3.add(a,d,x);const h=l.geodeticSurfaceNormal(f,I);f=e.Cartesian3.add(s,d,x);const u=l.geodeticSurfaceNormal(f,F),C=y(t,a,s,h,E),p=y(n,s,a,u,H),m=this.startEllipsoidNormals,b=this.endEllipsoidNormals,A=this.startPositionAndHeights,w=this.startFaceNormalAndVertexCornerIds,g=this.endPositionAndHeights,O=this.endFaceNormalAndHalfWidths,P=this.vertexBatchIds;let v,D=this.batchIdOffset,M=this.vec3Offset,S=this.vec4Offset;for(v=0;v<8;v++)e.Cartesian3.pack(h,m,M),e.Cartesian3.pack(u,b,M),e.Cartesian3.pack(a,A,S),A[S+3]=r,e.Cartesian3.pack(s,g,S),g[S+3]=i,e.Cartesian3.pack(C,w,S),w[S+3]=v,e.Cartesian3.pack(p,O,S),O[S+3]=o,P[D++]=c,M+=3,S+=4;this.batchIdOffset=D,this.vec3Offset=M,this.vec4Offset=S;const R=this.indices,U=this.volumeStartIndex,B=this.indexOffset;for(v=0;v<k;v++)R[B+v]=N[v]+U;this.volumeStartIndex+=8,this.indexOffset+=k};const O=new r.Rectangle,P=new e.Ellipsoid,v=new e.Cartesian3,D=new e.Cartesian3,M=new e.Cartesian3,S=new e.Cartesian3,R=new e.Cartesian3;return i((function(i,o){const c=new Uint16Array(i.positions),d=new Uint16Array(i.widths),l=new Uint32Array(i.counts),f=new Uint16Array(i.batchIds),u=O,w=P,g=v,y=new Float64Array(i.packedBuffer);let N=0;const k=y[N++],x=y[N++];let I;r.Rectangle.unpack(y,N,u),N+=r.Rectangle.packedLength,e.Ellipsoid.unpack(y,N,w),N+=e.Ellipsoid.packedLength,e.Cartesian3.unpack(y,N,g);let E=c.length/3;const F=c.subarray(0,E),H=c.subarray(E,2*E),U=c.subarray(2*E,3*E);t.AttributeCompression.zigZagDeltaDecode(F,H,U),function(t,a,s,n){const r=n.length,i=t.length,o=new Uint8Array(i),c=m,d=b;let l=0;for(let s=0;s<r;s++){const r=n[s];let i=r;for(let s=1;s<r;s++){const n=l+s,r=n-1;d.longitude=t[n],d.latitude=a[n],c.longitude=t[r],c.latitude=a[r],e.Cartographic.equals(d,c)&&(i--,o[r]=1)}n[s]=i,l+=r}let f=0;for(let e=0;e<i;e++)1!==o[e]&&(t[f]=t[e],a[f]=a[e],s[f]=s[e],f++)}(F,H,U,l);const B=l.length;let V=0;for(I=0;I<B;I++)V+=l[I]-1;const T=new A(V),W=function(t,a,s,r,i,o,c){const d=t.length,l=new Float64Array(3*d);for(let f=0;f<d;++f){const d=t[f],u=a[f],m=s[f],b=n.CesiumMath.lerp(r.west,r.east,d/h),A=n.CesiumMath.lerp(r.south,r.north,u/h),w=n.CesiumMath.lerp(i,o,m/h),g=e.Cartographic.fromRadians(b,A,w,C),y=c.cartographicToCartesian(g,p);e.Cartesian3.pack(y,l,3*f)}return l}(F,H,U,u,k,x,w);E=F.length;const z=new Float32Array(3*E);for(I=0;I<E;++I)z[3*I]=W[3*I]-g.x,z[3*I+1]=W[3*I+1]-g.y,z[3*I+2]=W[3*I+2]-g.z;let q=0,L=0;for(I=0;I<B;I++){const t=l[I]-1,a=.5*d[I],s=f[I],r=q;for(let i=0;i<t;i++){const o=e.Cartesian3.unpack(z,q,M),c=e.Cartesian3.unpack(z,q+3,S);let d=U[L],l=U[L+1];d=n.CesiumMath.lerp(k,x,d/h),l=n.CesiumMath.lerp(k,x,l/h),L++;let f=D,u=R;if(0===i){const a=r+3*t,s=e.Cartesian3.unpack(z,a,D);if(e.Cartesian3.equals(s,o))e.Cartesian3.unpack(z,a-3,f);else{const t=e.Cartesian3.subtract(o,c,D);f=e.Cartesian3.add(t,o,D)}}else e.Cartesian3.unpack(z,q-3,f);if(i===t-1){const t=e.Cartesian3.unpack(z,r,R);if(e.Cartesian3.equals(t,c))e.Cartesian3.unpack(z,r+3,u);else{const t=e.Cartesian3.subtract(c,o,R);u=e.Cartesian3.add(t,c,R)}}else e.Cartesian3.unpack(z,q+6,u);T.addVolume(f,o,c,u,d,l,a,s,g,w),q+=3}q+=3,L++}const _=T.indices;o.push(T.startEllipsoidNormals.buffer),o.push(T.endEllipsoidNormals.buffer),o.push(T.startPositionAndHeights.buffer),o.push(T.startFaceNormalAndVertexCornerIds.buffer),o.push(T.endPositionAndHeights.buffer),o.push(T.endFaceNormalAndHalfWidths.buffer),o.push(T.vertexBatchIds.buffer),o.push(_.buffer);let G={indexDatatype:2===_.BYTES_PER_ELEMENT?s.IndexDatatype.UNSIGNED_SHORT:s.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:T.startEllipsoidNormals.buffer,endEllipsoidNormals:T.endEllipsoidNormals.buffer,startPositionAndHeights:T.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:T.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:T.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:T.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:T.vertexBatchIds.buffer,indices:_.buffer};if(i.keepDecodedPositions){const t=function(t){const e=t.length,a=new Uint32Array(e+1);let s=0;for(let n=0;n<e;++n)a[n]=s,s+=t[n];return a[e]=s,a}(l);o.push(W.buffer,t.buffer),G=a.combine(G,{decodedPositions:W.buffer,decodedPositionOffsets:t.buffer})}return G}))}));