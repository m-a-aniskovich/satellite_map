/*! For license information please see createVectorTileGeometries.js.LICENSE.txt */
import{Color_default}from"./chunk-QUXSQQEF.js";import{CylinderGeometry_default}from"./chunk-CLVEIRXT.js";import"./chunk-PB7BIXHI.js";import{EllipsoidGeometry_default}from"./chunk-S7IBK36I.js";import{createTaskProcessorWorker_default}from"./chunk-AI3KSNM6.js";import{BoxGeometry_default}from"./chunk-VKTKOIYG.js";import"./chunk-W7F5VTH6.js";import"./chunk-ZTYE74E2.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import"./chunk-SJDXMQSP.js";import"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Matrix4_default}from"./chunk-RSWBNJPT.js";import"./chunk-Z6LPXA7S.js";import{Cartesian3_default}from"./chunk-PHQVHDVI.js";import"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import"./chunk-C53JYYKX.js";import"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";function Vector3DTileBatch(e){this.offset=e.offset,this.count=e.count,this.color=e.color,this.batchIds=e.batchIds}var Vector3DTileBatch_default=Vector3DTileBatch,scratchCartesian=new Cartesian3_default,packedBoxLength=Matrix4_default.packedLength+Cartesian3_default.packedLength,packedCylinderLength=Matrix4_default.packedLength+2,packedEllipsoidLength=Matrix4_default.packedLength+Cartesian3_default.packedLength,packedSphereLength=Cartesian3_default.packedLength+1,scratchModelMatrixAndBV={modelMatrix:new Matrix4_default,boundingVolume:new BoundingSphere_default};function boxModelMatrixAndBoundingVolume(e,t){let a=t*packedBoxLength;const n=Cartesian3_default.unpack(e,a,scratchCartesian);a+=Cartesian3_default.packedLength;const r=Matrix4_default.unpack(e,a,scratchModelMatrixAndBV.modelMatrix);Matrix4_default.multiplyByScale(r,n,r);const i=scratchModelMatrixAndBV.boundingVolume;return Cartesian3_default.clone(Cartesian3_default.ZERO,i.center),i.radius=Math.sqrt(3),scratchModelMatrixAndBV}function cylinderModelMatrixAndBoundingVolume(e,t){let a=t*packedCylinderLength;const n=e[a++],r=e[a++],i=Cartesian3_default.fromElements(n,n,r,scratchCartesian),d=Matrix4_default.unpack(e,a,scratchModelMatrixAndBV.modelMatrix);Matrix4_default.multiplyByScale(d,i,d);const o=scratchModelMatrixAndBV.boundingVolume;return Cartesian3_default.clone(Cartesian3_default.ZERO,o.center),o.radius=Math.sqrt(2),scratchModelMatrixAndBV}function ellipsoidModelMatrixAndBoundingVolume(e,t){let a=t*packedEllipsoidLength;const n=Cartesian3_default.unpack(e,a,scratchCartesian);a+=Cartesian3_default.packedLength;const r=Matrix4_default.unpack(e,a,scratchModelMatrixAndBV.modelMatrix);Matrix4_default.multiplyByScale(r,n,r);const i=scratchModelMatrixAndBV.boundingVolume;return Cartesian3_default.clone(Cartesian3_default.ZERO,i.center),i.radius=1,scratchModelMatrixAndBV}function sphereModelMatrixAndBoundingVolume(e,t){let a=t*packedSphereLength;const n=e[a++],r=Cartesian3_default.unpack(e,a,scratchCartesian),i=Matrix4_default.fromTranslation(r,scratchModelMatrixAndBV.modelMatrix);Matrix4_default.multiplyByUniformScale(i,n,i);const d=scratchModelMatrixAndBV.boundingVolume;return Cartesian3_default.clone(Cartesian3_default.ZERO,d.center),d.radius=1,scratchModelMatrixAndBV}var scratchPosition=new Cartesian3_default;function createPrimitive(e,t,a,n,r){if(!defined_default(t))return;const i=a.length,d=n.attributes.position.values,o=n.indices,c=e.positions,l=e.vertexBatchIds,s=e.indices,u=e.batchIds,f=e.batchTableColors,h=e.batchedIndices,p=e.indexOffsets,_=e.indexCounts,m=e.boundingVolumes,x=e.modelMatrix,M=e.center;let g=e.positionOffset,k=e.batchIdIndex,B=e.indexOffset;const b=e.batchedIndicesOffset;for(let e=0;e<i;++e){const n=r(t,e),i=n.modelMatrix;Matrix4_default.multiply(x,i,i);const C=a[e],y=d.length;for(let e=0;e<y;e+=3){const t=Cartesian3_default.unpack(d,e,scratchPosition);Matrix4_default.multiplyByPoint(i,t,t),Cartesian3_default.subtract(t,M,t),Cartesian3_default.pack(t,c,3*g+e),l[k++]=C}const V=o.length;for(let e=0;e<V;++e)s[B+e]=o[e]+g;const I=e+b;h[I]=new Vector3DTileBatch_default({offset:B,count:V,color:Color_default.fromRgba(f[C]),batchIds:[C]}),u[I]=C,p[I]=B,_[I]=V,m[I]=BoundingSphere_default.transform(n.boundingVolume,i),g+=y/3,B+=V}e.positionOffset=g,e.batchIdIndex=k,e.indexOffset=B,e.batchedIndicesOffset+=i}var scratchCenter=new Cartesian3_default,scratchMatrix4=new Matrix4_default;function unpackBuffer(e){const t=new Float64Array(e);let a=0;Cartesian3_default.unpack(t,a,scratchCenter),a+=Cartesian3_default.packedLength,Matrix4_default.unpack(t,a,scratchMatrix4)}function packedBatchedIndicesLength(e){const t=e.length;let a=0;for(let n=0;n<t;++n)a+=Color_default.packedLength+3+e[n].batchIds.length;return a}function packBuffer(e,t,a){const n=a.length,r=2+n*BoundingSphere_default.packedLength+1+packedBatchedIndicesLength(t),i=new Float64Array(r);let d=0;i[d++]=e,i[d++]=n;for(let e=0;e<n;++e)BoundingSphere_default.pack(a[e],i,d),d+=BoundingSphere_default.packedLength;const o=t.length;i[d++]=o;for(let e=0;e<o;++e){const a=t[e];Color_default.pack(a.color,i,d),d+=Color_default.packedLength,i[d++]=a.offset,i[d++]=a.count;const n=a.batchIds,r=n.length;i[d++]=r;for(let e=0;e<r;++e)i[d++]=n[e]}return i}function createVectorTileGeometries(e,t){const a=defined_default(e.boxes)?new Float32Array(e.boxes):void 0,n=defined_default(e.boxBatchIds)?new Uint16Array(e.boxBatchIds):void 0,r=defined_default(e.cylinders)?new Float32Array(e.cylinders):void 0,i=defined_default(e.cylinderBatchIds)?new Uint16Array(e.cylinderBatchIds):void 0,d=defined_default(e.ellipsoids)?new Float32Array(e.ellipsoids):void 0,o=defined_default(e.ellipsoidBatchIds)?new Uint16Array(e.ellipsoidBatchIds):void 0,c=defined_default(e.spheres)?new Float32Array(e.spheres):void 0,l=defined_default(e.sphereBatchIds)?new Uint16Array(e.sphereBatchIds):void 0,s=defined_default(a)?n.length:0,u=defined_default(r)?i.length:0,f=defined_default(d)?o.length:0,h=defined_default(c)?l.length:0,p=BoxGeometry_default.getUnitBox(),_=CylinderGeometry_default.getUnitCylinder(),m=EllipsoidGeometry_default.getUnitEllipsoid(),x=p.attributes.position.values,M=_.attributes.position.values,g=m.attributes.position.values;let k=x.length*s;k+=M.length*u,k+=g.length*(f+h);const B=p.indices,b=_.indices,C=m.indices;let y=B.length*s;y+=b.length*u,y+=C.length*(f+h);const V=new Float32Array(k),I=new Uint16Array(k/3),A=IndexDatatype_default.createTypedArray(k/3,y),L=s+u+f+h,w=new Uint16Array(L),v=new Array(L),T=new Uint32Array(L),j=new Uint32Array(L),O=new Array(L);unpackBuffer(e.packedBuffer);const S={batchTableColors:new Uint32Array(e.batchTableColors),positions:V,vertexBatchIds:I,indices:A,batchIds:w,batchedIndices:v,indexOffsets:T,indexCounts:j,boundingVolumes:O,positionOffset:0,batchIdIndex:0,indexOffset:0,batchedIndicesOffset:0,modelMatrix:scratchMatrix4,center:scratchCenter};createPrimitive(S,a,n,p,boxModelMatrixAndBoundingVolume),createPrimitive(S,r,i,_,cylinderModelMatrixAndBoundingVolume),createPrimitive(S,d,o,m,ellipsoidModelMatrixAndBoundingVolume),createPrimitive(S,c,l,m,sphereModelMatrixAndBoundingVolume);const E=packBuffer(A.BYTES_PER_ELEMENT,v,O);return t.push(V.buffer,I.buffer,A.buffer),t.push(w.buffer,T.buffer,j.buffer),t.push(E.buffer),{positions:V.buffer,vertexBatchIds:I.buffer,indices:A.buffer,indexOffsets:T.buffer,indexCounts:j.buffer,batchIds:w.buffer,packedBuffer:E.buffer}}var createVectorTileGeometries_default=createTaskProcessorWorker_default(createVectorTileGeometries);export{createVectorTileGeometries_default as default};