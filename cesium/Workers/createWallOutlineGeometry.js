define(["./defaultValue-fe22d8c0","./Matrix3-41c58dde","./Transforms-e2d4a55a","./ComponentDatatype-cf1fa08e","./Check-6ede7e26","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./IndexDatatype-2643aa47","./Math-0a2ac845","./WallGeometryLibrary-3e0819ec","./Matrix2-e1298525","./RuntimeError-ef395448","./combine-d9581036","./WebGLConstants-0b1ce7ba","./arrayRemoveDuplicates-d2061e85","./PolylinePipeline-7119eb3f","./EllipsoidGeodesic-5b3623dc","./EllipsoidRhumbLine-ef872433","./IntersectionTests-85350792","./Plane-4c3d403b"],(function(e,i,t,n,o,r,s,a,l,d,m,u,p,f,c,h,g,y,E,w){"use strict";const _=new i.Cartesian3,H=new i.Cartesian3;function C(t){const n=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions,r=t.maximumHeights,s=t.minimumHeights;if(!e.defined(n))throw new o.DeveloperError("options.positions is required.");if(e.defined(r)&&r.length!==n.length)throw new o.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(e.defined(s)&&s.length!==n.length)throw new o.DeveloperError("options.positions and options.minimumHeights must have the same length.");const a=e.defaultValue(t.granularity,l.CesiumMath.RADIANS_PER_DEGREE),d=e.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84);this._positions=n,this._minimumHeights=s,this._maximumHeights=r,this._granularity=a,this._ellipsoid=i.Ellipsoid.clone(d),this._workerName="createWallOutlineGeometry";let m=1+n.length*i.Cartesian3.packedLength+2;e.defined(s)&&(m+=s.length),e.defined(r)&&(m+=r.length),this.packedLength=m+i.Ellipsoid.packedLength+1}C.pack=function(t,n,r){if(!e.defined(t))throw new o.DeveloperError("value is required");if(!e.defined(n))throw new o.DeveloperError("array is required");let s;r=e.defaultValue(r,0);const a=t._positions;let l=a.length;for(n[r++]=l,s=0;s<l;++s,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(a[s],n,r);const d=t._minimumHeights;if(l=e.defined(d)?d.length:0,n[r++]=l,e.defined(d))for(s=0;s<l;++s)n[r++]=d[s];const m=t._maximumHeights;if(l=e.defined(m)?m.length:0,n[r++]=l,e.defined(m))for(s=0;s<l;++s)n[r++]=m[s];return i.Ellipsoid.pack(t._ellipsoid,n,r),n[r+=i.Ellipsoid.packedLength]=t._granularity,n};const v=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),b={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:v,granularity:void 0};return C.unpack=function(t,n,r){if(!e.defined(t))throw new o.DeveloperError("array is required");let s;n=e.defaultValue(n,0);let a=t[n++];const l=new Array(a);for(s=0;s<a;++s,n+=i.Cartesian3.packedLength)l[s]=i.Cartesian3.unpack(t,n);let d,m;if(a=t[n++],a>0)for(d=new Array(a),s=0;s<a;++s)d[s]=t[n++];if(a=t[n++],a>0)for(m=new Array(a),s=0;s<a;++s)m[s]=t[n++];const u=i.Ellipsoid.unpack(t,n,v),p=t[n+=i.Ellipsoid.packedLength];return e.defined(r)?(r._positions=l,r._minimumHeights=d,r._maximumHeights=m,r._ellipsoid=i.Ellipsoid.clone(u,r._ellipsoid),r._granularity=p,r):(b.positions=l,b.minimumHeights=d,b.maximumHeights=m,b.granularity=p,new C(b))},C.fromConstantHeights=function(i){const t=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).positions;if(!e.defined(t))throw new o.DeveloperError("options.positions is required.");let n,r;const s=i.minimumHeight,a=i.maximumHeight,l=e.defined(s),d=e.defined(a);if(l||d){const e=t.length;n=l?new Array(e):void 0,r=d?new Array(e):void 0;for(let i=0;i<e;++i)l&&(n[i]=s),d&&(r[i]=a)}return new C({positions:t,maximumHeights:r,minimumHeights:n,ellipsoid:i.ellipsoid})},C.createGeometry=function(o){const m=o._positions,u=o._minimumHeights,p=o._maximumHeights,f=o._granularity,c=o._ellipsoid,h=d.WallGeometryLibrary.computePositions(c,m,p,u,f,!1);if(!e.defined(h))return;const g=h.bottomPositions,y=h.topPositions;let E=y.length,w=2*E;const C=new Float64Array(w);let v,b=0;for(E/=3,v=0;v<E;++v){const e=3*v,t=i.Cartesian3.fromArray(y,e,_),n=i.Cartesian3.fromArray(g,e,H);C[b++]=n.x,C[b++]=n.y,C[b++]=n.z,C[b++]=t.x,C[b++]=t.y,C[b++]=t.z}const A=new s.GeometryAttributes({position:new r.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:C})}),k=w/3;w=2*k-4+k;const x=a.IndexDatatype.createTypedArray(k,w);let D=0;for(v=0;v<k-2;v+=2){const e=v,t=v+2,n=i.Cartesian3.fromArray(C,3*e,_),o=i.Cartesian3.fromArray(C,3*t,H);if(i.Cartesian3.equalsEpsilon(n,o,l.CesiumMath.EPSILON10))continue;const r=v+1,s=v+3;x[D++]=r,x[D++]=e,x[D++]=r,x[D++]=s,x[D++]=e,x[D++]=t}return x[D++]=k-2,x[D++]=k-1,new r.Geometry({attributes:A,indices:x,primitiveType:r.PrimitiveType.LINES,boundingSphere:new t.BoundingSphere.fromVertices(C)})},function(t,n){return e.defined(n)&&(t=C.unpack(t,n)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),C.createGeometry(t)}}));