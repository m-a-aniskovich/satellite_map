/*! For license information please see createCorridorOutlineGeometry.js.LICENSE.txt */
import{CorridorGeometryLibrary_default}from"./chunk-ZGMOBRTG.js";import{CornerType_default}from"./chunk-D325WRAY.js";import"./chunk-7ONRI7T4.js";import"./chunk-3FCUUN6M.js";import"./chunk-LSGUCCKJ.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import"./chunk-MOLGJDJV.js";import"./chunk-FGUP2QEP.js";import{PolygonPipeline_default}from"./chunk-ZVUAJKAL.js";import{arrayRemoveDuplicates_default}from"./chunk-DTNN3ODA.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var cartesian1=new Cartesian3_default,cartesian2=new Cartesian3_default,cartesian3=new Cartesian3_default;function scaleToSurface(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function combine(t,e){const r=[],i=t.positions,o=t.corners,a=t.endPositions,l=new GeometryAttributes_default;let n,u,s,d=0,f=0,c=0;for(u=0;u<i.length;u+=2)s=i[u].length-3,d+=s,c+=s/3*4,f+=i[u+1].length-3;for(d+=3,f+=3,u=0;u<o.length;u++){n=o[u];const t=o[u].leftPositions;defined_default(t)?(s=t.length,d+=s,c+=s/3*2):(s=o[u].rightPositions.length,f+=s,c+=s/3*2)}const p=defined_default(a);let h;p&&(h=a[0].length-3,d+=h,f+=h,h/=3,c+=4*h);const _=d+f,m=new Float64Array(_);let y,g,C,b,A,G,O=0,k=_-1;const E=h/2,T=IndexDatatype_default.createTypedArray(_/3,c+4);let P=0;if(T[P++]=O/3,T[P++]=(k-2)/3,p){r.push(O/3),G=cartesian1,A=cartesian2;const t=a[0];for(u=0;u<E;u++)G=Cartesian3_default.fromArray(t,3*(E-1-u),G),A=Cartesian3_default.fromArray(t,3*(E+u),A),CorridorGeometryLibrary_default.addAttribute(m,A,O),CorridorGeometryLibrary_default.addAttribute(m,G,void 0,k),g=O/3,b=g+1,y=(k-2)/3,C=y-1,T[P++]=y,T[P++]=C,T[P++]=g,T[P++]=b,O+=3,k-=3}let v=0,D=i[v++],j=i[v++];for(m.set(D,O),m.set(j,k-j.length+1),s=j.length-3,r.push(O/3,(k-2)/3),u=0;u<s;u+=3)g=O/3,b=g+1,y=(k-2)/3,C=y-1,T[P++]=y,T[P++]=C,T[P++]=g,T[P++]=b,O+=3,k-=3;for(u=0;u<o.length;u++){let t;n=o[u];const a=n.leftPositions,l=n.rightPositions;let d,f=cartesian3;if(defined_default(a)){for(k-=3,d=C,r.push(b),t=0;t<a.length/3;t++)f=Cartesian3_default.fromArray(a,3*t,f),T[P++]=d-t-1,T[P++]=d-t,CorridorGeometryLibrary_default.addAttribute(m,f,void 0,k),k-=3;r.push(d-Math.floor(a.length/6)),e===CornerType_default.BEVELED&&r.push((k-2)/3+1),O+=3}else{for(O+=3,d=b,r.push(C),t=0;t<l.length/3;t++)f=Cartesian3_default.fromArray(l,3*t,f),T[P++]=d+t,T[P++]=d+t+1,CorridorGeometryLibrary_default.addAttribute(m,f,O),O+=3;r.push(d+Math.floor(l.length/6)),e===CornerType_default.BEVELED&&r.push(O/3-1),k-=3}for(D=i[v++],j=i[v++],D.splice(0,3),j.splice(j.length-3,3),m.set(D,O),m.set(j,k-j.length+1),s=j.length-3,t=0;t<j.length;t+=3)b=O/3,g=b-1,C=(k-2)/3,y=C+1,T[P++]=y,T[P++]=C,T[P++]=g,T[P++]=b,O+=3,k-=3;O-=3,k+=3,r.push(O/3,(k-2)/3)}if(p){O+=3,k-=3,G=cartesian1,A=cartesian2;const t=a[1];for(u=0;u<E;u++)G=Cartesian3_default.fromArray(t,3*(h-u-1),G),A=Cartesian3_default.fromArray(t,3*u,A),CorridorGeometryLibrary_default.addAttribute(m,G,void 0,k),CorridorGeometryLibrary_default.addAttribute(m,A,O),b=O/3,g=b-1,C=(k-2)/3,y=C+1,T[P++]=y,T[P++]=C,T[P++]=g,T[P++]=b,O+=3,k-=3;r.push(O/3)}else r.push(O/3,(k-2)/3);return T[P++]=O/3,T[P++]=(k-2)/3,l.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:m}),{attributes:l,indices:T,wallIndices:r}}function computePositionsExtruded(t){const e=t.ellipsoid,r=combine(CorridorGeometryLibrary_default.computePositions(t),t.cornerType),i=r.wallIndices,o=t.height,a=t.extrudedHeight,l=r.attributes,n=r.indices;let u=l.position.values,s=u.length,d=new Float64Array(s);d.set(u);const f=new Float64Array(2*s);if(u=PolygonPipeline_default.scaleToGeodeticHeight(u,o,e),d=PolygonPipeline_default.scaleToGeodeticHeight(d,a,e),f.set(u),f.set(d,s),l.position.values=f,s/=3,defined_default(t.offsetAttribute)){let e=new Uint8Array(2*s);if(t.offsetAttribute===GeometryOffsetAttribute_default.TOP)e=e.fill(1,0,s);else{const r=t.offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1;e=e.fill(r)}l.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let c;const p=n.length,h=IndexDatatype_default.createTypedArray(f.length/3,2*(p+i.length));h.set(n);let _,m,y=p;for(c=0;c<p;c+=2){const t=n[c],e=n[c+1];h[y++]=t+s,h[y++]=e+s}for(c=0;c<i.length;c++)_=i[c],m=_+s,h[y++]=_,h[y++]=m;return{attributes:l,indices:h}}function CorridorOutlineGeometry(t){const e=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).positions,r=t.width;Check_default.typeOf.object("options.positions",e),Check_default.typeOf.number("options.width",r);const i=defaultValue_default(t.height,0),o=defaultValue_default(t.extrudedHeight,i);this._positions=e,this._ellipsoid=Ellipsoid_default.clone(defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84)),this._width=r,this._height=Math.max(i,o),this._extrudedHeight=Math.min(i,o),this._cornerType=defaultValue_default(t.cornerType,CornerType_default.ROUNDED),this._granularity=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),this._offsetAttribute=t.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+e.length*Cartesian3_default.packedLength+Ellipsoid_default.packedLength+6}CorridorOutlineGeometry.pack=function(t,e,r){Check_default.typeOf.object("value",t),Check_default.typeOf.object("array",e),r=defaultValue_default(r,0);const i=t._positions,o=i.length;e[r++]=o;for(let t=0;t<o;++t,r+=Cartesian3_default.packedLength)Cartesian3_default.pack(i[t],e,r);return Ellipsoid_default.pack(t._ellipsoid,e,r),r+=Ellipsoid_default.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r]=defaultValue_default(t._offsetAttribute,-1),e};var scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchOptions={positions:void 0,ellipsoid:scratchEllipsoid,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};CorridorOutlineGeometry.unpack=function(t,e,r){Check_default.typeOf.object("array",t),e=defaultValue_default(e,0);const i=t[e++],o=new Array(i);for(let r=0;r<i;++r,e+=Cartesian3_default.packedLength)o[r]=Cartesian3_default.unpack(t,e);const a=Ellipsoid_default.unpack(t,e,scratchEllipsoid);e+=Ellipsoid_default.packedLength;const l=t[e++],n=t[e++],u=t[e++],s=t[e++],d=t[e++],f=t[e];return defined_default(r)?(r._positions=o,r._ellipsoid=Ellipsoid_default.clone(a,r._ellipsoid),r._width=l,r._height=n,r._extrudedHeight=u,r._cornerType=s,r._granularity=d,r._offsetAttribute=-1===f?void 0:f,r):(scratchOptions.positions=o,scratchOptions.width=l,scratchOptions.height=n,scratchOptions.extrudedHeight=u,scratchOptions.cornerType=s,scratchOptions.granularity=d,scratchOptions.offsetAttribute=-1===f?void 0:f,new CorridorOutlineGeometry(scratchOptions))},CorridorOutlineGeometry.createGeometry=function(t){let e=t._positions;const r=t._width,i=t._ellipsoid;e=scaleToSurface(e,i);const o=arrayRemoveDuplicates_default(e,Cartesian3_default.equalsEpsilon);if(o.length<2||r<=0)return;const a=t._height,l=t._extrudedHeight,n=!Math_default.equalsEpsilon(a,l,0,Math_default.EPSILON2),u={ellipsoid:i,positions:o,width:r,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!1};let s;if(n)u.height=a,u.extrudedHeight=l,u.offsetAttribute=t._offsetAttribute,s=computePositionsExtruded(u);else if(s=combine(CorridorGeometryLibrary_default.computePositions(u),u.cornerType),s.attributes.position.values=PolygonPipeline_default.scaleToGeodeticHeight(s.attributes.position.values,a,i),defined_default(t._offsetAttribute)){const e=s.attributes.position.values.length,r=t._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,i=new Uint8Array(e/3).fill(r);s.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}const d=s.attributes,f=BoundingSphere_default.fromVertices(d.position.values,void 0,3);return new Geometry_default({attributes:d,indices:s.indices,primitiveType:PrimitiveType_default.LINES,boundingSphere:f,offsetAttribute:t._offsetAttribute})};var CorridorOutlineGeometry_default=CorridorOutlineGeometry;function createCorridorOutlineGeometry(t,e){return defined_default(e)&&(t=CorridorOutlineGeometry_default.unpack(t,e)),t._ellipsoid=Ellipsoid_default.clone(t._ellipsoid),CorridorOutlineGeometry_default.createGeometry(t)}var createCorridorOutlineGeometry_default=createCorridorOutlineGeometry;export{createCorridorOutlineGeometry_default as default};