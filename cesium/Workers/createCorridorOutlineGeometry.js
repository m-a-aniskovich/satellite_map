define(["./arrayRemoveDuplicates-d2061e85","./Transforms-e2d4a55a","./Matrix3-41c58dde","./Check-6ede7e26","./ComponentDatatype-cf1fa08e","./PolylineVolumeGeometryLibrary-d25f0050","./CorridorGeometryLibrary-63907365","./defaultValue-fe22d8c0","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./GeometryOffsetAttribute-9ad0019c","./IndexDatatype-2643aa47","./Math-0a2ac845","./PolygonPipeline-460cce4e","./Matrix2-e1298525","./RuntimeError-ef395448","./combine-d9581036","./WebGLConstants-0b1ce7ba","./EllipsoidTangentPlane-546c0d5e","./AxisAlignedBoundingBox-4bfd84f3","./IntersectionTests-85350792","./Plane-4c3d403b","./PolylinePipeline-7119eb3f","./EllipsoidGeodesic-5b3623dc","./EllipsoidRhumbLine-ef872433"],(function(e,t,i,r,o,n,s,a,l,d,u,p,c,f,h,y,g,b,m,A,_,C,E,G,T){"use strict";const P=new i.Cartesian3,v=new i.Cartesian3,w=new i.Cartesian3;function L(e,t){const r=[],u=e.positions,c=e.corners,f=e.endPositions,h=new d.GeometryAttributes;let y,g,b,m=0,A=0,_=0;for(g=0;g<u.length;g+=2)b=u[g].length-3,m+=b,_+=b/3*4,A+=u[g+1].length-3;for(m+=3,A+=3,g=0;g<c.length;g++){y=c[g];const e=c[g].leftPositions;a.defined(e)?(b=e.length,m+=b,_+=b/3*2):(b=c[g].rightPositions.length,A+=b,_+=b/3*2)}const C=a.defined(f);let E;C&&(E=f[0].length-3,m+=E,A+=E,E/=3,_+=4*E);const G=m+A,T=new Float64Array(G);let L,k,D,O,x,V,N=0,H=G-1;const I=E/2,M=p.IndexDatatype.createTypedArray(G/3,_+4);let S=0;if(M[S++]=N/3,M[S++]=(H-2)/3,C){r.push(N/3),V=P,x=v;const e=f[0];for(g=0;g<I;g++)V=i.Cartesian3.fromArray(e,3*(I-1-g),V),x=i.Cartesian3.fromArray(e,3*(I+g),x),s.CorridorGeometryLibrary.addAttribute(T,x,N),s.CorridorGeometryLibrary.addAttribute(T,V,void 0,H),k=N/3,O=k+1,L=(H-2)/3,D=L-1,M[S++]=L,M[S++]=D,M[S++]=k,M[S++]=O,N+=3,H-=3}let B=0,R=u[B++],U=u[B++];for(T.set(R,N),T.set(U,H-U.length+1),b=U.length-3,r.push(N/3,(H-2)/3),g=0;g<b;g+=3)k=N/3,O=k+1,L=(H-2)/3,D=L-1,M[S++]=L,M[S++]=D,M[S++]=k,M[S++]=O,N+=3,H-=3;for(g=0;g<c.length;g++){let e;y=c[g];const o=y.leftPositions,l=y.rightPositions;let d,p=w;if(a.defined(o)){for(H-=3,d=D,r.push(O),e=0;e<o.length/3;e++)p=i.Cartesian3.fromArray(o,3*e,p),M[S++]=d-e-1,M[S++]=d-e,s.CorridorGeometryLibrary.addAttribute(T,p,void 0,H),H-=3;r.push(d-Math.floor(o.length/6)),t===n.CornerType.BEVELED&&r.push((H-2)/3+1),N+=3}else{for(N+=3,d=O,r.push(D),e=0;e<l.length/3;e++)p=i.Cartesian3.fromArray(l,3*e,p),M[S++]=d+e,M[S++]=d+e+1,s.CorridorGeometryLibrary.addAttribute(T,p,N),N+=3;r.push(d+Math.floor(l.length/6)),t===n.CornerType.BEVELED&&r.push(N/3-1),H-=3}for(R=u[B++],U=u[B++],R.splice(0,3),U.splice(U.length-3,3),T.set(R,N),T.set(U,H-U.length+1),b=U.length-3,e=0;e<U.length;e+=3)O=N/3,k=O-1,D=(H-2)/3,L=D+1,M[S++]=L,M[S++]=D,M[S++]=k,M[S++]=O,N+=3,H-=3;N-=3,H+=3,r.push(N/3,(H-2)/3)}if(C){N+=3,H-=3,V=P,x=v;const e=f[1];for(g=0;g<I;g++)V=i.Cartesian3.fromArray(e,3*(E-g-1),V),x=i.Cartesian3.fromArray(e,3*g,x),s.CorridorGeometryLibrary.addAttribute(T,V,void 0,H),s.CorridorGeometryLibrary.addAttribute(T,x,N),O=N/3,k=O-1,D=(H-2)/3,L=D+1,M[S++]=L,M[S++]=D,M[S++]=k,M[S++]=O,N+=3,H-=3;r.push(N/3)}else r.push(N/3,(H-2)/3);return M[S++]=N/3,M[S++]=(H-2)/3,h.position=new l.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:T}),{attributes:h,indices:M,wallIndices:r}}function k(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).positions,o=e.width;r.Check.typeOf.object("options.positions",t),r.Check.typeOf.number("options.width",o);const s=a.defaultValue(e.height,0),l=a.defaultValue(e.extrudedHeight,s);this._positions=t,this._ellipsoid=i.Ellipsoid.clone(a.defaultValue(e.ellipsoid,i.Ellipsoid.WGS84)),this._width=o,this._height=Math.max(s,l),this._extrudedHeight=Math.min(s,l),this._cornerType=a.defaultValue(e.cornerType,n.CornerType.ROUNDED),this._granularity=a.defaultValue(e.granularity,c.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*i.Cartesian3.packedLength+i.Ellipsoid.packedLength+6}k.pack=function(e,t,o){r.Check.typeOf.object("value",e),r.Check.typeOf.object("array",t),o=a.defaultValue(o,0);const n=e._positions,s=n.length;t[o++]=s;for(let e=0;e<s;++e,o+=i.Cartesian3.packedLength)i.Cartesian3.pack(n[e],t,o);return i.Ellipsoid.pack(e._ellipsoid,t,o),o+=i.Ellipsoid.packedLength,t[o++]=e._width,t[o++]=e._height,t[o++]=e._extrudedHeight,t[o++]=e._cornerType,t[o++]=e._granularity,t[o]=a.defaultValue(e._offsetAttribute,-1),t};const D=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),O={positions:void 0,ellipsoid:D,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return k.unpack=function(e,t,o){r.Check.typeOf.object("array",e),t=a.defaultValue(t,0);const n=e[t++],s=new Array(n);for(let r=0;r<n;++r,t+=i.Cartesian3.packedLength)s[r]=i.Cartesian3.unpack(e,t);const l=i.Ellipsoid.unpack(e,t,D);t+=i.Ellipsoid.packedLength;const d=e[t++],u=e[t++],p=e[t++],c=e[t++],f=e[t++],h=e[t];return a.defined(o)?(o._positions=s,o._ellipsoid=i.Ellipsoid.clone(l,o._ellipsoid),o._width=d,o._height=u,o._extrudedHeight=p,o._cornerType=c,o._granularity=f,o._offsetAttribute=-1===h?void 0:h,o):(O.positions=s,O.width=d,O.height=u,O.extrudedHeight=p,O.cornerType=c,O.granularity=f,O.offsetAttribute=-1===h?void 0:h,new k(O))},k.createGeometry=function(r){let n=r._positions;const d=r._width,h=r._ellipsoid;n=function(e,t){for(let i=0;i<e.length;i++)e[i]=t.scaleToGeodeticSurface(e[i],e[i]);return e}(n,h);const y=e.arrayRemoveDuplicates(n,i.Cartesian3.equalsEpsilon);if(y.length<2||d<=0)return;const g=r._height,b=r._extrudedHeight,m=!c.CesiumMath.equalsEpsilon(g,b,0,c.CesiumMath.EPSILON2),A={ellipsoid:h,positions:y,width:d,cornerType:r._cornerType,granularity:r._granularity,saveAttributes:!1};let _;if(m)A.height=g,A.extrudedHeight=b,A.offsetAttribute=r._offsetAttribute,_=function(e){const t=e.ellipsoid,i=L(s.CorridorGeometryLibrary.computePositions(e),e.cornerType),r=i.wallIndices,n=e.height,d=e.extrudedHeight,c=i.attributes,h=i.indices;let y=c.position.values,g=y.length,b=new Float64Array(g);b.set(y);const m=new Float64Array(2*g);if(y=f.PolygonPipeline.scaleToGeodeticHeight(y,n,t),b=f.PolygonPipeline.scaleToGeodeticHeight(b,d,t),m.set(y),m.set(b,g),c.position.values=m,g/=3,a.defined(e.offsetAttribute)){let t=new Uint8Array(2*g);if(e.offsetAttribute===u.GeometryOffsetAttribute.TOP)t=t.fill(1,0,g);else{const i=e.offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}c.applyOffset=new l.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let A;const _=h.length,C=p.IndexDatatype.createTypedArray(m.length/3,2*(_+r.length));C.set(h);let E,G,T=_;for(A=0;A<_;A+=2){const e=h[A],t=h[A+1];C[T++]=e+g,C[T++]=t+g}for(A=0;A<r.length;A++)E=r[A],G=E+g,C[T++]=E,C[T++]=G;return{attributes:c,indices:C}}(A);else if(_=L(s.CorridorGeometryLibrary.computePositions(A),A.cornerType),_.attributes.position.values=f.PolygonPipeline.scaleToGeodeticHeight(_.attributes.position.values,g,h),a.defined(r._offsetAttribute)){const e=_.attributes.position.values.length,t=r._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(t);_.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}const C=_.attributes,E=t.BoundingSphere.fromVertices(C.position.values,void 0,3);return new l.Geometry({attributes:C,indices:_.indices,primitiveType:l.PrimitiveType.LINES,boundingSphere:E,offsetAttribute:r._offsetAttribute})},function(e,t){return a.defined(t)&&(e=k.unpack(e,t)),e._ellipsoid=i.Ellipsoid.clone(e._ellipsoid),k.createGeometry(e)}}));