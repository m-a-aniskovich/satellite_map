/*! For license information please see createRectangleGeometry.js.LICENSE.txt */
import{RectangleGeometryLibrary_default}from"./chunk-PXLFBN2Q.js";import{GeometryInstance_default}from"./chunk-GTEXWEAP.js";import{GeometryPipeline_default}from"./chunk-36ESDRIZ.js";import"./chunk-I6TVJ6T7.js";import"./chunk-VOAZN4IP.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import{PolygonPipeline_default}from"./chunk-ZVUAJKAL.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default,Quaternion_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Cartesian2_default,Matrix2_default,Rectangle_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var positionScratch=new Cartesian3_default,normalScratch=new Cartesian3_default,tangentScratch=new Cartesian3_default,bitangentScratch=new Cartesian3_default,rectangleScratch=new Rectangle_default,stScratch=new Cartesian2_default,bottomBoundingSphere=new BoundingSphere_default,topBoundingSphere=new BoundingSphere_default;function createAttributes(t,e){const a=new Geometry_default({attributes:new GeometryAttributes_default,primitiveType:PrimitiveType_default.TRIANGLES});return a.attributes.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(a.attributes.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(a.attributes.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(a.attributes.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:e.bitangents})),a}function calculateAttributes(t,e,a,n){const r=t.length,o=e.normal?new Float32Array(r):void 0,l=e.tangent?new Float32Array(r):void 0,i=e.bitangent?new Float32Array(r):void 0;let u=0;const s=bitangentScratch,c=tangentScratch;let d=normalScratch;if(e.normal||e.tangent||e.bitangent)for(let f=0;f<r;f+=3){const r=Cartesian3_default.fromArray(t,f,positionScratch),_=u+1,m=u+2;d=a.geodeticSurfaceNormal(r,d),(e.tangent||e.bitangent)&&(Cartesian3_default.cross(Cartesian3_default.UNIT_Z,d,c),Matrix3_default.multiplyByVector(n,c,c),Cartesian3_default.normalize(c,c),e.bitangent&&Cartesian3_default.normalize(Cartesian3_default.cross(d,c,s),s)),e.normal&&(o[u]=d.x,o[_]=d.y,o[m]=d.z),e.tangent&&(l[u]=c.x,l[_]=c.y,l[m]=c.z),e.bitangent&&(i[u]=s.x,i[_]=s.y,i[m]=s.z),u+=3}return createAttributes(e,{positions:t,normals:o,tangents:l,bitangents:i})}var v1Scratch=new Cartesian3_default,v2Scratch=new Cartesian3_default;function calculateAttributesWall(t,e,a){const n=t.length,r=e.normal?new Float32Array(n):void 0,o=e.tangent?new Float32Array(n):void 0,l=e.bitangent?new Float32Array(n):void 0;let i=0,u=0,s=0,c=!0,d=bitangentScratch,f=tangentScratch,_=normalScratch;if(e.normal||e.tangent||e.bitangent)for(let m=0;m<n;m+=6){const p=Cartesian3_default.fromArray(t,m,positionScratch),h=Cartesian3_default.fromArray(t,(m+6)%n,v1Scratch);if(c){const e=Cartesian3_default.fromArray(t,(m+3)%n,v2Scratch);Cartesian3_default.subtract(h,p,h),Cartesian3_default.subtract(e,p,e),_=Cartesian3_default.normalize(Cartesian3_default.cross(e,h,_),_),c=!1}Cartesian3_default.equalsEpsilon(h,p,Math_default.EPSILON10)&&(c=!0),(e.tangent||e.bitangent)&&(d=a.geodeticSurfaceNormal(p,d),e.tangent&&(f=Cartesian3_default.normalize(Cartesian3_default.cross(d,_,f),f))),e.normal&&(r[i++]=_.x,r[i++]=_.y,r[i++]=_.z,r[i++]=_.x,r[i++]=_.y,r[i++]=_.z),e.tangent&&(o[u++]=f.x,o[u++]=f.y,o[u++]=f.z,o[u++]=f.x,o[u++]=f.y,o[u++]=f.z),e.bitangent&&(l[s++]=d.x,l[s++]=d.y,l[s++]=d.z,l[s++]=d.x,l[s++]=d.y,l[s++]=d.z)}return createAttributes(e,{positions:t,normals:r,tangents:o,bitangents:l})}function constructRectangle(t,e){const a=t._vertexFormat,n=t._ellipsoid,r=e.height,o=e.width,l=e.northCap,i=e.southCap;let u=0,s=r,c=r,d=0;l&&(u=1,c-=1,d+=1),i&&(s-=1,c-=1,d+=1),d+=o*c;const f=a.position?new Float64Array(3*d):void 0,_=a.st?new Float32Array(2*d):void 0;let m=0,p=0;const h=positionScratch,g=stScratch;let y=Number.MAX_VALUE,b=Number.MAX_VALUE,x=-Number.MAX_VALUE,A=-Number.MAX_VALUE;for(let t=u;t<s;++t)for(let r=0;r<o;++r)RectangleGeometryLibrary_default.computePosition(e,n,a.st,t,r,h,g),f[m++]=h.x,f[m++]=h.y,f[m++]=h.z,a.st&&(_[p++]=g.x,_[p++]=g.y,y=Math.min(y,g.x),b=Math.min(b,g.y),x=Math.max(x,g.x),A=Math.max(A,g.y));if(l&&(RectangleGeometryLibrary_default.computePosition(e,n,a.st,0,0,h,g),f[m++]=h.x,f[m++]=h.y,f[m++]=h.z,a.st&&(_[p++]=g.x,_[p++]=g.y,y=g.x,b=g.y,x=g.x,A=g.y)),i&&(RectangleGeometryLibrary_default.computePosition(e,n,a.st,r-1,0,h,g),f[m++]=h.x,f[m++]=h.y,f[m]=h.z,a.st&&(_[p++]=g.x,_[p]=g.y,y=Math.min(y,g.x),b=Math.min(b,g.y),x=Math.max(x,g.x),A=Math.max(A,g.y))),a.st&&(y<0||b<0||x>1||A>1))for(let t=0;t<_.length;t+=2)_[t]=(_[t]-y)/(x-y),_[t+1]=(_[t+1]-b)/(A-b);const R=calculateAttributes(f,a,n,e.tangentRotationMatrix);let w=6*(o-1)*(c-1);l&&(w+=3*(o-1)),i&&(w+=3*(o-1));const v=IndexDatatype_default.createTypedArray(d,w);let C,S=0,G=0;for(C=0;C<c-1;++C){for(let t=0;t<o-1;++t){const t=S,e=t+o,a=e+1,n=t+1;v[G++]=t,v[G++]=e,v[G++]=n,v[G++]=n,v[G++]=e,v[G++]=a,++S}++S}if(l||i){let t=d-1;const e=d-1;let a,n;if(l&&i&&(t=d-2),S=0,l)for(C=0;C<o-1;C++)a=S,n=a+1,v[G++]=t,v[G++]=a,v[G++]=n,++S;if(i)for(S=(c-1)*o,C=0;C<o-1;C++)a=S,n=a+1,v[G++]=a,v[G++]=e,v[G++]=n,++S}return R.indices=v,a.st&&(R.attributes.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:_})),R}function addWallPositions(t,e,a,n,r){return t[e++]=n[a],t[e++]=n[a+1],t[e++]=n[a+2],t[e++]=r[a],t[e++]=r[a+1],t[e]=r[a+2],t}function addWallTextureCoordinates(t,e,a,n){return t[e++]=n[a],t[e++]=n[a+1],t[e++]=n[a],t[e]=n[a+1],t}var scratchVertexFormat=new VertexFormat_default;function constructExtrudedRectangle(t,e){const a=t._shadowVolume,n=t._offsetAttribute,r=t._vertexFormat,o=t._extrudedHeight,l=t._surfaceHeight,i=t._ellipsoid,u=e.height,s=e.width;let c;if(a){const e=VertexFormat_default.clone(r,scratchVertexFormat);e.normal=!0,t._vertexFormat=e}const d=constructRectangle(t,e);a&&(t._vertexFormat=r);let f=PolygonPipeline_default.scaleToGeodeticHeight(d.attributes.position.values,l,i,!1);f=new Float64Array(f);let _=f.length;const m=2*_,p=new Float64Array(m);p.set(f);const h=PolygonPipeline_default.scaleToGeodeticHeight(d.attributes.position.values,o,i);p.set(h,_),d.attributes.position.values=p;const g=r.normal?new Float32Array(m):void 0,y=r.tangent?new Float32Array(m):void 0,b=r.bitangent?new Float32Array(m):void 0,x=r.st?new Float32Array(m/3*2):void 0;let A,R,w;if(r.normal){for(R=d.attributes.normal.values,g.set(R),c=0;c<_;c++)R[c]=-R[c];g.set(R,_),d.attributes.normal.values=g}if(a){R=d.attributes.normal.values,r.normal||(d.attributes.normal=void 0);const t=new Float32Array(m);for(c=0;c<_;c++)R[c]=-R[c];t.set(R,_),d.attributes.extrudeDirection=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:t})}const v=defined_default(n);if(v){const t=_/3*2;let e=new Uint8Array(t);n===GeometryOffsetAttribute_default.TOP?e=e.fill(1,0,t/2):(w=n===GeometryOffsetAttribute_default.NONE?0:1,e=e.fill(w)),d.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(r.tangent){const t=d.attributes.tangent.values;for(y.set(t),c=0;c<_;c++)t[c]=-t[c];y.set(t,_),d.attributes.tangent.values=y}if(r.bitangent){const t=d.attributes.bitangent.values;b.set(t),b.set(t,_),d.attributes.bitangent.values=b}r.st&&(A=d.attributes.st.values,x.set(A),x.set(A,_/3*2),d.attributes.st.values=x);const C=d.indices,S=C.length,G=_/3,E=IndexDatatype_default.createTypedArray(m/3,2*S);for(E.set(C),c=0;c<S;c+=3)E[c+S]=C[c+2]+G,E[c+1+S]=C[c+1]+G,E[c+2+S]=C[c]+G;d.indices=E;const P=e.northCap,V=e.southCap;let F=u,D=2,k=0,O=4,T=4;P&&(D-=1,F-=1,k+=1,O-=2,T-=1),V&&(D-=1,F-=1,k+=1,O-=2,T-=1),k+=D*s+2*F-O;const L=2*(k+T);let M=new Float64Array(3*L);const N=a?new Float32Array(3*L):void 0;let I=v?new Uint8Array(L):void 0,j=r.st?new Float32Array(2*L):void 0;const B=n===GeometryOffsetAttribute_default.TOP;v&&!B&&(w=n===GeometryOffsetAttribute_default.ALL?1:0,I=I.fill(w));let H=0,W=0,U=0,z=0;const Y=s*F;let J;for(c=0;c<Y;c+=s)J=3*c,M=addWallPositions(M,H,J,f,h),H+=6,r.st&&(j=addWallTextureCoordinates(j,W,2*c,A),W+=4),a&&(U+=3,N[U++]=R[J],N[U++]=R[J+1],N[U++]=R[J+2]),B&&(I[z++]=1,z+=1);if(V){const t=P?Y+1:Y;for(J=3*t,c=0;c<2;c++)M=addWallPositions(M,H,J,f,h),H+=6,r.st&&(j=addWallTextureCoordinates(j,W,2*t,A),W+=4),a&&(U+=3,N[U++]=R[J],N[U++]=R[J+1],N[U++]=R[J+2]),B&&(I[z++]=1,z+=1)}else for(c=Y-s;c<Y;c++)J=3*c,M=addWallPositions(M,H,J,f,h),H+=6,r.st&&(j=addWallTextureCoordinates(j,W,2*c,A),W+=4),a&&(U+=3,N[U++]=R[J],N[U++]=R[J+1],N[U++]=R[J+2]),B&&(I[z++]=1,z+=1);for(c=Y-1;c>0;c-=s)J=3*c,M=addWallPositions(M,H,J,f,h),H+=6,r.st&&(j=addWallTextureCoordinates(j,W,2*c,A),W+=4),a&&(U+=3,N[U++]=R[J],N[U++]=R[J+1],N[U++]=R[J+2]),B&&(I[z++]=1,z+=1);if(P){const t=Y;for(J=3*t,c=0;c<2;c++)M=addWallPositions(M,H,J,f,h),H+=6,r.st&&(j=addWallTextureCoordinates(j,W,2*t,A),W+=4),a&&(U+=3,N[U++]=R[J],N[U++]=R[J+1],N[U++]=R[J+2]),B&&(I[z++]=1,z+=1)}else for(c=s-1;c>=0;c--)J=3*c,M=addWallPositions(M,H,J,f,h),H+=6,r.st&&(j=addWallTextureCoordinates(j,W,2*c,A),W+=4),a&&(U+=3,N[U++]=R[J],N[U++]=R[J+1],N[U++]=R[J+2]),B&&(I[z++]=1,z+=1);let q=calculateAttributesWall(M,r,i);r.st&&(q.attributes.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:j})),a&&(q.attributes.extrudeDirection=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:N})),v&&(q.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:I}));const X=IndexDatatype_default.createTypedArray(L,6*k);let Z,Q,K,$;_=M.length/3;let tt=0;for(c=0;c<_-1;c+=2){Z=c,$=(Z+2)%_;const t=Cartesian3_default.fromArray(M,3*Z,v1Scratch),e=Cartesian3_default.fromArray(M,3*$,v2Scratch);Cartesian3_default.equalsEpsilon(t,e,Math_default.EPSILON10)||(Q=(Z+1)%_,K=(Q+2)%_,X[tt++]=Z,X[tt++]=Q,X[tt++]=$,X[tt++]=$,X[tt++]=Q,X[tt++]=K)}return q.indices=X,q=GeometryPipeline_default.combineInstances([new GeometryInstance_default({geometry:d}),new GeometryInstance_default({geometry:q})]),q[0]}var scratchRectanglePoints=[new Cartesian3_default,new Cartesian3_default,new Cartesian3_default,new Cartesian3_default],nwScratch=new Cartographic_default,stNwScratch=new Cartographic_default;function computeRectangle(t,e,a,n,r){if(0===a)return Rectangle_default.clone(t,r);const o=RectangleGeometryLibrary_default.computeOptions(t,e,a,0,rectangleScratch,nwScratch),l=o.height,i=o.width,u=scratchRectanglePoints;return RectangleGeometryLibrary_default.computePosition(o,n,!1,0,0,u[0]),RectangleGeometryLibrary_default.computePosition(o,n,!1,0,i-1,u[1]),RectangleGeometryLibrary_default.computePosition(o,n,!1,l-1,0,u[2]),RectangleGeometryLibrary_default.computePosition(o,n,!1,l-1,i-1,u[3]),Rectangle_default.fromCartesianArray(u,n,r)}function RectangleGeometry(t){const e=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).rectangle;if(Check_default.typeOf.object("rectangle",e),Rectangle_default.validate(e),e.north<e.south)throw new DeveloperError_default("options.rectangle.north must be greater than or equal to options.rectangle.south");const a=defaultValue_default(t.height,0),n=defaultValue_default(t.extrudedHeight,a);this._rectangle=Rectangle_default.clone(e),this._granularity=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),this._ellipsoid=Ellipsoid_default.clone(defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84)),this._surfaceHeight=Math.max(a,n),this._rotation=defaultValue_default(t.rotation,0),this._stRotation=defaultValue_default(t.stRotation,0),this._vertexFormat=VertexFormat_default.clone(defaultValue_default(t.vertexFormat,VertexFormat_default.DEFAULT)),this._extrudedHeight=Math.min(a,n),this._shadowVolume=defaultValue_default(t.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}RectangleGeometry.packedLength=Rectangle_default.packedLength+Ellipsoid_default.packedLength+VertexFormat_default.packedLength+7,RectangleGeometry.pack=function(t,e,a){return Check_default.typeOf.object("value",t),Check_default.defined("array",e),a=defaultValue_default(a,0),Rectangle_default.pack(t._rectangle,e,a),a+=Rectangle_default.packedLength,Ellipsoid_default.pack(t._ellipsoid,e,a),a+=Ellipsoid_default.packedLength,VertexFormat_default.pack(t._vertexFormat,e,a),a+=VertexFormat_default.packedLength,e[a++]=t._granularity,e[a++]=t._surfaceHeight,e[a++]=t._rotation,e[a++]=t._stRotation,e[a++]=t._extrudedHeight,e[a++]=t._shadowVolume?1:0,e[a]=defaultValue_default(t._offsetAttribute,-1),e};var scratchRectangle=new Rectangle_default,scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchOptions={rectangle:scratchRectangle,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};RectangleGeometry.unpack=function(t,e,a){Check_default.defined("array",t),e=defaultValue_default(e,0);const n=Rectangle_default.unpack(t,e,scratchRectangle);e+=Rectangle_default.packedLength;const r=Ellipsoid_default.unpack(t,e,scratchEllipsoid);e+=Ellipsoid_default.packedLength;const o=VertexFormat_default.unpack(t,e,scratchVertexFormat);e+=VertexFormat_default.packedLength;const l=t[e++],i=t[e++],u=t[e++],s=t[e++],c=t[e++],d=1===t[e++],f=t[e];return defined_default(a)?(a._rectangle=Rectangle_default.clone(n,a._rectangle),a._ellipsoid=Ellipsoid_default.clone(r,a._ellipsoid),a._vertexFormat=VertexFormat_default.clone(o,a._vertexFormat),a._granularity=l,a._surfaceHeight=i,a._rotation=u,a._stRotation=s,a._extrudedHeight=c,a._shadowVolume=d,a._offsetAttribute=-1===f?void 0:f,a):(scratchOptions.granularity=l,scratchOptions.height=i,scratchOptions.rotation=u,scratchOptions.stRotation=s,scratchOptions.extrudedHeight=c,scratchOptions.shadowVolume=d,scratchOptions.offsetAttribute=-1===f?void 0:f,new RectangleGeometry(scratchOptions))},RectangleGeometry.computeRectangle=function(t,e){const a=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).rectangle;if(Check_default.typeOf.object("rectangle",a),Rectangle_default.validate(a),a.north<a.south)throw new DeveloperError_default("options.rectangle.north must be greater than or equal to options.rectangle.south");const n=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),r=defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84);return computeRectangle(a,n,defaultValue_default(t.rotation,0),r,e)};var tangentRotationMatrixScratch=new Matrix3_default,quaternionScratch=new Quaternion_default,centerScratch=new Cartographic_default;RectangleGeometry.createGeometry=function(t){if(Math_default.equalsEpsilon(t._rectangle.north,t._rectangle.south,Math_default.EPSILON10)||Math_default.equalsEpsilon(t._rectangle.east,t._rectangle.west,Math_default.EPSILON10))return;let e=t._rectangle;const a=t._ellipsoid,n=t._rotation,r=t._stRotation,o=t._vertexFormat,l=RectangleGeometryLibrary_default.computeOptions(e,t._granularity,n,r,rectangleScratch,nwScratch,stNwScratch),i=tangentRotationMatrixScratch;if(0!==r||0!==n){const t=Rectangle_default.center(e,centerScratch),n=a.geodeticSurfaceNormalCartographic(t,v1Scratch);Quaternion_default.fromAxisAngle(n,-r,quaternionScratch),Matrix3_default.fromQuaternion(quaternionScratch,i)}else Matrix3_default.clone(Matrix3_default.IDENTITY,i);const u=t._surfaceHeight,s=t._extrudedHeight,c=!Math_default.equalsEpsilon(u,s,0,Math_default.EPSILON2);let d,f;if(l.lonScalar=1/t._rectangle.width,l.latScalar=1/t._rectangle.height,l.tangentRotationMatrix=i,e=t._rectangle,c){d=constructExtrudedRectangle(t,l);const n=BoundingSphere_default.fromRectangle3D(e,a,u,topBoundingSphere),r=BoundingSphere_default.fromRectangle3D(e,a,s,bottomBoundingSphere);f=BoundingSphere_default.union(n,r)}else{if(d=constructRectangle(t,l),d.attributes.position.values=PolygonPipeline_default.scaleToGeodeticHeight(d.attributes.position.values,u,a,!1),defined_default(t._offsetAttribute)){const e=d.attributes.position.values.length,a=t._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,n=new Uint8Array(e/3).fill(a);d.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}f=BoundingSphere_default.fromRectangle3D(e,a,u)}return o.position||delete d.attributes.position,new Geometry_default({attributes:d.attributes,indices:d.indices,primitiveType:d.primitiveType,boundingSphere:f,offsetAttribute:t._offsetAttribute})},RectangleGeometry.createShadowVolume=function(t,e,a){const n=t._granularity,r=t._ellipsoid,o=e(n,r),l=a(n,r);return new RectangleGeometry({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:r,stRotation:t._stRotation,granularity:n,extrudedHeight:l,height:o,vertexFormat:VertexFormat_default.POSITION_ONLY,shadowVolume:!0})};var unrotatedTextureRectangleScratch=new Rectangle_default,points2DScratch=[new Cartesian2_default,new Cartesian2_default,new Cartesian2_default],rotation2DScratch=new Matrix2_default,rectangleCenterScratch=new Cartographic_default;function textureCoordinateRotationPoints(t){if(0===t._stRotation)return[0,0,0,1,1,0];const e=Rectangle_default.clone(t._rectangle,unrotatedTextureRectangleScratch),a=t._granularity,n=t._ellipsoid,r=computeRectangle(e,a,t._rotation-t._stRotation,n,unrotatedTextureRectangleScratch),o=points2DScratch;o[0].x=r.west,o[0].y=r.south,o[1].x=r.west,o[1].y=r.north,o[2].x=r.east,o[2].y=r.south;const l=t.rectangle,i=Matrix2_default.fromRotation(t._stRotation,rotation2DScratch),u=Rectangle_default.center(l,rectangleCenterScratch);for(let t=0;t<3;++t){const e=o[t];e.x-=u.longitude,e.y-=u.latitude,Matrix2_default.multiplyByVector(i,e,e),e.x+=u.longitude,e.y+=u.latitude,e.x=(e.x-l.west)/l.width,e.y=(e.y-l.south)/l.height}const s=o[0],c=o[1],d=o[2],f=new Array(6);return Cartesian2_default.pack(s,f),Cartesian2_default.pack(c,f,2),Cartesian2_default.pack(d,f,4),f}Object.defineProperties(RectangleGeometry.prototype,{rectangle:{get:function(){return defined_default(this._rotatedRectangle)||(this._rotatedRectangle=computeRectangle(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return defined_default(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=textureCoordinateRotationPoints(this)),this._textureCoordinateRotationPoints}}});var RectangleGeometry_default=RectangleGeometry;function createRectangleGeometry(t,e){return defined_default(e)&&(t=RectangleGeometry_default.unpack(t,e)),t._ellipsoid=Ellipsoid_default.clone(t._ellipsoid),t._rectangle=Rectangle_default.clone(t._rectangle),RectangleGeometry_default.createGeometry(t)}var createRectangleGeometry_default=createRectangleGeometry;export{createRectangleGeometry_default as default};