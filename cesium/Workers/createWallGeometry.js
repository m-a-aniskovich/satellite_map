define(["./defaultValue-fe22d8c0","./Matrix3-41c58dde","./Transforms-e2d4a55a","./ComponentDatatype-cf1fa08e","./Check-6ede7e26","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./IndexDatatype-2643aa47","./Math-0a2ac845","./VertexFormat-030f11ff","./WallGeometryLibrary-3e0819ec","./Matrix2-e1298525","./RuntimeError-ef395448","./combine-d9581036","./WebGLConstants-0b1ce7ba","./arrayRemoveDuplicates-d2061e85","./PolylinePipeline-7119eb3f","./EllipsoidGeodesic-5b3623dc","./EllipsoidRhumbLine-ef872433","./IntersectionTests-85350792","./Plane-4c3d403b"],(function(e,t,i,n,r,a,o,s,l,m,d,p,u,c,f,h,g,y,C,w,x){"use strict";const E=new t.Cartesian3,v=new t.Cartesian3,A=new t.Cartesian3,b=new t.Cartesian3,_=new t.Cartesian3,F=new t.Cartesian3,D=new t.Cartesian3;function L(i){const n=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).positions,a=i.maximumHeights,o=i.minimumHeights;if(!e.defined(n))throw new r.DeveloperError("options.positions is required.");if(e.defined(a)&&a.length!==n.length)throw new r.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(e.defined(o)&&o.length!==n.length)throw new r.DeveloperError("options.positions and options.minimumHeights must have the same length.");const s=e.defaultValue(i.vertexFormat,m.VertexFormat.DEFAULT),d=e.defaultValue(i.granularity,l.CesiumMath.RADIANS_PER_DEGREE),p=e.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84);this._positions=n,this._minimumHeights=o,this._maximumHeights=a,this._vertexFormat=m.VertexFormat.clone(s),this._granularity=d,this._ellipsoid=t.Ellipsoid.clone(p),this._workerName="createWallGeometry";let u=1+n.length*t.Cartesian3.packedLength+2;e.defined(o)&&(u+=o.length),e.defined(a)&&(u+=a.length),this.packedLength=u+t.Ellipsoid.packedLength+m.VertexFormat.packedLength+1}L.pack=function(i,n,a){if(!e.defined(i))throw new r.DeveloperError("value is required");if(!e.defined(n))throw new r.DeveloperError("array is required");let o;a=e.defaultValue(a,0);const s=i._positions;let l=s.length;for(n[a++]=l,o=0;o<l;++o,a+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[o],n,a);const d=i._minimumHeights;if(l=e.defined(d)?d.length:0,n[a++]=l,e.defined(d))for(o=0;o<l;++o)n[a++]=d[o];const p=i._maximumHeights;if(l=e.defined(p)?p.length:0,n[a++]=l,e.defined(p))for(o=0;o<l;++o)n[a++]=p[o];return t.Ellipsoid.pack(i._ellipsoid,n,a),a+=t.Ellipsoid.packedLength,m.VertexFormat.pack(i._vertexFormat,n,a),n[a+=m.VertexFormat.packedLength]=i._granularity,n};const H=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),k=new m.VertexFormat,V={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:H,vertexFormat:k,granularity:void 0};return L.unpack=function(i,n,a){if(!e.defined(i))throw new r.DeveloperError("array is required");let o;n=e.defaultValue(n,0);let s=i[n++];const l=new Array(s);for(o=0;o<s;++o,n+=t.Cartesian3.packedLength)l[o]=t.Cartesian3.unpack(i,n);let d,p;if(s=i[n++],s>0)for(d=new Array(s),o=0;o<s;++o)d[o]=i[n++];if(s=i[n++],s>0)for(p=new Array(s),o=0;o<s;++o)p[o]=i[n++];const u=t.Ellipsoid.unpack(i,n,H);n+=t.Ellipsoid.packedLength;const c=m.VertexFormat.unpack(i,n,k),f=i[n+=m.VertexFormat.packedLength];return e.defined(a)?(a._positions=l,a._minimumHeights=d,a._maximumHeights=p,a._ellipsoid=t.Ellipsoid.clone(u,a._ellipsoid),a._vertexFormat=m.VertexFormat.clone(c,a._vertexFormat),a._granularity=f,a):(V.positions=l,V.minimumHeights=d,V.maximumHeights=p,V.granularity=f,new L(V))},L.fromConstantHeights=function(t){const i=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions;if(!e.defined(i))throw new r.DeveloperError("options.positions is required.");let n,a;const o=t.minimumHeight,s=t.maximumHeight,l=e.defined(o),m=e.defined(s);if(l||m){const e=i.length;n=l?new Array(e):void 0,a=m?new Array(e):void 0;for(let t=0;t<e;++t)l&&(n[t]=o),m&&(a[t]=s)}return new L({positions:i,maximumHeights:a,minimumHeights:n,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},L.createGeometry=function(r){const m=r._positions,p=r._minimumHeights,u=r._maximumHeights,c=r._vertexFormat,f=r._granularity,h=r._ellipsoid,g=d.WallGeometryLibrary.computePositions(h,m,u,p,f,!0);if(!e.defined(g))return;const y=g.bottomPositions,C=g.topPositions,w=g.numCorners;let x=C.length,L=2*x;const H=c.position?new Float64Array(L):void 0,k=c.normal?new Float32Array(L):void 0,V=c.tangent?new Float32Array(L):void 0,G=c.bitangent?new Float32Array(L):void 0,P=c.st?new Float32Array(L/3*2):void 0;let T,z=0,O=0,R=0,S=0,I=0,M=D,q=F,N=_,W=!0;x/=3;let B=0;const U=1/(x-w-1);for(T=0;T<x;++T){const e=3*T,i=t.Cartesian3.fromArray(C,e,E),n=t.Cartesian3.fromArray(y,e,v);if(c.position&&(H[z++]=n.x,H[z++]=n.y,H[z++]=n.z,H[z++]=i.x,H[z++]=i.y,H[z++]=i.z),c.st&&(P[I++]=B,P[I++]=0,P[I++]=B,P[I++]=1),c.normal||c.tangent||c.bitangent){let n=t.Cartesian3.clone(t.Cartesian3.ZERO,b);const r=t.Cartesian3.subtract(i,h.geodeticSurfaceNormal(i,v),v);if(T+1<x&&(n=t.Cartesian3.fromArray(C,e+3,b)),W){const e=t.Cartesian3.subtract(n,i,A),a=t.Cartesian3.subtract(r,i,E);M=t.Cartesian3.normalize(t.Cartesian3.cross(a,e,M),M),W=!1}t.Cartesian3.equalsEpsilon(i,n,l.CesiumMath.EPSILON10)?W=!0:(B+=U,c.tangent&&(q=t.Cartesian3.normalize(t.Cartesian3.subtract(n,i,q),q)),c.bitangent&&(N=t.Cartesian3.normalize(t.Cartesian3.cross(M,q,N),N))),c.normal&&(k[O++]=M.x,k[O++]=M.y,k[O++]=M.z,k[O++]=M.x,k[O++]=M.y,k[O++]=M.z),c.tangent&&(V[S++]=q.x,V[S++]=q.y,V[S++]=q.z,V[S++]=q.x,V[S++]=q.y,V[S++]=q.z),c.bitangent&&(G[R++]=N.x,G[R++]=N.y,G[R++]=N.z,G[R++]=N.x,G[R++]=N.y,G[R++]=N.z)}}const J=new o.GeometryAttributes;c.position&&(J.position=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:H})),c.normal&&(J.normal=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k})),c.tangent&&(J.tangent=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),c.bitangent&&(J.bitangent=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),c.st&&(J.st=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:P}));const Y=L/3;L-=6*(w+1);const Z=s.IndexDatatype.createTypedArray(Y,L);let j=0;for(T=0;T<Y-2;T+=2){const e=T,i=T+2,n=t.Cartesian3.fromArray(H,3*e,E),r=t.Cartesian3.fromArray(H,3*i,v);if(t.Cartesian3.equalsEpsilon(n,r,l.CesiumMath.EPSILON10))continue;const a=T+1,o=T+3;Z[j++]=a,Z[j++]=e,Z[j++]=o,Z[j++]=o,Z[j++]=e,Z[j++]=i}return new a.Geometry({attributes:J,indices:Z,primitiveType:a.PrimitiveType.TRIANGLES,boundingSphere:new i.BoundingSphere.fromVertices(H)})},function(i,n){return e.defined(n)&&(i=L.unpack(i,n)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),L.createGeometry(i)}}));