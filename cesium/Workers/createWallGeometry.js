/*! For license information please see createWallGeometry.js.LICENSE.txt */
import{WallGeometryLibrary_default}from"./chunk-CHDJ66UM.js";import"./chunk-3FCUUN6M.js";import"./chunk-LSGUCCKJ.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import"./chunk-DTNN3ODA.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var scratchCartesian3Position1=new Cartesian3_default,scratchCartesian3Position2=new Cartesian3_default,scratchCartesian3Position4=new Cartesian3_default,scratchCartesian3Position5=new Cartesian3_default,scratchBitangent=new Cartesian3_default,scratchTangent=new Cartesian3_default,scratchNormal=new Cartesian3_default;function WallGeometry(t){const e=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).positions,a=t.maximumHeights,r=t.minimumHeights;if(!defined_default(e))throw new DeveloperError_default("options.positions is required.");if(defined_default(a)&&a.length!==e.length)throw new DeveloperError_default("options.positions and options.maximumHeights must have the same length.");if(defined_default(r)&&r.length!==e.length)throw new DeveloperError_default("options.positions and options.minimumHeights must have the same length.");const i=defaultValue_default(t.vertexFormat,VertexFormat_default.DEFAULT),n=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),o=defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84);this._positions=e,this._minimumHeights=r,this._maximumHeights=a,this._vertexFormat=VertexFormat_default.clone(i),this._granularity=n,this._ellipsoid=Ellipsoid_default.clone(o),this._workerName="createWallGeometry";let l=1+e.length*Cartesian3_default.packedLength+2;defined_default(r)&&(l+=r.length),defined_default(a)&&(l+=a.length),this.packedLength=l+Ellipsoid_default.packedLength+VertexFormat_default.packedLength+1}WallGeometry.pack=function(t,e,a){if(!defined_default(t))throw new DeveloperError_default("value is required");if(!defined_default(e))throw new DeveloperError_default("array is required");let r;a=defaultValue_default(a,0);const i=t._positions;let n=i.length;for(e[a++]=n,r=0;r<n;++r,a+=Cartesian3_default.packedLength)Cartesian3_default.pack(i[r],e,a);const o=t._minimumHeights;if(n=defined_default(o)?o.length:0,e[a++]=n,defined_default(o))for(r=0;r<n;++r)e[a++]=o[r];const l=t._maximumHeights;if(n=defined_default(l)?l.length:0,e[a++]=n,defined_default(l))for(r=0;r<n;++r)e[a++]=l[r];return Ellipsoid_default.pack(t._ellipsoid,e,a),a+=Ellipsoid_default.packedLength,VertexFormat_default.pack(t._vertexFormat,e,a),e[a+=VertexFormat_default.packedLength]=t._granularity,e};var scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchVertexFormat=new VertexFormat_default,scratchOptions={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,granularity:void 0};WallGeometry.unpack=function(t,e,a){if(!defined_default(t))throw new DeveloperError_default("array is required");let r;e=defaultValue_default(e,0);let i=t[e++];const n=new Array(i);for(r=0;r<i;++r,e+=Cartesian3_default.packedLength)n[r]=Cartesian3_default.unpack(t,e);let o,l;if(i=t[e++],i>0)for(o=new Array(i),r=0;r<i;++r)o[r]=t[e++];if(i=t[e++],i>0)for(l=new Array(i),r=0;r<i;++r)l[r]=t[e++];const s=Ellipsoid_default.unpack(t,e,scratchEllipsoid);e+=Ellipsoid_default.packedLength;const u=VertexFormat_default.unpack(t,e,scratchVertexFormat),d=t[e+=VertexFormat_default.packedLength];return defined_default(a)?(a._positions=n,a._minimumHeights=o,a._maximumHeights=l,a._ellipsoid=Ellipsoid_default.clone(s,a._ellipsoid),a._vertexFormat=VertexFormat_default.clone(u,a._vertexFormat),a._granularity=d,a):(scratchOptions.positions=n,scratchOptions.minimumHeights=o,scratchOptions.maximumHeights=l,scratchOptions.granularity=d,new WallGeometry(scratchOptions))},WallGeometry.fromConstantHeights=function(t){const e=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).positions;if(!defined_default(e))throw new DeveloperError_default("options.positions is required.");let a,r;const i=t.minimumHeight,n=t.maximumHeight,o=defined_default(i),l=defined_default(n);if(o||l){const t=e.length;a=o?new Array(t):void 0,r=l?new Array(t):void 0;for(let e=0;e<t;++e)o&&(a[e]=i),l&&(r[e]=n)}return new WallGeometry({positions:e,maximumHeights:r,minimumHeights:a,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},WallGeometry.createGeometry=function(t){const e=t._positions,a=t._minimumHeights,r=t._maximumHeights,i=t._vertexFormat,n=t._granularity,o=t._ellipsoid,l=WallGeometryLibrary_default.computePositions(o,e,r,a,n,!0);if(!defined_default(l))return;const s=l.bottomPositions,u=l.topPositions,d=l.numCorners;let f=u.length,m=2*f;const c=i.position?new Float64Array(m):void 0,_=i.normal?new Float32Array(m):void 0,p=i.tangent?new Float32Array(m):void 0,h=i.bitangent?new Float32Array(m):void 0,y=i.st?new Float32Array(m/3*2):void 0;let g,C=0,E=0,v=0,w=0,x=0,k=scratchNormal,A=scratchTangent,P=scratchBitangent,D=!0;f/=3;let F=0;const G=1/(f-d-1);for(g=0;g<f;++g){const t=3*g,e=Cartesian3_default.fromArray(u,t,scratchCartesian3Position1),a=Cartesian3_default.fromArray(s,t,scratchCartesian3Position2);if(i.position&&(c[C++]=a.x,c[C++]=a.y,c[C++]=a.z,c[C++]=e.x,c[C++]=e.y,c[C++]=e.z),i.st&&(y[x++]=F,y[x++]=0,y[x++]=F,y[x++]=1),i.normal||i.tangent||i.bitangent){let a=Cartesian3_default.clone(Cartesian3_default.ZERO,scratchCartesian3Position5);const r=Cartesian3_default.subtract(e,o.geodeticSurfaceNormal(e,scratchCartesian3Position2),scratchCartesian3Position2);if(g+1<f&&(a=Cartesian3_default.fromArray(u,t+3,scratchCartesian3Position5)),D){const t=Cartesian3_default.subtract(a,e,scratchCartesian3Position4),i=Cartesian3_default.subtract(r,e,scratchCartesian3Position1);k=Cartesian3_default.normalize(Cartesian3_default.cross(i,t,k),k),D=!1}Cartesian3_default.equalsEpsilon(e,a,Math_default.EPSILON10)?D=!0:(F+=G,i.tangent&&(A=Cartesian3_default.normalize(Cartesian3_default.subtract(a,e,A),A)),i.bitangent&&(P=Cartesian3_default.normalize(Cartesian3_default.cross(k,A,P),P))),i.normal&&(_[E++]=k.x,_[E++]=k.y,_[E++]=k.z,_[E++]=k.x,_[E++]=k.y,_[E++]=k.z),i.tangent&&(p[w++]=A.x,p[w++]=A.y,p[w++]=A.z,p[w++]=A.x,p[w++]=A.y,p[w++]=A.z),i.bitangent&&(h[v++]=P.x,h[v++]=P.y,h[v++]=P.z,h[v++]=P.x,h[v++]=P.y,h[v++]=P.z)}}const V=new GeometryAttributes_default;i.position&&(V.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:c})),i.normal&&(V.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:_})),i.tangent&&(V.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:p})),i.bitangent&&(V.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:h})),i.st&&(V.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:y}));const b=m/3;m-=6*(d+1);const H=IndexDatatype_default.createTypedArray(b,m);let L=0;for(g=0;g<b-2;g+=2){const t=g,e=g+2,a=Cartesian3_default.fromArray(c,3*t,scratchCartesian3Position1),r=Cartesian3_default.fromArray(c,3*e,scratchCartesian3Position2);if(Cartesian3_default.equalsEpsilon(a,r,Math_default.EPSILON10))continue;const i=g+1,n=g+3;H[L++]=i,H[L++]=t,H[L++]=n,H[L++]=n,H[L++]=t,H[L++]=e}return new Geometry_default({attributes:V,indices:H,primitiveType:PrimitiveType_default.TRIANGLES,boundingSphere:new BoundingSphere_default.fromVertices(c)})};var WallGeometry_default=WallGeometry;function createWallGeometry(t,e){return defined_default(e)&&(t=WallGeometry_default.unpack(t,e)),t._ellipsoid=Ellipsoid_default.clone(t._ellipsoid),WallGeometry_default.createGeometry(t)}var createWallGeometry_default=createWallGeometry;export{createWallGeometry_default as default};