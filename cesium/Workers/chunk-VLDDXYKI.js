/*! For license information please see chunk-VLDDXYKI.js.LICENSE.txt */
import{EllipseGeometryLibrary_default}from"./chunk-FRG2Z7DE.js";import{GeometryInstance_default}from"./chunk-GTEXWEAP.js";import{GeometryPipeline_default}from"./chunk-36ESDRIZ.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default,GeographicProjection_default,Quaternion_default}from"./chunk-D4YHO4NZ.js";import{Cartesian2_default,Rectangle_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var scratchCartesian1=new Cartesian3_default,scratchCartesian2=new Cartesian3_default,scratchCartesian3=new Cartesian3_default,scratchCartesian4=new Cartesian3_default,texCoordScratch=new Cartesian2_default,textureMatrixScratch=new Matrix3_default,tangentMatrixScratch=new Matrix3_default,quaternionScratch=new Quaternion_default,scratchNormal=new Cartesian3_default,scratchTangent=new Cartesian3_default,scratchBitangent=new Cartesian3_default,scratchCartographic=new Cartographic_default,projectedCenterScratch=new Cartesian3_default,scratchMinTexCoord=new Cartesian2_default,scratchMaxTexCoord=new Cartesian2_default;function computeTopBottomAttributes(t,e,a){const r=e.vertexFormat,o=e.center,i=e.semiMajorAxis,n=e.semiMinorAxis,s=e.ellipsoid,l=e.stRotation,u=a?t.length/3*2:t.length/3,d=e.shadowVolume,c=r.st?new Float32Array(2*u):void 0,f=r.normal?new Float32Array(3*u):void 0,_=r.tangent?new Float32Array(3*u):void 0,m=r.bitangent?new Float32Array(3*u):void 0,p=d?new Float32Array(3*u):void 0;let h=0,y=scratchNormal,x=scratchTangent,g=scratchBitangent;const C=new GeographicProjection_default(s),A=C.project(s.cartesianToCartographic(o,scratchCartographic),projectedCenterScratch),b=s.scaleToGeodeticSurface(o,scratchCartesian1);s.geodeticSurfaceNormal(b,b);let E=textureMatrixScratch,S=tangentMatrixScratch;if(0!==l){let t=Quaternion_default.fromAxisAngle(b,l,quaternionScratch);E=Matrix3_default.fromQuaternion(t,E),t=Quaternion_default.fromAxisAngle(b,-l,quaternionScratch),S=Matrix3_default.fromQuaternion(t,S)}else E=Matrix3_default.clone(Matrix3_default.IDENTITY,E),S=Matrix3_default.clone(Matrix3_default.IDENTITY,S);const M=Cartesian2_default.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,scratchMinTexCoord),w=Cartesian2_default.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,scratchMaxTexCoord);let T=t.length;const G=a?T:0,I=G/3*2;for(let e=0;e<T;e+=3){const o=e+1,l=e+2,u=Cartesian3_default.fromArray(t,e,scratchCartesian1);if(r.st){const t=Matrix3_default.multiplyByVector(E,u,scratchCartesian2),e=C.project(s.cartesianToCartographic(t,scratchCartographic),scratchCartesian3);Cartesian3_default.subtract(e,A,e),texCoordScratch.x=(e.x+i)/(2*i),texCoordScratch.y=(e.y+n)/(2*n),M.x=Math.min(texCoordScratch.x,M.x),M.y=Math.min(texCoordScratch.y,M.y),w.x=Math.max(texCoordScratch.x,w.x),w.y=Math.max(texCoordScratch.y,w.y),a&&(c[h+I]=texCoordScratch.x,c[h+1+I]=texCoordScratch.y),c[h++]=texCoordScratch.x,c[h++]=texCoordScratch.y}(r.normal||r.tangent||r.bitangent||d)&&(y=s.geodeticSurfaceNormal(u,y),d&&(p[e+G]=-y.x,p[o+G]=-y.y,p[l+G]=-y.z),(r.normal||r.tangent||r.bitangent)&&((r.tangent||r.bitangent)&&(x=Cartesian3_default.normalize(Cartesian3_default.cross(Cartesian3_default.UNIT_Z,y,x),x),Matrix3_default.multiplyByVector(S,x,x)),r.normal&&(f[e]=y.x,f[o]=y.y,f[l]=y.z,a&&(f[e+G]=-y.x,f[o+G]=-y.y,f[l+G]=-y.z)),r.tangent&&(_[e]=x.x,_[o]=x.y,_[l]=x.z,a&&(_[e+G]=-x.x,_[o+G]=-x.y,_[l+G]=-x.z)),r.bitangent&&(g=Cartesian3_default.normalize(Cartesian3_default.cross(y,x,g),g),m[e]=g.x,m[o]=g.y,m[l]=g.z,a&&(m[e+G]=g.x,m[o+G]=g.y,m[l+G]=g.z))))}if(r.st){T=c.length;for(let t=0;t<T;t+=2)c[t]=(c[t]-M.x)/(w.x-M.x),c[t+1]=(c[t+1]-M.y)/(w.y-M.y)}const P=new GeometryAttributes_default;if(r.position){const r=EllipseGeometryLibrary_default.raisePositionsToHeight(t,e,a);P.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:r})}if(r.st&&(P.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:c})),r.normal&&(P.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:f})),r.tangent&&(P.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:_})),r.bitangent&&(P.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:m})),d&&(P.extrudeDirection=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:p})),a&&defined_default(e.offsetAttribute)){let t=new Uint8Array(u);if(e.offsetAttribute===GeometryOffsetAttribute_default.TOP)t=t.fill(1,0,u/2);else{const a=e.offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1;t=t.fill(a)}P.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return P}function topIndices(t){const e=new Array(t*(t+1)*12-6);let a,r,o,i,n,s=0;for(a=0,o=1,i=0;i<3;i++)e[s++]=o++,e[s++]=a,e[s++]=o;for(i=2;i<t+1;++i){for(o=i*(i+1)-1,a=(i-1)*i-1,e[s++]=o++,e[s++]=a,e[s++]=o,r=2*i,n=0;n<r-1;++n)e[s++]=o,e[s++]=a++,e[s++]=a,e[s++]=o++,e[s++]=a,e[s++]=o;e[s++]=o++,e[s++]=a,e[s++]=o}for(r=2*t,++o,++a,i=0;i<r-1;++i)e[s++]=o,e[s++]=a++,e[s++]=a,e[s++]=o++,e[s++]=a,e[s++]=o;for(e[s++]=o,e[s++]=a++,e[s++]=a,e[s++]=o++,e[s++]=a++,e[s++]=a,++a,i=t-1;i>1;--i){for(e[s++]=a++,e[s++]=a,e[s++]=o,r=2*i,n=0;n<r-1;++n)e[s++]=o,e[s++]=a++,e[s++]=a,e[s++]=o++,e[s++]=a,e[s++]=o;e[s++]=a++,e[s++]=a++,e[s++]=o++}for(i=0;i<3;i++)e[s++]=a++,e[s++]=a,e[s++]=o;return e}var boundingSphereCenter=new Cartesian3_default;function computeEllipse(t){const e=t.center;boundingSphereCenter=Cartesian3_default.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(e,boundingSphereCenter),t.height,boundingSphereCenter),boundingSphereCenter=Cartesian3_default.add(e,boundingSphereCenter,boundingSphereCenter);const a=new BoundingSphere_default(boundingSphereCenter,t.semiMajorAxis),r=EllipseGeometryLibrary_default.computeEllipsePositions(t,!0,!1),o=r.positions,i=r.numPts,n=computeTopBottomAttributes(o,t,!1);let s=topIndices(i);return s=IndexDatatype_default.createTypedArray(o.length/3,s),{boundingSphere:a,attributes:n,indices:s}}function computeWallAttributes(t,e){const a=e.vertexFormat,r=e.center,o=e.semiMajorAxis,i=e.semiMinorAxis,n=e.ellipsoid,s=e.height,l=e.extrudedHeight,u=e.stRotation,d=t.length/3*2,c=new Float64Array(3*d),f=a.st?new Float32Array(2*d):void 0,_=a.normal?new Float32Array(3*d):void 0,m=a.tangent?new Float32Array(3*d):void 0,p=a.bitangent?new Float32Array(3*d):void 0,h=e.shadowVolume,y=h?new Float32Array(3*d):void 0;let x=0,g=scratchNormal,C=scratchTangent,A=scratchBitangent;const b=new GeographicProjection_default(n),E=b.project(n.cartesianToCartographic(r,scratchCartographic),projectedCenterScratch),S=n.scaleToGeodeticSurface(r,scratchCartesian1);n.geodeticSurfaceNormal(S,S);const M=Quaternion_default.fromAxisAngle(S,u,quaternionScratch),w=Matrix3_default.fromQuaternion(M,textureMatrixScratch),T=Cartesian2_default.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,scratchMinTexCoord),G=Cartesian2_default.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,scratchMaxTexCoord);let I=t.length;const P=I/3*2;for(let e=0;e<I;e+=3){const r=e+1,u=e+2;let d,S=Cartesian3_default.fromArray(t,e,scratchCartesian1);if(a.st){const t=Matrix3_default.multiplyByVector(w,S,scratchCartesian2),e=b.project(n.cartesianToCartographic(t,scratchCartographic),scratchCartesian3);Cartesian3_default.subtract(e,E,e),texCoordScratch.x=(e.x+o)/(2*o),texCoordScratch.y=(e.y+i)/(2*i),T.x=Math.min(texCoordScratch.x,T.x),T.y=Math.min(texCoordScratch.y,T.y),G.x=Math.max(texCoordScratch.x,G.x),G.y=Math.max(texCoordScratch.y,G.y),f[x+P]=texCoordScratch.x,f[x+1+P]=texCoordScratch.y,f[x++]=texCoordScratch.x,f[x++]=texCoordScratch.y}S=n.scaleToGeodeticSurface(S,S),d=Cartesian3_default.clone(S,scratchCartesian2),g=n.geodeticSurfaceNormal(S,g),h&&(y[e+I]=-g.x,y[r+I]=-g.y,y[u+I]=-g.z);let M=Cartesian3_default.multiplyByScalar(g,s,scratchCartesian4);if(S=Cartesian3_default.add(S,M,S),M=Cartesian3_default.multiplyByScalar(g,l,M),d=Cartesian3_default.add(d,M,d),a.position&&(c[e+I]=d.x,c[r+I]=d.y,c[u+I]=d.z,c[e]=S.x,c[r]=S.y,c[u]=S.z),a.normal||a.tangent||a.bitangent){A=Cartesian3_default.clone(g,A);const o=Cartesian3_default.fromArray(t,(e+3)%I,scratchCartesian4);Cartesian3_default.subtract(o,S,o);const i=Cartesian3_default.subtract(d,S,scratchCartesian3);g=Cartesian3_default.normalize(Cartesian3_default.cross(i,o,g),g),a.normal&&(_[e]=g.x,_[r]=g.y,_[u]=g.z,_[e+I]=g.x,_[r+I]=g.y,_[u+I]=g.z),a.tangent&&(C=Cartesian3_default.normalize(Cartesian3_default.cross(A,g,C),C),m[e]=C.x,m[r]=C.y,m[u]=C.z,m[e+I]=C.x,m[e+1+I]=C.y,m[e+2+I]=C.z),a.bitangent&&(p[e]=A.x,p[r]=A.y,p[u]=A.z,p[e+I]=A.x,p[r+I]=A.y,p[u+I]=A.z)}}if(a.st){I=f.length;for(let t=0;t<I;t+=2)f[t]=(f[t]-T.x)/(G.x-T.x),f[t+1]=(f[t+1]-T.y)/(G.y-T.y)}const v=new GeometryAttributes_default;if(a.position&&(v.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:c})),a.st&&(v.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:f})),a.normal&&(v.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:_})),a.tangent&&(v.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:m})),a.bitangent&&(v.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:p})),h&&(v.extrudeDirection=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:y})),defined_default(e.offsetAttribute)){let t=new Uint8Array(d);if(e.offsetAttribute===GeometryOffsetAttribute_default.TOP)t=t.fill(1,0,d/2);else{const a=e.offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1;t=t.fill(a)}v.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return v}function computeWallIndices(t){const e=t.length/3,a=IndexDatatype_default.createTypedArray(e,6*e);let r=0;for(let t=0;t<e;t++){const o=t,i=t+e,n=(o+1)%e,s=n+e;a[r++]=o,a[r++]=i,a[r++]=n,a[r++]=n,a[r++]=i,a[r++]=s}return a}var topBoundingSphere=new BoundingSphere_default,bottomBoundingSphere=new BoundingSphere_default;function computeExtrudedEllipse(t){const e=t.center,a=t.ellipsoid,r=t.semiMajorAxis;let o=Cartesian3_default.multiplyByScalar(a.geodeticSurfaceNormal(e,scratchCartesian1),t.height,scratchCartesian1);topBoundingSphere.center=Cartesian3_default.add(e,o,topBoundingSphere.center),topBoundingSphere.radius=r,o=Cartesian3_default.multiplyByScalar(a.geodeticSurfaceNormal(e,o),t.extrudedHeight,o),bottomBoundingSphere.center=Cartesian3_default.add(e,o,bottomBoundingSphere.center),bottomBoundingSphere.radius=r;const i=EllipseGeometryLibrary_default.computeEllipsePositions(t,!0,!0),n=i.positions,s=i.numPts,l=i.outerPositions,u=BoundingSphere_default.union(topBoundingSphere,bottomBoundingSphere),d=computeTopBottomAttributes(n,t,!0);let c=topIndices(s);const f=c.length;c.length=2*f;const _=n.length/3;for(let t=0;t<f;t+=3)c[t+f]=c[t+2]+_,c[t+1+f]=c[t+1]+_,c[t+2+f]=c[t]+_;const m=IndexDatatype_default.createTypedArray(2*_/3,c),p=new Geometry_default({attributes:d,indices:m,primitiveType:PrimitiveType_default.TRIANGLES}),h=computeWallAttributes(l,t);c=computeWallIndices(l);const y=IndexDatatype_default.createTypedArray(2*l.length/3,c),x=new Geometry_default({attributes:h,indices:y,primitiveType:PrimitiveType_default.TRIANGLES}),g=GeometryPipeline_default.combineInstances([new GeometryInstance_default({geometry:p}),new GeometryInstance_default({geometry:x})]);return{boundingSphere:u,attributes:g[0].attributes,indices:g[0].indices}}function computeRectangle(t,e,a,r,o,i,n){const s=EllipseGeometryLibrary_default.computeEllipsePositions({center:t,semiMajorAxis:e,semiMinorAxis:a,rotation:r,granularity:o},!1,!0).outerPositions,l=s.length/3,u=new Array(l);for(let t=0;t<l;++t)u[t]=Cartesian3_default.fromArray(s,3*t);const d=Rectangle_default.fromCartesianArray(u,i,n);return d.width>Math_default.PI&&(d.north=d.north>0?Math_default.PI_OVER_TWO-Math_default.EPSILON7:d.north,d.south=d.south<0?Math_default.EPSILON7-Math_default.PI_OVER_TWO:d.south,d.east=Math_default.PI,d.west=-Math_default.PI),d}function EllipseGeometry(t){const e=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).center,a=defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84),r=t.semiMajorAxis,o=t.semiMinorAxis,i=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),n=defaultValue_default(t.vertexFormat,VertexFormat_default.DEFAULT);if(Check_default.defined("options.center",e),Check_default.typeOf.number("options.semiMajorAxis",r),Check_default.typeOf.number("options.semiMinorAxis",o),r<o)throw new DeveloperError_default("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(i<=0)throw new DeveloperError_default("granularity must be greater than zero.");const s=defaultValue_default(t.height,0),l=defaultValue_default(t.extrudedHeight,s);this._center=Cartesian3_default.clone(e),this._semiMajorAxis=r,this._semiMinorAxis=o,this._ellipsoid=Ellipsoid_default.clone(a),this._rotation=defaultValue_default(t.rotation,0),this._stRotation=defaultValue_default(t.stRotation,0),this._height=Math.max(l,s),this._granularity=i,this._vertexFormat=VertexFormat_default.clone(n),this._extrudedHeight=Math.min(l,s),this._shadowVolume=defaultValue_default(t.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}EllipseGeometry.packedLength=Cartesian3_default.packedLength+Ellipsoid_default.packedLength+VertexFormat_default.packedLength+9,EllipseGeometry.pack=function(t,e,a){return Check_default.defined("value",t),Check_default.defined("array",e),a=defaultValue_default(a,0),Cartesian3_default.pack(t._center,e,a),a+=Cartesian3_default.packedLength,Ellipsoid_default.pack(t._ellipsoid,e,a),a+=Ellipsoid_default.packedLength,VertexFormat_default.pack(t._vertexFormat,e,a),a+=VertexFormat_default.packedLength,e[a++]=t._semiMajorAxis,e[a++]=t._semiMinorAxis,e[a++]=t._rotation,e[a++]=t._stRotation,e[a++]=t._height,e[a++]=t._granularity,e[a++]=t._extrudedHeight,e[a++]=t._shadowVolume?1:0,e[a]=defaultValue_default(t._offsetAttribute,-1),e};var scratchCenter=new Cartesian3_default,scratchEllipsoid=new Ellipsoid_default,scratchVertexFormat=new VertexFormat_default,scratchOptions={center:scratchCenter,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};function textureCoordinateRotationPoints(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const a=EllipseGeometryLibrary_default.computeEllipsePositions({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,rotation:t._rotation,granularity:t._granularity},!1,!0).outerPositions,r=a.length/3,o=new Array(r);for(let t=0;t<r;++t)o[t]=Cartesian3_default.fromArray(a,3*t);const i=t._ellipsoid,n=t.rectangle;return Geometry_default._textureCoordinateRotationPoints(o,e,i,n)}EllipseGeometry.unpack=function(t,e,a){Check_default.defined("array",t),e=defaultValue_default(e,0);const r=Cartesian3_default.unpack(t,e,scratchCenter);e+=Cartesian3_default.packedLength;const o=Ellipsoid_default.unpack(t,e,scratchEllipsoid);e+=Ellipsoid_default.packedLength;const i=VertexFormat_default.unpack(t,e,scratchVertexFormat);e+=VertexFormat_default.packedLength;const n=t[e++],s=t[e++],l=t[e++],u=t[e++],d=t[e++],c=t[e++],f=t[e++],_=1===t[e++],m=t[e];return defined_default(a)?(a._center=Cartesian3_default.clone(r,a._center),a._ellipsoid=Ellipsoid_default.clone(o,a._ellipsoid),a._vertexFormat=VertexFormat_default.clone(i,a._vertexFormat),a._semiMajorAxis=n,a._semiMinorAxis=s,a._rotation=l,a._stRotation=u,a._height=d,a._granularity=c,a._extrudedHeight=f,a._shadowVolume=_,a._offsetAttribute=-1===m?void 0:m,a):(scratchOptions.height=d,scratchOptions.extrudedHeight=f,scratchOptions.granularity=c,scratchOptions.stRotation=u,scratchOptions.rotation=l,scratchOptions.semiMajorAxis=n,scratchOptions.semiMinorAxis=s,scratchOptions.shadowVolume=_,scratchOptions.offsetAttribute=-1===m?void 0:m,new EllipseGeometry(scratchOptions))},EllipseGeometry.computeRectangle=function(t,e){const a=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).center,r=defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84),o=t.semiMajorAxis,i=t.semiMinorAxis,n=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),s=defaultValue_default(t.rotation,0);if(Check_default.defined("options.center",a),Check_default.typeOf.number("options.semiMajorAxis",o),Check_default.typeOf.number("options.semiMinorAxis",i),o<i)throw new DeveloperError_default("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(n<=0)throw new DeveloperError_default("granularity must be greater than zero.");return computeRectangle(a,o,i,s,n,r,e)},EllipseGeometry.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const e=t._height,a=t._extrudedHeight,r=!Math_default.equalsEpsilon(e,a,0,Math_default.EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const o={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:e,granularity:t._granularity,vertexFormat:t._vertexFormat,stRotation:t._stRotation};let i;if(r)o.extrudedHeight=a,o.shadowVolume=t._shadowVolume,o.offsetAttribute=t._offsetAttribute,i=computeExtrudedEllipse(o);else if(i=computeEllipse(o),defined_default(t._offsetAttribute)){const e=i.attributes.position.values.length,a=t._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,r=new Uint8Array(e/3).fill(a);i.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new Geometry_default({attributes:i.attributes,indices:i.indices,primitiveType:PrimitiveType_default.TRIANGLES,boundingSphere:i.boundingSphere,offsetAttribute:t._offsetAttribute})},EllipseGeometry.createShadowVolume=function(t,e,a){const r=t._granularity,o=t._ellipsoid,i=e(r,o),n=a(r,o);return new EllipseGeometry({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:o,rotation:t._rotation,stRotation:t._stRotation,granularity:r,extrudedHeight:i,height:n,vertexFormat:VertexFormat_default.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(EllipseGeometry.prototype,{rectangle:{get:function(){return defined_default(this._rectangle)||(this._rectangle=computeRectangle(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return defined_default(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=textureCoordinateRotationPoints(this)),this._textureCoordinateRotationPoints}}});var EllipseGeometry_default=EllipseGeometry;export{EllipseGeometry_default};