define(["exports","./Matrix2-e1298525","./Matrix3-41c58dde","./EllipsoidTangentPlane-546c0d5e","./Math-0a2ac845","./PolylinePipeline-7119eb3f","./Transforms-e2d4a55a","./defaultValue-fe22d8c0","./Check-6ede7e26"],(function(e,a,t,n,r,i,s,o,l){"use strict";var c=Object.freeze({ROUNDED:0,MITERED:1,BEVELED:2});const C={};function u(e,a){if(!o.defined(e))throw new l.DeveloperError("identifier is required.");o.defined(C[e])||(C[e]=!0,console.warn(o.defaultValue(a,e)))}u.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",u.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",u.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",u.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";const d=[new t.Cartesian3,new t.Cartesian3],g=new t.Cartesian3,y=new t.Cartesian3,f=new t.Cartesian3,h=new t.Cartesian3,m=new t.Cartesian3,p=new t.Cartesian3,w=new t.Cartesian3,x=new t.Cartesian3,E=new t.Cartesian3,P=new t.Cartesian3,M=new t.Cartesian3,T={};let b=new t.Cartographic;function B(e,a,n,r){const i=e[0],s=e[1],o=t.Cartesian3.angleBetween(i,s),l=Math.ceil(o/r),c=new Array(l);let C;if(a===n){for(C=0;C<l;C++)c[C]=a;return c.push(n),c}const u=(n-a)/l;for(C=1;C<l;C++){const e=a+C*u;c[C]=e}return c[0]=a,c.push(n),c}const z=new t.Cartesian3,S=new t.Cartesian3,A=new t.Cartesian3(-1,0,0);let D=new a.Matrix4;const R=new a.Matrix4;let O=new t.Matrix3;const V=t.Matrix3.IDENTITY.clone(),v=new t.Cartesian3,I=new a.Cartesian4,N=new t.Cartesian3;function G(e,r,i,o,l,c,C,u){let d=v,g=I;D=s.Transforms.eastNorthUpToFixedFrame(e,l,D),d=a.Matrix4.multiplyByPointAsVector(D,A,d),d=t.Cartesian3.normalize(d,d);const y=function(e,r,i,s){const o=new n.EllipsoidTangentPlane(i,s),l=o.projectPointOntoPlane(t.Cartesian3.add(i,e,z),z),c=o.projectPointOntoPlane(t.Cartesian3.add(i,r,S),S),C=a.Cartesian2.angleBetween(l,c);return c.x*l.y-c.y*l.x>=0?-C:C}(d,r,e,l);O=t.Matrix3.fromRotationZ(y,O),N.z=c,D=a.Matrix4.multiplyTransformation(D,a.Matrix4.fromRotationTranslation(O,N,R),D);const f=V;f[0]=C;for(let e=0;e<u;e++)for(let e=0;e<i.length;e+=3)g=t.Cartesian3.fromArray(i,e,g),g=t.Matrix3.multiplyByVector(f,g,g),g=a.Matrix4.multiplyByPoint(D,g,g),o.push(g.x,g.y,g.z);return o}const H=new t.Cartesian3;function L(e,a,n,r,i,s,o){for(let l=0;l<e.length;l+=3)r=G(t.Cartesian3.fromArray(e,l,H),a,n,r,i,s[l/3],o,1);return r}function j(e,a){const t=e.length,n=new Array(3*t);let r=0;const i=a.x+a.width/2,s=a.y+a.height/2;for(let a=0;a<t;a++)n[r++]=e[a].x-i,n[r++]=0,n[r++]=e[a].y-s;return n}const q=new s.Quaternion,Q=new t.Cartesian3,F=new t.Matrix3;function U(e,a,n,i,o,l,C,u,d,g){const y=t.Cartesian3.angleBetween(t.Cartesian3.subtract(a,e,P),t.Cartesian3.subtract(n,e,M)),f=i===c.BEVELED?0:Math.ceil(y/r.CesiumMath.toRadians(5));let h,m,p;if(h=o?t.Matrix3.fromQuaternion(s.Quaternion.fromAxisAngle(t.Cartesian3.negate(e,P),y/(f+1),q),F):t.Matrix3.fromQuaternion(s.Quaternion.fromAxisAngle(e,y/(f+1),q),F),a=t.Cartesian3.clone(a,Q),f>0){const n=g?2:1;for(let r=0;r<f;r++)a=t.Matrix3.multiplyByVector(h,a,a),m=t.Cartesian3.subtract(a,e,P),m=t.Cartesian3.normalize(m,m),o||(m=t.Cartesian3.negate(m,m)),p=l.scaleToGeodeticSurface(a,M),C=G(p,m,u,C,l,d,1,n)}else m=t.Cartesian3.subtract(a,e,P),m=t.Cartesian3.normalize(m,m),o||(m=t.Cartesian3.negate(m,m)),p=l.scaleToGeodeticSurface(a,M),C=G(p,m,u,C,l,d,1,1),n=t.Cartesian3.clone(n,Q),m=t.Cartesian3.subtract(n,e,P),m=t.Cartesian3.normalize(m,m),o||(m=t.Cartesian3.negate(m,m)),p=l.scaleToGeodeticSurface(n,M),C=G(p,m,u,C,l,d,1,1);return C}T.removeDuplicatesFromShape=function(e){const t=e.length,n=[];for(let r=t-1,i=0;i<t;r=i++){const t=e[r],s=e[i];a.Cartesian2.equals(t,s)||n.push(s)}return n},T.angleIsGreaterThanPi=function(e,a,r,i){const s=new n.EllipsoidTangentPlane(r,i),o=s.projectPointOntoPlane(t.Cartesian3.add(r,e,z),z),l=s.projectPointOntoPlane(t.Cartesian3.add(r,a,S),S);return l.x*o.y-l.y*o.x>=0};const _=new t.Cartesian3,Z=new t.Cartesian3;T.computePositions=function(e,a,n,s,o){const l=s._ellipsoid,C=function(e,a){const t=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];b=a.cartesianToCartographic(r,b),t[n]=b.height,e[n]=a.scaleToGeodeticSurface(r,r)}return t}(e,l),M=s._granularity,z=s._cornerType,S=o?function(e,a){const t=e.length,n=new Array(6*t);let r=0;const i=a.x+a.width/2,s=a.y+a.height/2;let o=e[0];n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s;for(let a=1;a<t;a++){o=e[a];const t=o.x-i,l=o.y-s;n[r++]=t,n[r++]=0,n[r++]=l,n[r++]=t,n[r++]=0,n[r++]=l}return o=e[0],n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s,n}(a,n):j(a,n),A=o?j(a,n):void 0,D=n.height/2,R=n.width/2;let O=e.length,V=[],v=o?[]:void 0,I=g,N=y,H=f,q=h,Q=m,F=p,k=w,W=x,Y=E,J=e[0],K=e[1];q=l.geodeticSurfaceNormal(J,q),I=t.Cartesian3.subtract(K,J,I),I=t.Cartesian3.normalize(I,I),W=t.Cartesian3.cross(q,I,W),W=t.Cartesian3.normalize(W,W);let X,$,ee=C[0],ae=C[1];o&&(v=G(J,W,A,v,l,ee+D,1,1)),Y=t.Cartesian3.clone(J,Y),J=K,N=t.Cartesian3.negate(I,N);for(let a=1;a<O-1;a++){const n=o?2:1;if(K=e[a+1],J.equals(K)){u("Positions are too close and are considered equivalent with rounding error.");continue}I=t.Cartesian3.subtract(K,J,I),I=t.Cartesian3.normalize(I,I),H=t.Cartesian3.add(I,N,H),H=t.Cartesian3.normalize(H,H),q=l.geodeticSurfaceNormal(J,q);const s=t.Cartesian3.multiplyByScalar(q,t.Cartesian3.dot(I,q),_);t.Cartesian3.subtract(I,s,s),t.Cartesian3.normalize(s,s);const g=t.Cartesian3.multiplyByScalar(q,t.Cartesian3.dot(N,q),Z);if(t.Cartesian3.subtract(N,g,g),t.Cartesian3.normalize(g,g),r.CesiumMath.equalsEpsilon(Math.abs(t.Cartesian3.dot(s,g)),1,r.CesiumMath.EPSILON7))V=G(Y,W,S,V,l,ee+D,1,1),Y=J;else{H=t.Cartesian3.cross(H,q,H),H=t.Cartesian3.cross(q,H,H),H=t.Cartesian3.normalize(H,H);const e=1/Math.max(.25,t.Cartesian3.magnitude(t.Cartesian3.cross(H,N,P))),a=T.angleIsGreaterThanPi(I,N,J,l);a?(Q=t.Cartesian3.add(J,t.Cartesian3.multiplyByScalar(H,e*R,H),Q),F=t.Cartesian3.add(Q,t.Cartesian3.multiplyByScalar(W,R,F),F),d[0]=t.Cartesian3.clone(Y,d[0]),d[1]=t.Cartesian3.clone(F,d[1]),X=B(d,ee+D,ae+D,M),$=i.PolylinePipeline.generateArc({positions:d,granularity:M,ellipsoid:l}),V=L($,W,S,V,l,X,1),W=t.Cartesian3.cross(q,I,W),W=t.Cartesian3.normalize(W,W),k=t.Cartesian3.add(Q,t.Cartesian3.multiplyByScalar(W,R,k),k),z===c.ROUNDED||z===c.BEVELED?U(Q,F,k,z,a,l,V,S,ae+D,o):(H=t.Cartesian3.negate(H,H),V=G(J,H,S,V,l,ae+D,e,n)),Y=t.Cartesian3.clone(k,Y)):(Q=t.Cartesian3.add(J,t.Cartesian3.multiplyByScalar(H,e*R,H),Q),F=t.Cartesian3.add(Q,t.Cartesian3.multiplyByScalar(W,-R,F),F),d[0]=t.Cartesian3.clone(Y,d[0]),d[1]=t.Cartesian3.clone(F,d[1]),X=B(d,ee+D,ae+D,M),$=i.PolylinePipeline.generateArc({positions:d,granularity:M,ellipsoid:l}),V=L($,W,S,V,l,X,1),W=t.Cartesian3.cross(q,I,W),W=t.Cartesian3.normalize(W,W),k=t.Cartesian3.add(Q,t.Cartesian3.multiplyByScalar(W,-R,k),k),z===c.ROUNDED||z===c.BEVELED?U(Q,F,k,z,a,l,V,S,ae+D,o):V=G(J,H,S,V,l,ae+D,e,n),Y=t.Cartesian3.clone(k,Y)),N=t.Cartesian3.negate(I,N)}ee=ae,ae=C[a+1],J=K}d[0]=t.Cartesian3.clone(Y,d[0]),d[1]=t.Cartesian3.clone(J,d[1]),X=B(d,ee+D,ae+D,M),$=i.PolylinePipeline.generateArc({positions:d,granularity:M,ellipsoid:l}),V=L($,W,S,V,l,X,1),o&&(v=G(J,W,A,v,l,ae+D,1,1)),O=V.length;const te=o?O+v.length:O,ne=new Float64Array(te);return ne.set(V),o&&ne.set(v,O),ne};var k=T;e.CornerType=c,e.PolylineVolumeGeometryLibrary=k,e.oneTimeWarning=u}));