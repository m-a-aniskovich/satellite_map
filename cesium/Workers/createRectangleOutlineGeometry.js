define(["./defaultValue-fe22d8c0","./Matrix3-41c58dde","./Matrix2-e1298525","./Transforms-e2d4a55a","./ComponentDatatype-cf1fa08e","./Check-6ede7e26","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./GeometryOffsetAttribute-9ad0019c","./IndexDatatype-2643aa47","./Math-0a2ac845","./PolygonPipeline-460cce4e","./RectangleGeometryLibrary-bb378fb6","./RuntimeError-ef395448","./combine-d9581036","./WebGLConstants-0b1ce7ba","./EllipsoidRhumbLine-ef872433"],(function(e,t,i,n,o,r,a,l,s,u,c,d,p,f,g,h,y){"use strict";const m=new n.BoundingSphere,b=new n.BoundingSphere,_=new t.Cartesian3,E=new i.Rectangle;function A(e,t){const i=e._ellipsoid,n=t.height,r=t.width,s=t.northCap,c=t.southCap;let d=n,f=2,g=0,h=4;s&&(f-=1,d-=1,g+=1,h-=2),c&&(f-=1,d-=1,g+=1,h-=2),g+=f*r+2*d-h;const y=new Float64Array(3*g);let m,b=0,E=0;const A=_;if(s)p.RectangleGeometryLibrary.computePosition(t,i,!1,E,0,A),y[b++]=A.x,y[b++]=A.y,y[b++]=A.z;else for(m=0;m<r;m++)p.RectangleGeometryLibrary.computePosition(t,i,!1,E,m,A),y[b++]=A.x,y[b++]=A.y,y[b++]=A.z;for(m=r-1,E=1;E<n;E++)p.RectangleGeometryLibrary.computePosition(t,i,!1,E,m,A),y[b++]=A.x,y[b++]=A.y,y[b++]=A.z;if(E=n-1,!c)for(m=r-2;m>=0;m--)p.RectangleGeometryLibrary.computePosition(t,i,!1,E,m,A),y[b++]=A.x,y[b++]=A.y,y[b++]=A.z;for(m=0,E=n-2;E>0;E--)p.RectangleGeometryLibrary.computePosition(t,i,!1,E,m,A),y[b++]=A.x,y[b++]=A.y,y[b++]=A.z;const w=y.length/3*2,G=u.IndexDatatype.createTypedArray(y.length/3,w);let v=0;for(let e=0;e<y.length/3-1;e++)G[v++]=e,G[v++]=e+1;G[v++]=y.length/3-1,G[v++]=0;const R=new a.Geometry({attributes:new l.GeometryAttributes,primitiveType:a.PrimitiveType.LINES});return R.attributes.position=new a.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:y}),R.indices=G,R}function w(n){const o=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).rectangle,a=e.defaultValue(n.granularity,c.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84),s=e.defaultValue(n.rotation,0);if(!e.defined(o))throw new r.DeveloperError("rectangle is required.");if(i.Rectangle.validate(o),o.north<o.south)throw new r.DeveloperError("options.rectangle.north must be greater than options.rectangle.south");const u=e.defaultValue(n.height,0),d=e.defaultValue(n.extrudedHeight,u);this._rectangle=i.Rectangle.clone(o),this._granularity=a,this._ellipsoid=l,this._surfaceHeight=Math.max(u,d),this._rotation=s,this._extrudedHeight=Math.min(u,d),this._offsetAttribute=n.offsetAttribute,this._workerName="createRectangleOutlineGeometry"}w.packedLength=i.Rectangle.packedLength+t.Ellipsoid.packedLength+5,w.pack=function(n,o,a){if(!e.defined(n))throw new r.DeveloperError("value is required");if(!e.defined(o))throw new r.DeveloperError("array is required");return a=e.defaultValue(a,0),i.Rectangle.pack(n._rectangle,o,a),a+=i.Rectangle.packedLength,t.Ellipsoid.pack(n._ellipsoid,o,a),a+=t.Ellipsoid.packedLength,o[a++]=n._granularity,o[a++]=n._surfaceHeight,o[a++]=n._rotation,o[a++]=n._extrudedHeight,o[a]=e.defaultValue(n._offsetAttribute,-1),o};const G=new i.Rectangle,v=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),R={rectangle:G,ellipsoid:v,granularity:void 0,height:void 0,rotation:void 0,extrudedHeight:void 0,offsetAttribute:void 0};w.unpack=function(n,o,a){if(!e.defined(n))throw new r.DeveloperError("array is required");o=e.defaultValue(o,0);const l=i.Rectangle.unpack(n,o,G);o+=i.Rectangle.packedLength;const s=t.Ellipsoid.unpack(n,o,v);o+=t.Ellipsoid.packedLength;const u=n[o++],c=n[o++],d=n[o++],p=n[o++],f=n[o];return e.defined(a)?(a._rectangle=i.Rectangle.clone(l,a._rectangle),a._ellipsoid=t.Ellipsoid.clone(s,a._ellipsoid),a._surfaceHeight=c,a._rotation=d,a._extrudedHeight=p,a._offsetAttribute=-1===f?void 0:f,a):(R.granularity=u,R.height=c,R.rotation=d,R.extrudedHeight=p,R.offsetAttribute=-1===f?void 0:f,new w(R))};const P=new t.Cartographic;return w.createGeometry=function(t){const i=t._rectangle,r=t._ellipsoid,l=p.RectangleGeometryLibrary.computeOptions(i,t._granularity,t._rotation,0,E,P);let f,g;if(c.CesiumMath.equalsEpsilon(i.north,i.south,c.CesiumMath.EPSILON10)||c.CesiumMath.equalsEpsilon(i.east,i.west,c.CesiumMath.EPSILON10))return;const h=t._surfaceHeight,y=t._extrudedHeight;let _;if(c.CesiumMath.equalsEpsilon(h,y,0,c.CesiumMath.EPSILON2)){if(f=A(t,l),f.attributes.position.values=d.PolygonPipeline.scaleToGeodeticHeight(f.attributes.position.values,h,r,!1),e.defined(t._offsetAttribute)){const e=f.attributes.position.values.length;_=t._offsetAttribute===s.GeometryOffsetAttribute.NONE?0:1;const i=new Uint8Array(e/3).fill(_);f.attributes.applyOffset=new a.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}g=n.BoundingSphere.fromRectangle3D(i,r,h)}else{if(f=function(e,t){const i=e._surfaceHeight,n=e._extrudedHeight,o=e._ellipsoid,r=n,a=i,l=A(e,t),s=t.height,c=t.width,p=d.PolygonPipeline.scaleToGeodeticHeight(l.attributes.position.values,a,o,!1);let f=p.length;const g=new Float64Array(2*f);g.set(p);const h=d.PolygonPipeline.scaleToGeodeticHeight(l.attributes.position.values,r,o);g.set(h,f),l.attributes.position.values=g;const y=t.northCap,m=t.southCap;let b=4;y&&(b-=1),m&&(b-=1);const _=2*(g.length/3+b),E=u.IndexDatatype.createTypedArray(g.length/3,_);f=g.length/6;let w,G=0;for(let e=0;e<f-1;e++)E[G++]=e,E[G++]=e+1,E[G++]=e+f,E[G++]=e+f+1;if(E[G++]=f-1,E[G++]=0,E[G++]=f+f-1,E[G++]=f,E[G++]=0,E[G++]=f,y)w=s-1;else{const e=c-1;E[G++]=e,E[G++]=e+f,w=c+s-2}if(E[G++]=w,E[G++]=w+f,!m){const e=c+w-1;E[G++]=e,E[G]=e+f}return l.indices=E,l}(t,l),e.defined(t._offsetAttribute)){const e=f.attributes.position.values.length/3;let i=new Uint8Array(e);t._offsetAttribute===s.GeometryOffsetAttribute.TOP?i=i.fill(1,0,e/2):(_=t._offsetAttribute===s.GeometryOffsetAttribute.NONE?0:1,i=i.fill(_)),f.attributes.applyOffset=new a.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}const c=n.BoundingSphere.fromRectangle3D(i,r,h,b),p=n.BoundingSphere.fromRectangle3D(i,r,y,m);g=n.BoundingSphere.union(c,p)}return new a.Geometry({attributes:f.attributes,indices:f.indices,primitiveType:a.PrimitiveType.LINES,boundingSphere:g,offsetAttribute:t._offsetAttribute})},function(n,o){return e.defined(o)&&(n=w.unpack(n,o)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),n._rectangle=i.Rectangle.clone(n._rectangle),w.createGeometry(n)}}));