/*! For license information please see createRectangleOutlineGeometry.js.LICENSE.txt */
import{RectangleGeometryLibrary_default}from"./chunk-PXLFBN2Q.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{PolygonPipeline_default}from"./chunk-ZVUAJKAL.js";import"./chunk-6PWSSCRA.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Rectangle_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var bottomBoundingSphere=new BoundingSphere_default,topBoundingSphere=new BoundingSphere_default,positionScratch=new Cartesian3_default,rectangleScratch=new Rectangle_default;function constructRectangle(e,t){const a=e._ellipsoid,l=t.height,r=t.width,i=t.northCap,o=t.southCap;let n=l,u=2,d=0,f=4;i&&(u-=1,n-=1,d+=1,f-=2),o&&(u-=1,n-=1,d+=1,f-=2),d+=u*r+2*n-f;const c=new Float64Array(3*d);let s,_=0,p=0;const h=positionScratch;if(i)RectangleGeometryLibrary_default.computePosition(t,a,!1,p,0,h),c[_++]=h.x,c[_++]=h.y,c[_++]=h.z;else for(s=0;s<r;s++)RectangleGeometryLibrary_default.computePosition(t,a,!1,p,s,h),c[_++]=h.x,c[_++]=h.y,c[_++]=h.z;for(s=r-1,p=1;p<l;p++)RectangleGeometryLibrary_default.computePosition(t,a,!1,p,s,h),c[_++]=h.x,c[_++]=h.y,c[_++]=h.z;if(p=l-1,!o)for(s=r-2;s>=0;s--)RectangleGeometryLibrary_default.computePosition(t,a,!1,p,s,h),c[_++]=h.x,c[_++]=h.y,c[_++]=h.z;for(s=0,p=l-2;p>0;p--)RectangleGeometryLibrary_default.computePosition(t,a,!1,p,s,h),c[_++]=h.x,c[_++]=h.y,c[_++]=h.z;const g=c.length/3*2,m=IndexDatatype_default.createTypedArray(c.length/3,g);let y=0;for(let e=0;e<c.length/3-1;e++)m[y++]=e,m[y++]=e+1;m[y++]=c.length/3-1,m[y++]=0;const R=new Geometry_default({attributes:new GeometryAttributes_default,primitiveType:PrimitiveType_default.LINES});return R.attributes.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:c}),R.indices=m,R}function constructExtrudedRectangle(e,t){const a=e._surfaceHeight,l=e._extrudedHeight,r=e._ellipsoid,i=l,o=a,n=constructRectangle(e,t),u=t.height,d=t.width,f=PolygonPipeline_default.scaleToGeodeticHeight(n.attributes.position.values,o,r,!1);let c=f.length;const s=new Float64Array(2*c);s.set(f);const _=PolygonPipeline_default.scaleToGeodeticHeight(n.attributes.position.values,i,r);s.set(_,c),n.attributes.position.values=s;const p=t.northCap,h=t.southCap;let g=4;p&&(g-=1),h&&(g-=1);const m=2*(s.length/3+g),y=IndexDatatype_default.createTypedArray(s.length/3,m);c=s.length/6;let R,b=0;for(let e=0;e<c-1;e++)y[b++]=e,y[b++]=e+1,y[b++]=e+c,y[b++]=e+c+1;if(y[b++]=c-1,y[b++]=0,y[b++]=c+c-1,y[b++]=c,y[b++]=0,y[b++]=c,p)R=u-1;else{const e=d-1;y[b++]=e,y[b++]=e+c,R=d+u-2}if(y[b++]=R,y[b++]=R+c,!h){const e=d+R-1;y[b++]=e,y[b]=e+c}return n.indices=y,n}function RectangleOutlineGeometry(e){const t=(e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT)).rectangle,a=defaultValue_default(e.granularity,Math_default.RADIANS_PER_DEGREE),l=defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84),r=defaultValue_default(e.rotation,0);if(!defined_default(t))throw new DeveloperError_default("rectangle is required.");if(Rectangle_default.validate(t),t.north<t.south)throw new DeveloperError_default("options.rectangle.north must be greater than options.rectangle.south");const i=defaultValue_default(e.height,0),o=defaultValue_default(e.extrudedHeight,i);this._rectangle=Rectangle_default.clone(t),this._granularity=a,this._ellipsoid=l,this._surfaceHeight=Math.max(i,o),this._rotation=r,this._extrudedHeight=Math.min(i,o),this._offsetAttribute=e.offsetAttribute,this._workerName="createRectangleOutlineGeometry"}RectangleOutlineGeometry.packedLength=Rectangle_default.packedLength+Ellipsoid_default.packedLength+5,RectangleOutlineGeometry.pack=function(e,t,a){if(!defined_default(e))throw new DeveloperError_default("value is required");if(!defined_default(t))throw new DeveloperError_default("array is required");return a=defaultValue_default(a,0),Rectangle_default.pack(e._rectangle,t,a),a+=Rectangle_default.packedLength,Ellipsoid_default.pack(e._ellipsoid,t,a),a+=Ellipsoid_default.packedLength,t[a++]=e._granularity,t[a++]=e._surfaceHeight,t[a++]=e._rotation,t[a++]=e._extrudedHeight,t[a]=defaultValue_default(e._offsetAttribute,-1),t};var scratchRectangle=new Rectangle_default,scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchOptions={rectangle:scratchRectangle,ellipsoid:scratchEllipsoid,granularity:void 0,height:void 0,rotation:void 0,extrudedHeight:void 0,offsetAttribute:void 0};RectangleOutlineGeometry.unpack=function(e,t,a){if(!defined_default(e))throw new DeveloperError_default("array is required");t=defaultValue_default(t,0);const l=Rectangle_default.unpack(e,t,scratchRectangle);t+=Rectangle_default.packedLength;const r=Ellipsoid_default.unpack(e,t,scratchEllipsoid);t+=Ellipsoid_default.packedLength;const i=e[t++],o=e[t++],n=e[t++],u=e[t++],d=e[t];return defined_default(a)?(a._rectangle=Rectangle_default.clone(l,a._rectangle),a._ellipsoid=Ellipsoid_default.clone(r,a._ellipsoid),a._surfaceHeight=o,a._rotation=n,a._extrudedHeight=u,a._offsetAttribute=-1===d?void 0:d,a):(scratchOptions.granularity=i,scratchOptions.height=o,scratchOptions.rotation=n,scratchOptions.extrudedHeight=u,scratchOptions.offsetAttribute=-1===d?void 0:d,new RectangleOutlineGeometry(scratchOptions))};var nwScratch=new Cartographic_default;RectangleOutlineGeometry.createGeometry=function(e){const t=e._rectangle,a=e._ellipsoid,l=RectangleGeometryLibrary_default.computeOptions(t,e._granularity,e._rotation,0,rectangleScratch,nwScratch);let r,i;if(Math_default.equalsEpsilon(t.north,t.south,Math_default.EPSILON10)||Math_default.equalsEpsilon(t.east,t.west,Math_default.EPSILON10))return;const o=e._surfaceHeight,n=e._extrudedHeight;let u;if(Math_default.equalsEpsilon(o,n,0,Math_default.EPSILON2)){if(r=constructRectangle(e,l),r.attributes.position.values=PolygonPipeline_default.scaleToGeodeticHeight(r.attributes.position.values,o,a,!1),defined_default(e._offsetAttribute)){const t=r.attributes.position.values.length;u=e._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1;const a=new Uint8Array(t/3).fill(u);r.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}i=BoundingSphere_default.fromRectangle3D(t,a,o)}else{if(r=constructExtrudedRectangle(e,l),defined_default(e._offsetAttribute)){const t=r.attributes.position.values.length/3;let a=new Uint8Array(t);e._offsetAttribute===GeometryOffsetAttribute_default.TOP?a=a.fill(1,0,t/2):(u=e._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,a=a.fill(u)),r.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}const d=BoundingSphere_default.fromRectangle3D(t,a,o,topBoundingSphere),f=BoundingSphere_default.fromRectangle3D(t,a,n,bottomBoundingSphere);i=BoundingSphere_default.union(d,f)}return new Geometry_default({attributes:r.attributes,indices:r.indices,primitiveType:PrimitiveType_default.LINES,boundingSphere:i,offsetAttribute:e._offsetAttribute})};var RectangleOutlineGeometry_default=RectangleOutlineGeometry;function createRectangleOutlineGeometry(e,t){return defined_default(t)&&(e=RectangleOutlineGeometry_default.unpack(e,t)),e._ellipsoid=Ellipsoid_default.clone(e._ellipsoid),e._rectangle=Rectangle_default.clone(e._rectangle),RectangleOutlineGeometry_default.createGeometry(e)}var createRectangleOutlineGeometry_default=createRectangleOutlineGeometry;export{createRectangleOutlineGeometry_default as default};