define(["./Transforms-e2d4a55a","./Matrix2-e1298525","./Matrix3-41c58dde","./Check-6ede7e26","./ComponentDatatype-cf1fa08e","./CylinderGeometryLibrary-7bf291b4","./defaultValue-fe22d8c0","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./GeometryOffsetAttribute-9ad0019c","./IndexDatatype-2643aa47","./Math-0a2ac845","./combine-d9581036","./RuntimeError-ef395448","./WebGLConstants-0b1ce7ba"],(function(t,e,i,o,r,n,a,s,u,f,d,c,b,l,m){"use strict";const p=new e.Cartesian2;function y(t){const e=(t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT)).length,i=t.topRadius,r=t.bottomRadius,n=a.defaultValue(t.slices,128),s=Math.max(a.defaultValue(t.numberOfVerticalLines,16),0);if(o.Check.typeOf.number("options.positions",e),o.Check.typeOf.number("options.topRadius",i),o.Check.typeOf.number("options.bottomRadius",r),o.Check.typeOf.number.greaterThanOrEquals("options.slices",n,3),a.defined(t.offsetAttribute)&&t.offsetAttribute===f.GeometryOffsetAttribute.TOP)throw new o.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=e,this._topRadius=i,this._bottomRadius=r,this._slices=n,this._numberOfVerticalLines=s,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderOutlineGeometry"}y.packedLength=6,y.pack=function(t,e,i){return o.Check.typeOf.object("value",t),o.Check.defined("array",e),i=a.defaultValue(i,0),e[i++]=t._length,e[i++]=t._topRadius,e[i++]=t._bottomRadius,e[i++]=t._slices,e[i++]=t._numberOfVerticalLines,e[i]=a.defaultValue(t._offsetAttribute,-1),e};const h={length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};return y.unpack=function(t,e,i){o.Check.defined("array",t),e=a.defaultValue(e,0);const r=t[e++],n=t[e++],s=t[e++],u=t[e++],f=t[e++],d=t[e];return a.defined(i)?(i._length=r,i._topRadius=n,i._bottomRadius=s,i._slices=u,i._numberOfVerticalLines=f,i._offsetAttribute=-1===d?void 0:d,i):(h.length=r,h.topRadius=n,h.bottomRadius=s,h.slices=u,h.numberOfVerticalLines=f,h.offsetAttribute=-1===d?void 0:d,new y(h))},y.createGeometry=function(o){let c=o._length;const b=o._topRadius,l=o._bottomRadius,m=o._slices,y=o._numberOfVerticalLines;if(c<=0||b<0||l<0||0===b&&0===l)return;const h=2*m,_=n.CylinderGeometryLibrary.computePositions(c,b,l,m,!1);let A,O=2*m;if(y>0){const t=Math.min(y,m);A=Math.round(m/t),O+=t}const C=d.IndexDatatype.createTypedArray(h,2*O);let R,G=0;for(R=0;R<m-1;R++)C[G++]=R,C[G++]=R+1,C[G++]=R+m,C[G++]=R+1+m;if(C[G++]=m-1,C[G++]=0,C[G++]=m+m-1,C[G++]=m,y>0)for(R=0;R<m;R+=A)C[G++]=R,C[G++]=R+m;const V=new u.GeometryAttributes;V.position=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:_}),p.x=.5*c,p.y=Math.max(l,b);const g=new t.BoundingSphere(i.Cartesian3.ZERO,e.Cartesian2.magnitude(p));if(a.defined(o._offsetAttribute)){c=_.length;const t=o._offsetAttribute===f.GeometryOffsetAttribute.NONE?0:1,e=new Uint8Array(c/3).fill(t);V.applyOffset=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new s.Geometry({attributes:V,indices:C,primitiveType:s.PrimitiveType.LINES,boundingSphere:g,offsetAttribute:o._offsetAttribute})},function(t,e){return a.defined(e)&&(t=y.unpack(t,e)),y.createGeometry(t)}}));