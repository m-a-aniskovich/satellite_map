/*! For license information please see decodeI3S.js.LICENSE.txt */
import{require_draco_decoder_nodejs}from"./chunk-5NZTU5YL.js";import{createTaskProcessorWorker_default}from"./chunk-AI3KSNM6.js";import{WebMercatorProjection_default}from"./chunk-K6Q5IRBK.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-C53JYYKX.js";import"./chunk-7FEGZO3D.js";import{__toESM,defined_default}from"./chunk-YS4KPNLC.js";var draco,import_draco_decoder_nodejs=__toESM(require_draco_decoder_nodejs(),1);function bilinearInterpolate(e,t,r,n,o,a){return(r*(1-e)+n*e)*(1-t)+(o*(1-e)+a*e)*t}function sampleMap(e,t,r,n){return n[e+t*r]}function sampleGeoid(e,t,r){const n=r.nativeExtent;let o=(e-n.west)/(n.east-n.west)*(r.width-1),a=(t-n.south)/(n.north-n.south)*(r.height-1);const i=Math.floor(o);let s=Math.floor(a);o-=i,a-=s;const u=i<r.width?i+1:i;let c=s<r.height?s+1:s;s=r.height-1-s,c=r.height-1-c;let f=bilinearInterpolate(o,a,sampleMap(i,s,r.width,r.buffer),sampleMap(u,s,r.width,r.buffer),sampleMap(i,c,r.width,r.buffer),sampleMap(u,c,r.width,r.buffer));return f=f*r.scale+r.offset,f}function sampleGeoidFromList(e,t,r){for(let n=0;n<r.length;n++){const o=r[n].nativeExtent;let a=new Cartesian3_default;if("WebMercator"===r[n].projectionType){const o=r[n].projection._ellipsoid._radii;a=new WebMercatorProjection_default(new Ellipsoid_default(o.x,o.y,o.z)).project(new Cartographic_default(e,t,0))}else a.x=e,a.y=t;if(a.x>o.west&&a.x<o.east&&a.y>o.south&&a.y<o.north)return sampleGeoid(a.x,a.y,r[n])}return 0}function orthometricToEllipsoidal(e,t,r,n,o,a,i){if(i)return;const s=sampleGeoidFromList(o.longitude,o.latitude,a);for(let i=0;i<e;++i){const e=sampleGeoidFromList(o.longitude+Math_default.toRadians(r*t[3*i]),o.latitude+Math_default.toRadians(n*t[3*i+1]),a);t[3*i+2]+=e-s}}function transformToLocal(e,t,r,n,o,a,i,s,u){if(0===e||!defined_default(t)||0===t.length)return;const c=new Ellipsoid_default(Math.sqrt(i.x),Math.sqrt(i.y),Math.sqrt(i.z));for(let i=0;i<e;++i){const e=3*i,f=e+1,d=e+2,l=new Cartographic_default;l.longitude=n.longitude+Math_default.toRadians(s*t[e]),l.latitude=n.latitude+Math_default.toRadians(u*t[f]),l.height=n.height+t[d];const y={};c.cartographicToCartesian(l,y),y.x-=o.x,y.y-=o.y,y.z-=o.z;const p={};if(Matrix3_default.multiplyByVector(a,y,p),t[e]=p.x,t[f]=p.y,t[d]=p.z,defined_default(r)){const t=new Cartesian3_default(r[e],r[f],r[d]),n={};Matrix3_default.multiplyByVector(a,t,n),r[e]=n.x,r[f]=n.y,r[d]=n.z}}}function cropUVs(e,t,r){for(let n=0;n<e;++n){const e=r[4*n]/65535,o=r[4*n+1]/65535,a=(r[4*n+2]-r[4*n])/65535,i=(r[4*n+3]-r[4*n+1])/65535;t[2*n]*=a,t[2*n]+=e,t[2*n+1]*=i,t[2*n+1]+=o}}function generateGltfBuffer(e,t,r,n,o,a){if(0===e||!defined_default(r)||0===r.length)return{buffers:[],bufferViews:[],accessors:[],meshes:[],nodes:[],nodesInScene:[]};const i=[],s=[],u=[],c=[],f=[],d=[];defined_default(t)&&(e=t.length);const l=new Uint32Array(e);if(defined_default(t))for(let r=0;r<e;++r)l[r]=t[r];else for(let t=0;t<e;++t)l[t]=t;const y=new Blob([l],{type:"application/binary"}),p=URL.createObjectURL(y),b=e,h=r.subarray(0,3*b),_=new Blob([h],{type:"application/binary"}),m=URL.createObjectURL(_);let g=Number.POSITIVE_INFINITY,A=Number.NEGATIVE_INFINITY,w=Number.POSITIVE_INFINITY,I=Number.NEGATIVE_INFINITY,C=Number.POSITIVE_INFINITY,x=Number.NEGATIVE_INFINITY;for(let e=0;e<h.length/3;e++)g=Math.min(g,h[3*e+0]),A=Math.max(A,h[3*e+0]),w=Math.min(w,h[3*e+1]),I=Math.max(I,h[3*e+1]),C=Math.min(C,h[3*e+2]),x=Math.max(x,h[3*e+2]);const L=n?n.subarray(0,3*b):void 0;let G;if(defined_default(L)){const e=new Blob([L],{type:"application/binary"});G=URL.createObjectURL(e)}const D=o?o.subarray(0,2*b):void 0;let R;if(defined_default(D)){const e=new Blob([D],{type:"application/binary"});R=URL.createObjectURL(e)}const M=defined_default(a)?a.subarray(0,4*b):void 0;let O;if(defined_default(M)){const e=new Blob([M],{type:"application/binary"});O=URL.createObjectURL(e)}let V=0,v=0,E=0,U=0,T=0;const N={POSITION:0};return i.push({uri:m,byteLength:h.byteLength}),s.push({buffer:0,byteOffset:0,byteLength:h.byteLength,target:34962}),u.push({bufferView:0,byteOffset:0,componentType:5126,count:e,type:"VEC3",max:[g,w,C],min:[A,I,x]}),defined_default(G)&&(++T,V=T,N.NORMAL=V,i.push({uri:G,byteLength:L.byteLength}),s.push({buffer:V,byteOffset:0,byteLength:L.byteLength,target:34962}),u.push({bufferView:V,byteOffset:0,componentType:5126,count:e,type:"VEC3"})),defined_default(R)&&(++T,v=T,N.TEXCOORD_0=v,i.push({uri:R,byteLength:D.byteLength}),s.push({buffer:v,byteOffset:0,byteLength:D.byteLength,target:34962}),u.push({bufferView:v,byteOffset:0,componentType:5126,count:e,type:"VEC2"})),defined_default(O)&&(++T,E=T,N.COLOR_0=E,i.push({uri:O,byteLength:M.byteLength}),s.push({buffer:E,byteOffset:0,byteLength:M.byteLength,target:34962}),u.push({bufferView:E,byteOffset:0,componentType:5121,normalized:!0,count:e,type:"VEC4"})),++T,U=T,i.push({uri:p,byteLength:l.byteLength}),s.push({buffer:U,byteOffset:0,byteLength:l.byteLength,target:34963}),u.push({bufferView:U,byteOffset:0,componentType:5125,count:e,type:"SCALAR"}),c.push({primitives:[{attributes:N,indices:U,material:0}]}),d.push(0),f.push({mesh:0}),{buffers:i,bufferViews:s,accessors:u,meshes:c,nodes:f,nodesInScene:d}}function decode(e,t,r,n){const o=new Uint8Array(e,0,5);return o[0]==="D".charCodeAt()&&o[1]==="R".charCodeAt()&&o[2]==="A".charCodeAt()&&o[3]==="C".charCodeAt()&&o[4]==="O".charCodeAt()?decodeDracoEncodedGeometry(e,r):decodeBinaryGeometry(e,t,r,n)}function decodeDracoEncodedGeometry(e){const t=draco,r=new t.DecoderBuffer,n=new Uint8Array(e);r.Init(n,n.length);const o=new t.Decoder,a=o.GetEncodedGeometryType(r),i=new t.MetadataQuerier;let s,u;a===t.TRIANGULAR_MESH&&(s=new t.Mesh,u=o.DecodeBufferToMesh(r,s));const c={vertexCount:[0],featureCount:0};if(defined_default(u)&&u.ok()&&0!==s.ptr){const e=s.num_faces(),r=s.num_attributes(),n=s.num_points();c.indices=new Uint32Array(3*e);const a=c.indices;c.vertexCount[0]=n,c.scale_x=1,c.scale_y=1;const u=new t.DracoInt32Array(3);for(let t=0;t<e;++t)o.GetFaceFromMesh(s,t,u),a[3*t]=u.GetValue(0),a[3*t+1]=u.GetValue(1),a[3*t+2]=u.GetValue(2);t.destroy(u);for(let e=0;e<r;++e){const r=o.GetAttribute(s,e),a=decodeDracoAttribute(t,o,s,r,n),u=r.attribute_type();let f="unknown";u===t.POSITION?f="positions":u===t.NORMAL?f="normals":u===t.COLOR?f="colors":u===t.TEX_COORD&&(f="uv0s");const d=o.GetAttributeMetadata(s,e);if(0!==d.ptr){const e=i.NumEntries(d);for(let t=0;t<e;++t){const e=i.GetEntryName(d,t);"i3s-scale_x"===e?c.scale_x=i.GetDoubleEntry(d,"i3s-scale_x"):"i3s-scale_y"===e?c.scale_y=i.GetDoubleEntry(d,"i3s-scale_y"):"i3s-attribute-type"===e&&(f=i.GetStringEntry(d,"i3s-attribute-type"))}}defined_default(c[f])&&console.log("Attribute already exists",f),c[f]=a,"feature-index"===f&&c.featureCount++}t.destroy(s)}return t.destroy(i),t.destroy(o),c}function decodeDracoAttribute(e,t,r,n,o){const a=n.num_components()*o;let i;const s=[function(){},function(){i=new e.DracoInt8Array(a),t.GetAttributeInt8ForAllPoints(r,n,i)||console.error("Bad stream");const o=new Int8Array(a);for(let e=0;e<a;++e)o[e]=i.GetValue(e);return o},function(){i=new e.DracoInt8Array(a),t.GetAttributeUInt8ForAllPoints(r,n,i)||console.error("Bad stream");const o=new Uint8Array(a);for(let e=0;e<a;++e)o[e]=i.GetValue(e);return o},function(){i=new e.DracoInt16Array(a),t.GetAttributeInt16ForAllPoints(r,n,i)||console.error("Bad stream");const o=new Int16Array(a);for(let e=0;e<a;++e)o[e]=i.GetValue(e);return o},function(){i=new e.DracoInt16Array(a),t.GetAttributeUInt16ForAllPoints(r,n,i)||console.error("Bad stream");const o=new Uint16Array(a);for(let e=0;e<a;++e)o[e]=i.GetValue(e);return o},function(){i=new e.DracoInt32Array(a),t.GetAttributeInt32ForAllPoints(r,n,i)||console.error("Bad stream");const o=new Int32Array(a);for(let e=0;e<a;++e)o[e]=i.GetValue(e);return o},function(){i=new e.DracoInt32Array(a),t.GetAttributeUInt32ForAllPoints(r,n,i)||console.error("Bad stream");const o=new Uint32Array(a);for(let e=0;e<a;++e)o[e]=i.GetValue(e);return o},function(){},function(){},function(){i=new e.DracoFloat32Array(a),t.GetAttributeFloatForAllPoints(r,n,i)||console.error("Bad stream");const o=new Float32Array(a);for(let e=0;e<a;++e)o[e]=i.GetValue(e);return o},function(){},function(){i=new e.DracoUInt8Array(a),t.GetAttributeUInt8ForAllPoints(r,n,i)||console.error("Bad stream");const o=new Uint8Array(a);for(let e=0;e<a;++e)o[e]=i.GetValue(e);return o}][n.data_type()]();return defined_default(i)&&e.destroy(i),s}var binaryAttributeDecoders={position:function(e,t,r){const n=3*e.vertexCount;return e.positions=new Float32Array(t,r,n),r+4*n},normal:function(e,t,r){const n=3*e.vertexCount;return e.normals=new Float32Array(t,r,n),r+4*n},uv0:function(e,t,r){const n=2*e.vertexCount;return e.uv0s=new Float32Array(t,r,n),r+4*n},color:function(e,t,r){const n=4*e.vertexCount;return e.colors=new Uint8Array(t,r,n),r+n},featureId:function(e,t,r){return r+8*e.featureCount},id:function(e,t,r){return r+8*e.featureCount},faceRange:function(e,t,r){const n=2*e.featureCount;return e.faceRange=new Uint32Array(t,r,n),r+4*n},uvRegion:function(e,t,r){const n=4*e.vertexCount;return e["uv-region"]=new Uint16Array(t,r,n),r+2*n},region:function(e,t,r){const n=4*e.vertexCount;return e["uv-region"]=new Uint16Array(t,r,n),r+2*n}};function decodeBinaryGeometry(e,t,r,n){const o={vertexCount:0},a=new DataView(e);try{let i=0;if(o.vertexCount=a.getUint32(i,1),i+=4,o.featureCount=a.getUint32(i,1),i+=4,defined_default(r))for(let t=0;t<r.attributes.length;t++)defined_default(binaryAttributeDecoders[r.attributes[t]])?i=binaryAttributeDecoders[r.attributes[t]](o,e,i):console.error("Unknown decoder for",r.attributes[t]);else{let r=t.ordering,a=t.featureAttributeOrder;defined_default(n)&&defined_default(n.geometryData)&&defined_default(n.geometryData[0])&&defined_default(n.geometryData[0].params)&&(r=Object.keys(n.geometryData[0].params.vertexAttributes),a=Object.keys(n.geometryData[0].params.featureAttributes));for(let t=0;t<r.length;t++)i=(0,binaryAttributeDecoders[r[t]])(o,e,i);for(let t=0;t<a.length;t++)i=(0,binaryAttributeDecoders[a[t]])(o,e,i)}}catch(e){console.error(e)}return o.scale_x=1,o.scale_y=1,o}function decodeAndCreateGltf(e){const t=decode(e.binaryData,e.schema,e.bufferInfo,e.featureData);defined_default(e.geoidDataList)&&e.geoidDataList.length>0&&orthometricToEllipsoidal(t.vertexCount,t.positions,t.scale_x,t.scale_y,e.cartographicCenter,e.geoidDataList,!1),transformToLocal(t.vertexCount,t.positions,t.normals,e.cartographicCenter,e.cartesianCenter,e.parentRotation,e.ellipsoidRadiiSquare,t.scale_x,t.scale_y),defined_default(t.uv0s)&&defined_default(t["uv-region"])&&cropUVs(t.vertexCount,t.uv0s,t["uv-region"]);const r=generateGltfBuffer(t.vertexCount,t.indices,t.positions,t.normals,t.uv0s,t.colors),n={};if(defined_default(t["feature-index"]))n.positions=t.positions,n.indices=t.indices,n.featureIndex=t["feature-index"],n.cartesianCenter=e.cartesianCenter,n.parentRotation=e.parentRotation;else if(defined_default(t.faceRange)){n.positions=t.positions,n.indices=t.indices,n.sourceURL=e.url,n.cartesianCenter=e.cartesianCenter,n.parentRotation=e.parentRotation,n.featureIndex=new Array(t.positions.length);for(let e=0;e<t.faceRange.length-1;e+=2){const r=e/2,o=t.faceRange[e],a=t.faceRange[e+1];for(let e=o;e<=a;e++)n.featureIndex[3*e]=r,n.featureIndex[3*e+1]=r,n.featureIndex[3*e+2]=r}}return r._customAttributes=n,{meshData:r}}async function initWorker(e,t){const r=e.webAssemblyConfig;return draco=defined_default(r)&&defined_default(r.wasmBinaryFile)?await(0,import_draco_decoder_nodejs.default)(r):await(0,import_draco_decoder_nodejs.default)(),!0}function decodeI3S(e,t){const r=e.webAssemblyConfig;return defined_default(r)?initWorker(e,t):decodeAndCreateGltf(e,t)}var decodeI3S_default=createTaskProcessorWorker_default(decodeI3S);export{decodeI3S_default as default};