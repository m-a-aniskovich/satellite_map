define(["./defaultValue-fe22d8c0","./Matrix3-41c58dde","./ArcType-2d9abbbc","./arrayRemoveDuplicates-d2061e85","./Transforms-e2d4a55a","./Color-8e135f71","./ComponentDatatype-cf1fa08e","./Check-6ede7e26","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./IndexDatatype-2643aa47","./Math-0a2ac845","./PolylinePipeline-7119eb3f","./VertexFormat-030f11ff","./Matrix2-e1298525","./RuntimeError-ef395448","./combine-d9581036","./WebGLConstants-0b1ce7ba","./EllipsoidGeodesic-5b3623dc","./EllipsoidRhumbLine-ef872433","./IntersectionTests-85350792","./Plane-4c3d403b"],(function(e,t,o,r,n,a,i,l,s,c,p,d,u,y,f,h,m,C,g,w,E,_){"use strict";const A=[];function b(e,t,o,r,n){const i=A;let l;i.length=n;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=r.red,y=r.green,f=r.blue,h=r.alpha;if(a.Color.equals(o,r)){for(l=0;l<n;l++)i[l]=a.Color.clone(o);return i}const m=(u-s)/n,C=(y-c)/n,g=(f-p)/n,w=(h-d)/n;for(l=0;l<n;l++)i[l]=new a.Color(s+l*m,c+l*C,p+l*g,d+l*w);return i}function P(r){const n=(r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT)).positions,i=r.colors,s=e.defaultValue(r.width,1),c=e.defaultValue(r.colorsPerVertex,!1);if(!e.defined(n)||n.length<2)throw new l.DeveloperError("At least two positions are required.");if("number"!=typeof s)throw new l.DeveloperError("width must be a number");if(e.defined(i)&&(c&&i.length<n.length||!c&&i.length<n.length-1))throw new l.DeveloperError("colors has an invalid length.");this._positions=n,this._colors=i,this._width=s,this._colorsPerVertex=c,this._vertexFormat=y.VertexFormat.clone(e.defaultValue(r.vertexFormat,y.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,d.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let p=1+n.length*t.Cartesian3.packedLength;p+=e.defined(i)?1+i.length*a.Color.packedLength:1,this.packedLength=p+t.Ellipsoid.packedLength+y.VertexFormat.packedLength+4}P.pack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("value is required");if(!e.defined(r))throw new l.DeveloperError("array is required");let i;n=e.defaultValue(n,0);const s=o._positions;let c=s.length;for(r[n++]=c,i=0;i<c;++i,n+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[i],r,n);const p=o._colors;for(c=e.defined(p)?p.length:0,r[n++]=c,i=0;i<c;++i,n+=a.Color.packedLength)a.Color.pack(p[i],r,n);return t.Ellipsoid.pack(o._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,y.VertexFormat.pack(o._vertexFormat,r,n),n+=y.VertexFormat.packedLength,r[n++]=o._width,r[n++]=o._colorsPerVertex?1:0,r[n++]=o._arcType,r[n]=o._granularity,r};const v=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),D=new y.VertexFormat,x={positions:void 0,colors:void 0,ellipsoid:v,vertexFormat:D,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};P.unpack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("array is required");let i;r=e.defaultValue(r,0);let s=o[r++];const c=new Array(s);for(i=0;i<s;++i,r+=t.Cartesian3.packedLength)c[i]=t.Cartesian3.unpack(o,r);s=o[r++];const p=s>0?new Array(s):void 0;for(i=0;i<s;++i,r+=a.Color.packedLength)p[i]=a.Color.unpack(o,r);const d=t.Ellipsoid.unpack(o,r,v);r+=t.Ellipsoid.packedLength;const u=y.VertexFormat.unpack(o,r,D);r+=y.VertexFormat.packedLength;const f=o[r++],h=1===o[r++],m=o[r++],C=o[r];return e.defined(n)?(n._positions=c,n._colors=p,n._ellipsoid=t.Ellipsoid.clone(d,n._ellipsoid),n._vertexFormat=y.VertexFormat.clone(u,n._vertexFormat),n._width=f,n._colorsPerVertex=h,n._arcType=m,n._granularity=C,n):(x.positions=c,x.colors=p,x.width=f,x.colorsPerVertex=h,x.arcType=m,x.granularity=C,new P(x))};const T=new t.Cartesian3,k=new t.Cartesian3,V=new t.Cartesian3,L=new t.Cartesian3;return P.createGeometry=function(l){const y=l._width,f=l._vertexFormat;let h=l._colors;const m=l._colorsPerVertex,C=l._arcType,g=l._granularity,w=l._ellipsoid;let E,_,P;const v=[];let D=r.arrayRemoveDuplicates(l._positions,t.Cartesian3.equalsEpsilon,!1,v);if(e.defined(h)&&v.length>0){let e=0,t=v[0];h=h.filter((function(o,r){let n=!1;return n=m?r===t||0===r&&1===t:r+1===t,!n||(e++,t=v[e],!1)}))}let x=D.length;if(x<2||y<=0)return;if(C===o.ArcType.GEODESIC||C===o.ArcType.RHUMB){let t,r;C===o.ArcType.GEODESIC?(t=d.CesiumMath.chordLength(g,w.maximumRadius),r=u.PolylinePipeline.numberOfPoints):(t=g,r=u.PolylinePipeline.numberOfPointsRhumbLine);const n=u.PolylinePipeline.extractHeights(D,w);if(e.defined(h)){let e=1;for(E=0;E<x-1;++E)e+=r(D[E],D[E+1],t);const o=new Array(e);let n=0;for(E=0;E<x-1;++E){const i=D[E],l=D[E+1],s=h[E],c=r(i,l,t);if(m&&E<e){const e=b(0,0,s,h[E+1],c),t=e.length;for(_=0;_<t;++_)o[n++]=e[_]}else for(_=0;_<c;++_)o[n++]=a.Color.clone(s)}o[n]=a.Color.clone(h[h.length-1]),h=o,A.length=0}D=C===o.ArcType.GEODESIC?u.PolylinePipeline.generateCartesianArc({positions:D,minDistance:t,ellipsoid:w,height:n}):u.PolylinePipeline.generateCartesianRhumbArc({positions:D,granularity:t,ellipsoid:w,height:n})}x=D.length;const F=4*x-4,G=new Float64Array(3*F),O=new Float64Array(3*F),R=new Float64Array(3*F),I=new Float32Array(2*F),S=f.st?new Float32Array(2*F):void 0,B=e.defined(h)?new Uint8Array(4*F):void 0;let M,U=0,N=0,q=0,H=0;for(_=0;_<x;++_){let o,r;0===_?(M=T,t.Cartesian3.subtract(D[0],D[1],M),t.Cartesian3.add(D[0],M,M)):M=D[_-1],t.Cartesian3.clone(M,V),t.Cartesian3.clone(D[_],k),_===x-1?(M=T,t.Cartesian3.subtract(D[x-1],D[x-2],M),t.Cartesian3.add(D[x-1],M,M)):M=D[_+1],t.Cartesian3.clone(M,L),e.defined(B)&&(o=0===_||m?h[_]:h[_-1],_!==x-1&&(r=h[_]));const n=_===x-1?2:4;for(P=0===_?2:0;P<n;++P){t.Cartesian3.pack(k,G,U),t.Cartesian3.pack(V,O,U),t.Cartesian3.pack(L,R,U),U+=3;const n=P-2<0?-1:1;if(I[N++]=P%2*2-1,I[N++]=n*y,f.st&&(S[q++]=_/(x-1),S[q++]=Math.max(I[N-2],0)),e.defined(B)){const e=P<2?o:r;B[H++]=a.Color.floatToByte(e.red),B[H++]=a.Color.floatToByte(e.green),B[H++]=a.Color.floatToByte(e.blue),B[H++]=a.Color.floatToByte(e.alpha)}}}const W=new c.GeometryAttributes;W.position=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),W.prevPosition=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),W.nextPosition=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:R}),W.expandAndWidth=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I}),f.st&&(W.st=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:S})),e.defined(B)&&(W.color=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:B,normalize:!0}));const Y=p.IndexDatatype.createTypedArray(F,6*x-6);let z=0,J=0;const j=x-1;for(_=0;_<j;++_)Y[J++]=z,Y[J++]=z+2,Y[J++]=z+1,Y[J++]=z+1,Y[J++]=z+2,Y[J++]=z+3,z+=4;return new s.Geometry({attributes:W,indices:Y,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:n.BoundingSphere.fromPoints(D),geometryType:s.GeometryType.POLYLINES})},function(o,r){return e.defined(r)&&(o=P.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),P.createGeometry(o)}}));