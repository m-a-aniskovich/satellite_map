/*! For license information please see createPolylineGeometry.js.LICENSE.txt */
import{Color_default}from"./chunk-QUXSQQEF.js";import{ArcType_default}from"./chunk-235MRXLH.js";import{PolylinePipeline_default}from"./chunk-3FCUUN6M.js";import"./chunk-LSGUCCKJ.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import{arrayRemoveDuplicates_default}from"./chunk-DTNN3ODA.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,GeometryType_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var scratchInterpolateColorsArray=[];function interpolateColors(e,t,a,r,o){const l=scratchInterpolateColorsArray;let n;l.length=o;const i=a.red,d=a.green,u=a.blue,s=a.alpha,f=r.red,c=r.green,_=r.blue,p=r.alpha;if(Color_default.equals(a,r)){for(n=0;n<o;n++)l[n]=Color_default.clone(a);return l}const h=(f-i)/o,m=(c-d)/o,y=(_-u)/o,P=(p-s)/o;for(n=0;n<o;n++)l[n]=new Color_default(i+n*h,d+n*m,u+n*y,s+n*P);return l}function PolylineGeometry(e){const t=(e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT)).positions,a=e.colors,r=defaultValue_default(e.width,1),o=defaultValue_default(e.colorsPerVertex,!1);if(!defined_default(t)||t.length<2)throw new DeveloperError_default("At least two positions are required.");if("number"!=typeof r)throw new DeveloperError_default("width must be a number");if(defined_default(a)&&(o&&a.length<t.length||!o&&a.length<t.length-1))throw new DeveloperError_default("colors has an invalid length.");this._positions=t,this._colors=a,this._width=r,this._colorsPerVertex=o,this._vertexFormat=VertexFormat_default.clone(defaultValue_default(e.vertexFormat,VertexFormat_default.DEFAULT)),this._arcType=defaultValue_default(e.arcType,ArcType_default.GEODESIC),this._granularity=defaultValue_default(e.granularity,Math_default.RADIANS_PER_DEGREE),this._ellipsoid=Ellipsoid_default.clone(defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84)),this._workerName="createPolylineGeometry";let l=1+t.length*Cartesian3_default.packedLength;l+=defined_default(a)?1+a.length*Color_default.packedLength:1,this.packedLength=l+Ellipsoid_default.packedLength+VertexFormat_default.packedLength+4}PolylineGeometry.pack=function(e,t,a){if(!defined_default(e))throw new DeveloperError_default("value is required");if(!defined_default(t))throw new DeveloperError_default("array is required");let r;a=defaultValue_default(a,0);const o=e._positions;let l=o.length;for(t[a++]=l,r=0;r<l;++r,a+=Cartesian3_default.packedLength)Cartesian3_default.pack(o[r],t,a);const n=e._colors;for(l=defined_default(n)?n.length:0,t[a++]=l,r=0;r<l;++r,a+=Color_default.packedLength)Color_default.pack(n[r],t,a);return Ellipsoid_default.pack(e._ellipsoid,t,a),a+=Ellipsoid_default.packedLength,VertexFormat_default.pack(e._vertexFormat,t,a),a+=VertexFormat_default.packedLength,t[a++]=e._width,t[a++]=e._colorsPerVertex?1:0,t[a++]=e._arcType,t[a]=e._granularity,t};var scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchVertexFormat=new VertexFormat_default,scratchOptions={positions:void 0,colors:void 0,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};PolylineGeometry.unpack=function(e,t,a){if(!defined_default(e))throw new DeveloperError_default("array is required");let r;t=defaultValue_default(t,0);let o=e[t++];const l=new Array(o);for(r=0;r<o;++r,t+=Cartesian3_default.packedLength)l[r]=Cartesian3_default.unpack(e,t);o=e[t++];const n=o>0?new Array(o):void 0;for(r=0;r<o;++r,t+=Color_default.packedLength)n[r]=Color_default.unpack(e,t);const i=Ellipsoid_default.unpack(e,t,scratchEllipsoid);t+=Ellipsoid_default.packedLength;const d=VertexFormat_default.unpack(e,t,scratchVertexFormat);t+=VertexFormat_default.packedLength;const u=e[t++],s=1===e[t++],f=e[t++],c=e[t];return defined_default(a)?(a._positions=l,a._colors=n,a._ellipsoid=Ellipsoid_default.clone(i,a._ellipsoid),a._vertexFormat=VertexFormat_default.clone(d,a._vertexFormat),a._width=u,a._colorsPerVertex=s,a._arcType=f,a._granularity=c,a):(scratchOptions.positions=l,scratchOptions.colors=n,scratchOptions.width=u,scratchOptions.colorsPerVertex=s,scratchOptions.arcType=f,scratchOptions.granularity=c,new PolylineGeometry(scratchOptions))};var scratchCartesian3=new Cartesian3_default,scratchPosition=new Cartesian3_default,scratchPrevPosition=new Cartesian3_default,scratchNextPosition=new Cartesian3_default;PolylineGeometry.createGeometry=function(e){const t=e._width,a=e._vertexFormat;let r=e._colors;const o=e._colorsPerVertex,l=e._arcType,n=e._granularity,i=e._ellipsoid;let d,u,s;const f=[];let c=arrayRemoveDuplicates_default(e._positions,Cartesian3_default.equalsEpsilon,!1,f);if(defined_default(r)&&f.length>0){let e=0,t=f[0];r=r.filter((function(a,r){let l=!1;return l=o?r===t||0===r&&1===t:r+1===t,!l||(e++,t=f[e],!1)}))}let _=c.length;if(_<2||t<=0)return;if(l===ArcType_default.GEODESIC||l===ArcType_default.RHUMB){let e,t;l===ArcType_default.GEODESIC?(e=Math_default.chordLength(n,i.maximumRadius),t=PolylinePipeline_default.numberOfPoints):(e=n,t=PolylinePipeline_default.numberOfPointsRhumbLine);const a=PolylinePipeline_default.extractHeights(c,i);if(defined_default(r)){let a=1;for(d=0;d<_-1;++d)a+=t(c[d],c[d+1],e);const l=new Array(a);let n=0;for(d=0;d<_-1;++d){const i=c[d],s=c[d+1],f=r[d],_=t(i,s,e);if(o&&d<a){const e=interpolateColors(i,s,f,r[d+1],_),t=e.length;for(u=0;u<t;++u)l[n++]=e[u]}else for(u=0;u<_;++u)l[n++]=Color_default.clone(f)}l[n]=Color_default.clone(r[r.length-1]),r=l,scratchInterpolateColorsArray.length=0}c=l===ArcType_default.GEODESIC?PolylinePipeline_default.generateCartesianArc({positions:c,minDistance:e,ellipsoid:i,height:a}):PolylinePipeline_default.generateCartesianRhumbArc({positions:c,granularity:e,ellipsoid:i,height:a})}_=c.length;const p=4*_-4,h=new Float64Array(3*p),m=new Float64Array(3*p),y=new Float64Array(3*p),P=new Float32Array(2*p),C=a.st?new Float32Array(2*p):void 0,E=defined_default(r)?new Uint8Array(4*p):void 0;let g,k=0,A=0,w=0,v=0;for(u=0;u<_;++u){let e,l;0===u?(g=scratchCartesian3,Cartesian3_default.subtract(c[0],c[1],g),Cartesian3_default.add(c[0],g,g)):g=c[u-1],Cartesian3_default.clone(g,scratchPrevPosition),Cartesian3_default.clone(c[u],scratchPosition),u===_-1?(g=scratchCartesian3,Cartesian3_default.subtract(c[_-1],c[_-2],g),Cartesian3_default.add(c[_-1],g,g)):g=c[u+1],Cartesian3_default.clone(g,scratchNextPosition),defined_default(E)&&(e=0===u||o?r[u]:r[u-1],u!==_-1&&(l=r[u]));const n=u===_-1?2:4;for(s=0===u?2:0;s<n;++s){Cartesian3_default.pack(scratchPosition,h,k),Cartesian3_default.pack(scratchPrevPosition,m,k),Cartesian3_default.pack(scratchNextPosition,y,k),k+=3;const r=s-2<0?-1:1;if(P[A++]=s%2*2-1,P[A++]=r*t,a.st&&(C[w++]=u/(_-1),C[w++]=Math.max(P[A-2],0)),defined_default(E)){const t=s<2?e:l;E[v++]=Color_default.floatToByte(t.red),E[v++]=Color_default.floatToByte(t.green),E[v++]=Color_default.floatToByte(t.blue),E[v++]=Color_default.floatToByte(t.alpha)}}}const D=new GeometryAttributes_default;D.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:h}),D.prevPosition=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:m}),D.nextPosition=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:y}),D.expandAndWidth=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:P}),a.st&&(D.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:C})),defined_default(E)&&(D.color=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:4,values:E,normalize:!0}));const G=IndexDatatype_default.createTypedArray(p,6*_-6);let x=0,V=0;const T=_-1;for(u=0;u<T;++u)G[V++]=x,G[V++]=x+2,G[V++]=x+1,G[V++]=x+1,G[V++]=x+2,G[V++]=x+3,x+=4;return new Geometry_default({attributes:D,indices:G,primitiveType:PrimitiveType_default.TRIANGLES,boundingSphere:BoundingSphere_default.fromPoints(c),geometryType:GeometryType_default.POLYLINES})};var PolylineGeometry_default=PolylineGeometry;function createPolylineGeometry(e,t){return defined_default(t)&&(e=PolylineGeometry_default.unpack(e,t)),e._ellipsoid=Ellipsoid_default.clone(e._ellipsoid),PolylineGeometry_default.createGeometry(e)}var createPolylineGeometry_default=createPolylineGeometry;export{createPolylineGeometry_default as default};