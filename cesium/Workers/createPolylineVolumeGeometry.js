define(["./defaultValue-fe22d8c0","./Matrix3-41c58dde","./arrayRemoveDuplicates-d2061e85","./BoundingRectangle-5fd6403a","./Transforms-e2d4a55a","./Matrix2-e1298525","./ComponentDatatype-cf1fa08e","./PolylineVolumeGeometryLibrary-d25f0050","./Check-6ede7e26","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./GeometryPipeline-03bc5709","./IndexDatatype-2643aa47","./Math-0a2ac845","./PolygonPipeline-460cce4e","./VertexFormat-030f11ff","./combine-d9581036","./RuntimeError-ef395448","./WebGLConstants-0b1ce7ba","./EllipsoidTangentPlane-546c0d5e","./AxisAlignedBoundingBox-4bfd84f3","./IntersectionTests-85350792","./Plane-4c3d403b","./PolylinePipeline-7119eb3f","./EllipsoidGeodesic-5b3623dc","./EllipsoidRhumbLine-ef872433","./AttributeCompression-f9f6c717","./EncodedCartesian3-57415c8a"],(function(e,t,n,o,i,r,a,l,s,p,d,c,u,y,m,g,f,h,E,b,P,v,_,k,V,x,C,L){"use strict";function w(n){const o=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).polylinePositions,i=n.shapePositions;if(!e.defined(o))throw new s.DeveloperError("options.polylinePositions is required.");if(!e.defined(i))throw new s.DeveloperError("options.shapePositions is required.");this._positions=o,this._shape=i,this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,l.CornerType.ROUNDED),this._vertexFormat=g.VertexFormat.clone(e.defaultValue(n.vertexFormat,g.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(n.granularity,y.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let a=1+o.length*t.Cartesian3.packedLength;a+=1+i.length*r.Cartesian2.packedLength,this.packedLength=a+t.Ellipsoid.packedLength+g.VertexFormat.packedLength+2}w.pack=function(n,o,i){if(!e.defined(n))throw new s.DeveloperError("value is required");if(!e.defined(o))throw new s.DeveloperError("array is required");let a;i=e.defaultValue(i,0);const l=n._positions;let p=l.length;for(o[i++]=p,a=0;a<p;++a,i+=t.Cartesian3.packedLength)t.Cartesian3.pack(l[a],o,i);const d=n._shape;for(p=d.length,o[i++]=p,a=0;a<p;++a,i+=r.Cartesian2.packedLength)r.Cartesian2.pack(d[a],o,i);return t.Ellipsoid.pack(n._ellipsoid,o,i),i+=t.Ellipsoid.packedLength,g.VertexFormat.pack(n._vertexFormat,o,i),i+=g.VertexFormat.packedLength,o[i++]=n._cornerType,o[i]=n._granularity,o};const D=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),F=new g.VertexFormat,A={polylinePositions:void 0,shapePositions:void 0,ellipsoid:D,vertexFormat:F,cornerType:void 0,granularity:void 0};w.unpack=function(n,o,i){if(!e.defined(n))throw new s.DeveloperError("array is required");let a;o=e.defaultValue(o,0);let l=n[o++];const p=new Array(l);for(a=0;a<l;++a,o+=t.Cartesian3.packedLength)p[a]=t.Cartesian3.unpack(n,o);l=n[o++];const d=new Array(l);for(a=0;a<l;++a,o+=r.Cartesian2.packedLength)d[a]=r.Cartesian2.unpack(n,o);const c=t.Ellipsoid.unpack(n,o,D);o+=t.Ellipsoid.packedLength;const u=g.VertexFormat.unpack(n,o,F);o+=g.VertexFormat.packedLength;const y=n[o++],m=n[o];return e.defined(i)?(i._positions=p,i._shape=d,i._ellipsoid=t.Ellipsoid.clone(c,i._ellipsoid),i._vertexFormat=g.VertexFormat.clone(u,i._vertexFormat),i._cornerType=y,i._granularity=m,i):(A.polylinePositions=p,A.shapePositions=d,A.cornerType=y,A.granularity=m,new w(A))};const T=new o.BoundingRectangle;return w.createGeometry=function(e){const r=e._positions,s=n.arrayRemoveDuplicates(r,t.Cartesian3.equalsEpsilon);let y=e._shape;if(y=l.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(y),s.length<2||y.length<3)return;m.PolygonPipeline.computeWindingOrder2D(y)===m.WindingOrder.CLOCKWISE&&y.reverse();const g=o.BoundingRectangle.fromPoints(y,T);return function(e,t,n,o){const r=new d.GeometryAttributes;o.position&&(r.position=new p.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));const s=t.length,y=e.length/3,g=(y-2*s)/(2*s),f=m.PolygonPipeline.triangulate(t),h=(g-1)*s*6+2*f.length,E=u.IndexDatatype.createTypedArray(y,h);let b,P,v,_,k,V;const x=2*s;let C=0;for(b=0;b<g-1;b++){for(P=0;P<s-1;P++)v=2*P+b*s*2,V=v+x,_=v+1,k=_+x,E[C++]=_,E[C++]=v,E[C++]=k,E[C++]=k,E[C++]=v,E[C++]=V;v=2*s-2+b*s*2,_=v+1,k=_+x,V=v+x,E[C++]=_,E[C++]=v,E[C++]=k,E[C++]=k,E[C++]=v,E[C++]=V}if(o.st||o.tangent||o.bitangent){const e=new Float32Array(2*y),o=1/(g-1),i=1/n.height,l=n.height/2;let d,c,u=0;for(b=0;b<g;b++){for(d=b*o,c=i*(t[0].y+l),e[u++]=d,e[u++]=c,P=1;P<s;P++)c=i*(t[P].y+l),e[u++]=d,e[u++]=c,e[u++]=d,e[u++]=c;c=i*(t[0].y+l),e[u++]=d,e[u++]=c}for(P=0;P<s;P++)d=0,c=i*(t[P].y+l),e[u++]=d,e[u++]=c;for(P=0;P<s;P++)d=(g-1)*o,c=i*(t[P].y+l),e[u++]=d,e[u++]=c;r.st=new p.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const L=y-2*s;for(b=0;b<f.length;b+=3){const e=f[b]+L,t=f[b+1]+L,n=f[b+2]+L;E[C++]=e,E[C++]=t,E[C++]=n,E[C++]=n+s,E[C++]=t+s,E[C++]=e+s}let w=new p.Geometry({attributes:r,indices:E,boundingSphere:i.BoundingSphere.fromVertices(e),primitiveType:p.PrimitiveType.TRIANGLES});if(o.normal&&(w=c.GeometryPipeline.computeNormal(w)),o.tangent||o.bitangent){try{w=c.GeometryPipeline.computeTangentAndBitangent(w)}catch(e){l.oneTimeWarning("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}o.tangent||(w.attributes.tangent=void 0),o.bitangent||(w.attributes.bitangent=void 0),o.st||(w.attributes.st=void 0)}return w}(l.PolylineVolumeGeometryLibrary.computePositions(s,y,g,e,!0),y,g,e._vertexFormat)},function(n,o){return e.defined(o)&&(n=w.unpack(n,o)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),w.createGeometry(n)}}));