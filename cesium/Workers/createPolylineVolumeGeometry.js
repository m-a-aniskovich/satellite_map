/*! For license information please see createPolylineVolumeGeometry.js.LICENSE.txt */
import{BoundingRectangle_default}from"./chunk-KUB2HQXR.js";import{GeometryPipeline_default}from"./chunk-36ESDRIZ.js";import"./chunk-I6TVJ6T7.js";import"./chunk-VOAZN4IP.js";import{CornerType_default,PolylineVolumeGeometryLibrary_default}from"./chunk-D325WRAY.js";import{oneTimeWarning_default}from"./chunk-7ONRI7T4.js";import"./chunk-3FCUUN6M.js";import"./chunk-LSGUCCKJ.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import"./chunk-MOLGJDJV.js";import"./chunk-FGUP2QEP.js";import{PolygonPipeline_default,WindingOrder_default}from"./chunk-ZVUAJKAL.js";import{arrayRemoveDuplicates_default}from"./chunk-DTNN3ODA.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Cartesian2_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";function computeAttributes(e,t,o,r){const a=new GeometryAttributes_default;r.position&&(a.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:e}));const l=t.length,n=e.length/3,i=(n-2*l)/(2*l),u=PolygonPipeline_default.triangulate(t),d=(i-1)*l*6+2*u.length,s=IndexDatatype_default.createTypedArray(n,d);let f,p,c,m,_,h;const y=2*l;let g=0;for(f=0;f<i-1;f++){for(p=0;p<l-1;p++)c=2*p+f*l*2,h=c+y,m=c+1,_=m+y,s[g++]=m,s[g++]=c,s[g++]=_,s[g++]=_,s[g++]=c,s[g++]=h;c=2*l-2+f*l*2,m=c+1,_=m+y,h=c+y,s[g++]=m,s[g++]=c,s[g++]=_,s[g++]=_,s[g++]=c,s[g++]=h}if(r.st||r.tangent||r.bitangent){const e=new Float32Array(2*n),r=1/(i-1),u=1/o.height,d=o.height/2;let s,c,m=0;for(f=0;f<i;f++){for(s=f*r,c=u*(t[0].y+d),e[m++]=s,e[m++]=c,p=1;p<l;p++)c=u*(t[p].y+d),e[m++]=s,e[m++]=c,e[m++]=s,e[m++]=c;c=u*(t[0].y+d),e[m++]=s,e[m++]=c}for(p=0;p<l;p++)s=0,c=u*(t[p].y+d),e[m++]=s,e[m++]=c;for(p=0;p<l;p++)s=(i-1)*r,c=u*(t[p].y+d),e[m++]=s,e[m++]=c;a.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const k=n-2*l;for(f=0;f<u.length;f+=3){const e=u[f]+k,t=u[f+1]+k,o=u[f+2]+k;s[g++]=e,s[g++]=t,s[g++]=o,s[g++]=o+l,s[g++]=t+l,s[g++]=e+l}let P=new Geometry_default({attributes:a,indices:s,boundingSphere:BoundingSphere_default.fromVertices(e),primitiveType:PrimitiveType_default.TRIANGLES});if(r.normal&&(P=GeometryPipeline_default.computeNormal(P)),r.tangent||r.bitangent){try{P=GeometryPipeline_default.computeTangentAndBitangent(P)}catch(e){oneTimeWarning_default("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}r.tangent||(P.attributes.tangent=void 0),r.bitangent||(P.attributes.bitangent=void 0),r.st||(P.attributes.st=void 0)}return P}function PolylineVolumeGeometry(e){const t=(e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT)).polylinePositions,o=e.shapePositions;if(!defined_default(t))throw new DeveloperError_default("options.polylinePositions is required.");if(!defined_default(o))throw new DeveloperError_default("options.shapePositions is required.");this._positions=t,this._shape=o,this._ellipsoid=Ellipsoid_default.clone(defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84)),this._cornerType=defaultValue_default(e.cornerType,CornerType_default.ROUNDED),this._vertexFormat=VertexFormat_default.clone(defaultValue_default(e.vertexFormat,VertexFormat_default.DEFAULT)),this._granularity=defaultValue_default(e.granularity,Math_default.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let r=1+t.length*Cartesian3_default.packedLength;r+=1+o.length*Cartesian2_default.packedLength,this.packedLength=r+Ellipsoid_default.packedLength+VertexFormat_default.packedLength+2}PolylineVolumeGeometry.pack=function(e,t,o){if(!defined_default(e))throw new DeveloperError_default("value is required");if(!defined_default(t))throw new DeveloperError_default("array is required");let r;o=defaultValue_default(o,0);const a=e._positions;let l=a.length;for(t[o++]=l,r=0;r<l;++r,o+=Cartesian3_default.packedLength)Cartesian3_default.pack(a[r],t,o);const n=e._shape;for(l=n.length,t[o++]=l,r=0;r<l;++r,o+=Cartesian2_default.packedLength)Cartesian2_default.pack(n[r],t,o);return Ellipsoid_default.pack(e._ellipsoid,t,o),o+=Ellipsoid_default.packedLength,VertexFormat_default.pack(e._vertexFormat,t,o),o+=VertexFormat_default.packedLength,t[o++]=e._cornerType,t[o]=e._granularity,t};var scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchVertexFormat=new VertexFormat_default,scratchOptions={polylinePositions:void 0,shapePositions:void 0,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,cornerType:void 0,granularity:void 0};PolylineVolumeGeometry.unpack=function(e,t,o){if(!defined_default(e))throw new DeveloperError_default("array is required");let r;t=defaultValue_default(t,0);let a=e[t++];const l=new Array(a);for(r=0;r<a;++r,t+=Cartesian3_default.packedLength)l[r]=Cartesian3_default.unpack(e,t);a=e[t++];const n=new Array(a);for(r=0;r<a;++r,t+=Cartesian2_default.packedLength)n[r]=Cartesian2_default.unpack(e,t);const i=Ellipsoid_default.unpack(e,t,scratchEllipsoid);t+=Ellipsoid_default.packedLength;const u=VertexFormat_default.unpack(e,t,scratchVertexFormat);t+=VertexFormat_default.packedLength;const d=e[t++],s=e[t];return defined_default(o)?(o._positions=l,o._shape=n,o._ellipsoid=Ellipsoid_default.clone(i,o._ellipsoid),o._vertexFormat=VertexFormat_default.clone(u,o._vertexFormat),o._cornerType=d,o._granularity=s,o):(scratchOptions.polylinePositions=l,scratchOptions.shapePositions=n,scratchOptions.cornerType=d,scratchOptions.granularity=s,new PolylineVolumeGeometry(scratchOptions))};var brScratch=new BoundingRectangle_default;PolylineVolumeGeometry.createGeometry=function(e){const t=e._positions,o=arrayRemoveDuplicates_default(t,Cartesian3_default.equalsEpsilon);let r=e._shape;if(r=PolylineVolumeGeometryLibrary_default.removeDuplicatesFromShape(r),o.length<2||r.length<3)return;PolygonPipeline_default.computeWindingOrder2D(r)===WindingOrder_default.CLOCKWISE&&r.reverse();const a=BoundingRectangle_default.fromPoints(r,brScratch);return computeAttributes(PolylineVolumeGeometryLibrary_default.computePositions(o,r,a,e,!0),r,a,e._vertexFormat)};var PolylineVolumeGeometry_default=PolylineVolumeGeometry;function createPolylineVolumeGeometry(e,t){return defined_default(t)&&(e=PolylineVolumeGeometry_default.unpack(e,t)),e._ellipsoid=Ellipsoid_default.clone(e._ellipsoid),PolylineVolumeGeometry_default.createGeometry(e)}var createPolylineVolumeGeometry_default=createPolylineVolumeGeometry;export{createPolylineVolumeGeometry_default as default};