/*! For license information please see chunk-FRG2Z7DE.js.LICENSE.txt */
import{Quaternion_default}from"./chunk-D4YHO4NZ.js";import{Cartesian3_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";var EllipseGeometryLibrary={},rotAxis=new Cartesian3_default,tempVec=new Cartesian3_default,unitQuat=new Quaternion_default,rotMtx=new Matrix3_default;function pointOnEllipsoid(t,a,e,r,i,n,l,s,o,u){const c=t+a;Cartesian3_default.multiplyByScalar(r,Math.cos(c),rotAxis),Cartesian3_default.multiplyByScalar(e,Math.sin(c),tempVec),Cartesian3_default.add(rotAxis,tempVec,rotAxis);let d=Math.cos(t);d*=d;let f=Math.sin(t);f*=f;const _=n/Math.sqrt(l*d+i*f)/s;return Quaternion_default.fromAxisAngle(rotAxis,_,unitQuat),Matrix3_default.fromQuaternion(unitQuat,rotMtx),Matrix3_default.multiplyByVector(rotMtx,o,u),Cartesian3_default.normalize(u,u),Cartesian3_default.multiplyByScalar(u,s,u),u}var scratchCartesian1=new Cartesian3_default,scratchCartesian2=new Cartesian3_default,scratchCartesian3=new Cartesian3_default,scratchNormal=new Cartesian3_default;EllipseGeometryLibrary.raisePositionsToHeight=function(t,a,e){const r=a.ellipsoid,i=a.height,n=a.extrudedHeight,l=e?t.length/3*2:t.length/3,s=new Float64Array(3*l),o=t.length,u=e?o:0;for(let a=0;a<o;a+=3){const l=a+1,o=a+2,c=Cartesian3_default.fromArray(t,a,scratchCartesian1);r.scaleToGeodeticSurface(c,c);const d=Cartesian3_default.clone(c,scratchCartesian2),f=r.geodeticSurfaceNormal(c,scratchNormal),_=Cartesian3_default.multiplyByScalar(f,i,scratchCartesian3);Cartesian3_default.add(c,_,c),e&&(Cartesian3_default.multiplyByScalar(f,n,_),Cartesian3_default.add(d,_,d),s[a+u]=d.x,s[l+u]=d.y,s[o+u]=d.z),s[a]=c.x,s[l]=c.y,s[o]=c.z}return s};var unitPosScratch=new Cartesian3_default,eastVecScratch=new Cartesian3_default,northVecScratch=new Cartesian3_default;EllipseGeometryLibrary.computeEllipsePositions=function(t,a,e){const r=t.semiMinorAxis,i=t.semiMajorAxis,n=t.rotation,l=t.center,s=8*t.granularity,o=r*r,u=i*i,c=i*r,d=Cartesian3_default.magnitude(l),f=Cartesian3_default.normalize(l,unitPosScratch);let _=Cartesian3_default.cross(Cartesian3_default.UNIT_Z,l,eastVecScratch);_=Cartesian3_default.normalize(_,_);const h=Cartesian3_default.cross(f,_,northVecScratch);let y=1+Math.ceil(Math_default.PI_OVER_TWO/s);const p=Math_default.PI_OVER_TWO/(y-1);let C=Math_default.PI_OVER_TWO-y*p;C<0&&(y-=Math.ceil(Math.abs(C)/p));const m=a?new Array(y*(y+2)*2*3):void 0;let x=0,M=scratchCartesian1,O=scratchCartesian2;const E=4*y*3;let z=E-1,V=0;const P=e?new Array(E):void 0;let w,A,I,S,T;for(C=Math_default.PI_OVER_TWO,M=pointOnEllipsoid(C,n,h,_,o,c,u,d,f,M),a&&(m[x++]=M.x,m[x++]=M.y,m[x++]=M.z),e&&(P[z--]=M.z,P[z--]=M.y,P[z--]=M.x),C=Math_default.PI_OVER_TWO-p,w=1;w<y+1;++w){if(M=pointOnEllipsoid(C,n,h,_,o,c,u,d,f,M),O=pointOnEllipsoid(Math.PI-C,n,h,_,o,c,u,d,f,O),a){for(m[x++]=M.x,m[x++]=M.y,m[x++]=M.z,I=2*w+2,A=1;A<I-1;++A)S=A/(I-1),T=Cartesian3_default.lerp(M,O,S,scratchCartesian3),m[x++]=T.x,m[x++]=T.y,m[x++]=T.z;m[x++]=O.x,m[x++]=O.y,m[x++]=O.z}e&&(P[z--]=M.z,P[z--]=M.y,P[z--]=M.x,P[V++]=O.x,P[V++]=O.y,P[V++]=O.z),C=Math_default.PI_OVER_TWO-(w+1)*p}for(w=y;w>1;--w){if(C=Math_default.PI_OVER_TWO-(w-1)*p,M=pointOnEllipsoid(-C,n,h,_,o,c,u,d,f,M),O=pointOnEllipsoid(C+Math.PI,n,h,_,o,c,u,d,f,O),a){for(m[x++]=M.x,m[x++]=M.y,m[x++]=M.z,I=2*(w-1)+2,A=1;A<I-1;++A)S=A/(I-1),T=Cartesian3_default.lerp(M,O,S,scratchCartesian3),m[x++]=T.x,m[x++]=T.y,m[x++]=T.z;m[x++]=O.x,m[x++]=O.y,m[x++]=O.z}e&&(P[z--]=M.z,P[z--]=M.y,P[z--]=M.x,P[V++]=O.x,P[V++]=O.y,P[V++]=O.z)}C=Math_default.PI_OVER_TWO,M=pointOnEllipsoid(-C,n,h,_,o,c,u,d,f,M);const g={};return a&&(m[x++]=M.x,m[x++]=M.y,m[x++]=M.z,g.positions=m,g.numPts=y),e&&(P[z--]=M.z,P[z--]=M.y,P[z--]=M.x,g.outerPositions=P),g};var EllipseGeometryLibrary_default=EllipseGeometryLibrary;export{EllipseGeometryLibrary_default};