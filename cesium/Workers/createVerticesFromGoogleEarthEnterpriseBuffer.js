/*! For license information please see createVerticesFromGoogleEarthEnterpriseBuffer.js.LICENSE.txt */
import{EllipsoidalOccluder_default,TerrainEncoding_default}from"./chunk-SEFDWMCW.js";import{createTaskProcessorWorker_default}from"./chunk-AI3KSNM6.js";import{WebMercatorProjection_default}from"./chunk-K6Q5IRBK.js";import{OrientedBoundingBox_default}from"./chunk-QY2WY5XJ.js";import"./chunk-I6TVJ6T7.js";import"./chunk-MOLGJDJV.js";import{AxisAlignedBoundingBox_default}from"./chunk-FGUP2QEP.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{BoundingSphere_default,Transforms_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Cartesian2_default,Matrix4_default,Rectangle_default}from"./chunk-RSWBNJPT.js";import"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import{RuntimeError_default}from"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var sizeOfUint16=Uint16Array.BYTES_PER_ELEMENT,sizeOfInt32=Int32Array.BYTES_PER_ELEMENT,sizeOfUint32=Uint32Array.BYTES_PER_ELEMENT,sizeOfFloat=Float32Array.BYTES_PER_ELEMENT,sizeOfDouble=Float64Array.BYTES_PER_ELEMENT;function indexOfEpsilon(t,e,a){a=defaultValue_default(a,Math_default);const r=t.length;for(let i=0;i<r;++i)if(a.equalsEpsilon(t[i],e,Math_default.EPSILON12))return i;return-1}function createVerticesFromGoogleEarthEnterpriseBuffer(t,e){t.ellipsoid=Ellipsoid_default.clone(t.ellipsoid),t.rectangle=Rectangle_default.clone(t.rectangle);const a=processBuffer(t.buffer,t.relativeToCenter,t.ellipsoid,t.rectangle,t.nativeRectangle,t.exaggeration,t.exaggerationRelativeHeight,t.skirtHeight,t.includeWebMercatorT,t.negativeAltitudeExponentBias,t.negativeElevationThreshold),r=a.vertices;e.push(r.buffer);const i=a.indices;return e.push(i.buffer),{vertices:r.buffer,indices:i.buffer,numberOfAttributes:a.encoding.stride,minimumHeight:a.minimumHeight,maximumHeight:a.maximumHeight,boundingSphere3D:a.boundingSphere3D,orientedBoundingBox:a.orientedBoundingBox,occludeePointInScaledSpace:a.occludeePointInScaledSpace,encoding:a.encoding,vertexCountWithoutSkirts:a.vertexCountWithoutSkirts,indexCountWithoutSkirts:a.indexCountWithoutSkirts,westIndicesSouthToNorth:a.westIndicesSouthToNorth,southIndicesEastToWest:a.southIndicesEastToWest,eastIndicesNorthToSouth:a.eastIndicesNorthToSouth,northIndicesWestToEast:a.northIndicesWestToEast}}var scratchCartographic=new Cartographic_default,scratchCartesian=new Cartesian3_default,minimumScratch=new Cartesian3_default,maximumScratch=new Cartesian3_default,matrix4Scratch=new Matrix4_default;function processBuffer(t,e,a,r,i,n,o,s,c,u,l){let d,h,f,g,p,m;defined_default(r)?(d=r.west,h=r.south,f=r.east,g=r.north,p=r.width,m=r.height):(d=Math_default.toRadians(i.west),h=Math_default.toRadians(i.south),f=Math_default.toRadians(i.east),g=Math_default.toRadians(i.north),p=Math_default.toRadians(r.width),m=Math_default.toRadians(r.height));const _=[h,g],E=[d,f],I=Transforms_default.eastNorthUpToFixedFrame(e,a),C=Matrix4_default.inverseTransformation(I,matrix4Scratch);let T,x;c&&(T=WebMercatorProjection_default.geodeticLatitudeToMercatorAngle(h),x=1/(WebMercatorProjection_default.geodeticLatitudeToMercatorAngle(g)-T));const M=1!==n,N=new DataView(t);let S=Number.POSITIVE_INFINITY,O=Number.NEGATIVE_INFINITY;const B=minimumScratch;B.x=Number.POSITIVE_INFINITY,B.y=Number.POSITIVE_INFINITY,B.z=Number.POSITIVE_INFINITY;const k=maximumScratch;k.x=Number.NEGATIVE_INFINITY,k.y=Number.NEGATIVE_INFINITY,k.z=Number.NEGATIVE_INFINITY;let b,P,R=0,w=0,F=0;for(P=0;P<4;++P){let t=R;b=N.getUint32(t,!0),t+=sizeOfUint32;const e=Math_default.toRadians(180*N.getFloat64(t,!0));t+=sizeOfDouble,-1===indexOfEpsilon(E,e)&&E.push(e);const a=Math_default.toRadians(180*N.getFloat64(t,!0));t+=sizeOfDouble,-1===indexOfEpsilon(_,a)&&_.push(a),t+=2*sizeOfDouble;let r=N.getInt32(t,!0);t+=sizeOfInt32,w+=r,r=N.getInt32(t,!0),F+=3*r,R+=b+sizeOfUint32}const A=[],W=[],y=new Array(w),V=new Array(w),j=new Array(w),z=c?new Array(w):[],v=M?new Array(w):[],D=new Array(F),U=[],Y=[],H=[],L=[];let G=0,J=0;for(R=0,P=0;P<4;++P){b=N.getUint32(R,!0),R+=sizeOfUint32;const t=R,e=Math_default.toRadians(180*N.getFloat64(R,!0));R+=sizeOfDouble;const r=Math_default.toRadians(180*N.getFloat64(R,!0));R+=sizeOfDouble;const i=Math_default.toRadians(180*N.getFloat64(R,!0)),n=.5*i;R+=sizeOfDouble;const o=Math_default.toRadians(180*N.getFloat64(R,!0)),s=.5*o;R+=sizeOfDouble;const p=N.getInt32(R,!0);R+=sizeOfInt32;const m=N.getInt32(R,!0);R+=sizeOfInt32,R+=sizeOfInt32;const I=new Array(p);for(let t=0;t<p;++t){const p=e+N.getUint8(R++)*i;scratchCartographic.longitude=p;const m=r+N.getUint8(R++)*o;scratchCartographic.latitude=m;let b=N.getFloat32(R,!0);if(R+=sizeOfFloat,0!==b&&b<l&&(b*=-Math.pow(2,u)),b*=6371010,scratchCartographic.height=b,-1!==indexOfEpsilon(E,p)||-1!==indexOfEpsilon(_,m)){const e=indexOfEpsilon(A,scratchCartographic,Cartographic_default);if(-1!==e){I[t]=W[e];continue}A.push(Cartographic_default.clone(scratchCartographic)),W.push(G)}I[t]=G,Math.abs(p-d)<n?U.push({index:G,cartographic:Cartographic_default.clone(scratchCartographic)}):Math.abs(p-f)<n?H.push({index:G,cartographic:Cartographic_default.clone(scratchCartographic)}):Math.abs(m-h)<s?Y.push({index:G,cartographic:Cartographic_default.clone(scratchCartographic)}):Math.abs(m-g)<s&&L.push({index:G,cartographic:Cartographic_default.clone(scratchCartographic)}),S=Math.min(b,S),O=Math.max(b,O),j[G]=b;const P=a.cartographicToCartesian(scratchCartographic);if(y[G]=P,c&&(z[G]=(WebMercatorProjection_default.geodeticLatitudeToMercatorAngle(m)-T)*x),M){const t=a.geodeticSurfaceNormal(P);v[G]=t}Matrix4_default.multiplyByPoint(C,P,scratchCartesian),Cartesian3_default.minimumByComponent(scratchCartesian,B,B),Cartesian3_default.maximumByComponent(scratchCartesian,k,k);let w=(p-d)/(f-d);w=Math_default.clamp(w,0,1);let F=(m-h)/(g-h);F=Math_default.clamp(F,0,1),V[G]=new Cartesian2_default(w,F),++G}const P=3*m;for(let t=0;t<P;++t,++J)D[J]=I[N.getUint16(R,!0)],R+=sizeOfUint16;if(b!==R-t)throw new RuntimeError_default("Invalid terrain tile.")}y.length=G,V.length=G,j.length=G,c&&(z.length=G),M&&(v.length=G);const K=G,Q=J,X={hMin:S,lastBorderPoint:void 0,skirtHeight:s,toENU:C,ellipsoid:a,minimum:B,maximum:k};U.sort((function(t,e){return e.cartographic.latitude-t.cartographic.latitude})),Y.sort((function(t,e){return t.cartographic.longitude-e.cartographic.longitude})),H.sort((function(t,e){return t.cartographic.latitude-e.cartographic.latitude})),L.sort((function(t,e){return e.cartographic.longitude-t.cartographic.longitude}));const Z=1e-5;if(addSkirt(y,j,V,z,v,D,X,U,-1e-5*p,!0,-1e-5*m),addSkirt(y,j,V,z,v,D,X,Y,-1e-5*m,!1),addSkirt(y,j,V,z,v,D,X,H,Z*p,!0,Z*m),addSkirt(y,j,V,z,v,D,X,L,Z*m,!1),U.length>0&&L.length>0){const t=U[0].index,e=K,a=L[L.length-1].index,r=y.length-1;D.push(a,r,e,e,t,a)}w=y.length;const q=BoundingSphere_default.fromPoints(y);let $;defined_default(r)&&($=OrientedBoundingBox_default.fromRectangle(r,S,O,a));const tt=new EllipsoidalOccluder_default(a).computeHorizonCullingPointPossiblyUnderEllipsoid(e,y,S),et=new AxisAlignedBoundingBox_default(B,k,e),at=new TerrainEncoding_default(e,et,X.hMin,O,I,!1,c,M,n,o),rt=new Float32Array(w*at.stride);let it=0;for(let t=0;t<w;++t)it=at.encode(rt,it,y[t],V[t],j[t],void 0,z[t],v[t]);const nt=U.map((function(t){return t.index})).reverse(),ot=Y.map((function(t){return t.index})).reverse(),st=H.map((function(t){return t.index})).reverse(),ct=L.map((function(t){return t.index})).reverse();return ot.unshift(st[st.length-1]),ot.push(nt[0]),ct.unshift(nt[nt.length-1]),ct.push(st[0]),{vertices:rt,indices:new Uint16Array(D),maximumHeight:O,minimumHeight:S,encoding:at,boundingSphere3D:q,orientedBoundingBox:$,occludeePointInScaledSpace:tt,vertexCountWithoutSkirts:K,indexCountWithoutSkirts:Q,westIndicesSouthToNorth:nt,southIndicesEastToWest:ot,eastIndicesNorthToSouth:st,northIndicesWestToEast:ct}}function addSkirt(t,e,a,r,i,n,o,s,c,u,l){const d=s.length;for(let h=0;h<d;++h){const f=s[h],g=f.cartographic,p=f.index,m=t.length,_=g.longitude;let E=g.latitude;E=Math_default.clamp(E,-Math_default.PI_OVER_TWO,Math_default.PI_OVER_TWO);const I=g.height-o.skirtHeight;o.hMin=Math.min(o.hMin,I),Cartographic_default.fromRadians(_,E,I,scratchCartographic),u&&(scratchCartographic.longitude+=c),u?h===d-1?scratchCartographic.latitude+=l:0===h&&(scratchCartographic.latitude-=l):scratchCartographic.latitude+=c;const C=o.ellipsoid.cartographicToCartesian(scratchCartographic);t.push(C),e.push(I),a.push(Cartesian2_default.clone(a[p])),r.length>0&&r.push(r[p]),i.length>0&&i.push(i[p]),Matrix4_default.multiplyByPoint(o.toENU,C,scratchCartesian);const T=o.minimum,x=o.maximum;Cartesian3_default.minimumByComponent(scratchCartesian,T,T),Cartesian3_default.maximumByComponent(scratchCartesian,x,x);const M=o.lastBorderPoint;if(defined_default(M)){const t=M.index;n.push(t,m-1,m,m,p,t)}o.lastBorderPoint=f}}var createVerticesFromGoogleEarthEnterpriseBuffer_default=createTaskProcessorWorker_default(createVerticesFromGoogleEarthEnterpriseBuffer);export{createVerticesFromGoogleEarthEnterpriseBuffer_default as default};