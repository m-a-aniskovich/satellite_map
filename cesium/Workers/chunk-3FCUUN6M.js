/*! For license information please see chunk-3FCUUN6M.js.LICENSE.txt */
import{EllipsoidGeodesic_default}from"./chunk-LSGUCCKJ.js";import{EllipsoidRhumbLine_default}from"./chunk-6PWSSCRA.js";import{IntersectionTests_default}from"./chunk-HEROVJML.js";import{Plane_default}from"./chunk-4EYB62WJ.js";import{Matrix4_default}from"./chunk-RSWBNJPT.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var PolylinePipeline={numberOfPoints:function(e,t,a){const i=Cartesian3_default.distance(e,t);return Math.ceil(i/a)},numberOfPointsRhumbLine:function(e,t,a){const i=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(i/(a*a))))}},cartoScratch=new Cartographic_default;PolylinePipeline.extractHeights=function(e,t){const a=e.length,i=new Array(a);for(let r=0;r<a;r++){const a=e[r];i[r]=t.cartesianToCartographic(a,cartoScratch).height}return i};var wrapLongitudeInversMatrix=new Matrix4_default,wrapLongitudeOrigin=new Cartesian3_default,wrapLongitudeXZNormal=new Cartesian3_default,wrapLongitudeXZPlane=new Plane_default(Cartesian3_default.UNIT_X,0),wrapLongitudeYZNormal=new Cartesian3_default,wrapLongitudeYZPlane=new Plane_default(Cartesian3_default.UNIT_X,0),wrapLongitudeIntersection=new Cartesian3_default,wrapLongitudeOffset=new Cartesian3_default,subdivideHeightsScratchArray=[];function subdivideHeights(e,t,a){const i=subdivideHeightsScratchArray;let r;if(i.length=e,t===a){for(r=0;r<e;r++)i[r]=t;return i}const n=(a-t)/e;for(r=0;r<e;r++){const e=t+r*n;i[r]=e}return i}var carto1=new Cartographic_default,carto2=new Cartographic_default,cartesian=new Cartesian3_default,scaleFirst=new Cartesian3_default,scaleLast=new Cartesian3_default,ellipsoidGeodesic=new EllipsoidGeodesic_default,ellipsoidRhumb=new EllipsoidRhumbLine_default;function generateCartesianArc(e,t,a,i,r,n,l,o){const s=i.scaleToGeodeticSurface(e,scaleFirst),u=i.scaleToGeodeticSurface(t,scaleLast),c=PolylinePipeline.numberOfPoints(e,t,a),d=i.cartesianToCartographic(s,carto1),f=i.cartesianToCartographic(u,carto2),p=subdivideHeights(c,r,n);ellipsoidGeodesic.setEndPoints(d,f);const h=ellipsoidGeodesic.surfaceDistance/c;let g=o;d.height=r;let _=i.cartographicToCartesian(d,cartesian);Cartesian3_default.pack(_,l,g),g+=3;for(let e=1;e<c;e++){const t=ellipsoidGeodesic.interpolateUsingSurfaceDistance(e*h,carto2);t.height=p[e],_=i.cartographicToCartesian(t,cartesian),Cartesian3_default.pack(_,l,g),g+=3}return g}function generateCartesianRhumbArc(e,t,a,i,r,n,l,o){const s=i.cartesianToCartographic(e,carto1),u=i.cartesianToCartographic(t,carto2),c=PolylinePipeline.numberOfPointsRhumbLine(s,u,a);s.height=0,u.height=0;const d=subdivideHeights(c,r,n);ellipsoidRhumb.ellipsoid.equals(i)||(ellipsoidRhumb=new EllipsoidRhumbLine_default(void 0,void 0,i)),ellipsoidRhumb.setEndPoints(s,u);const f=ellipsoidRhumb.surfaceDistance/c;let p=o;s.height=r;let h=i.cartographicToCartesian(s,cartesian);Cartesian3_default.pack(h,l,p),p+=3;for(let e=1;e<c;e++){const t=ellipsoidRhumb.interpolateUsingSurfaceDistance(e*f,carto2);t.height=d[e],h=i.cartographicToCartesian(t,cartesian),Cartesian3_default.pack(h,l,p),p+=3}return p}PolylinePipeline.wrapLongitude=function(e,t){const a=[],i=[];if(defined_default(e)&&e.length>0){t=defaultValue_default(t,Matrix4_default.IDENTITY);const r=Matrix4_default.inverseTransformation(t,wrapLongitudeInversMatrix),n=Matrix4_default.multiplyByPoint(r,Cartesian3_default.ZERO,wrapLongitudeOrigin),l=Cartesian3_default.normalize(Matrix4_default.multiplyByPointAsVector(r,Cartesian3_default.UNIT_Y,wrapLongitudeXZNormal),wrapLongitudeXZNormal),o=Plane_default.fromPointNormal(n,l,wrapLongitudeXZPlane),s=Cartesian3_default.normalize(Matrix4_default.multiplyByPointAsVector(r,Cartesian3_default.UNIT_X,wrapLongitudeYZNormal),wrapLongitudeYZNormal),u=Plane_default.fromPointNormal(n,s,wrapLongitudeYZPlane);let c=1;a.push(Cartesian3_default.clone(e[0]));let d=a[0];const f=e.length;for(let t=1;t<f;++t){const r=e[t];if(Plane_default.getPointDistance(u,d)<0||Plane_default.getPointDistance(u,r)<0){const e=IntersectionTests_default.lineSegmentPlane(d,r,o,wrapLongitudeIntersection);if(defined_default(e)){const t=Cartesian3_default.multiplyByScalar(l,5e-9,wrapLongitudeOffset);Plane_default.getPointDistance(o,d)<0&&Cartesian3_default.negate(t,t),a.push(Cartesian3_default.add(e,t,new Cartesian3_default)),i.push(c+1),Cartesian3_default.negate(t,t),a.push(Cartesian3_default.add(e,t,new Cartesian3_default)),c=1}}a.push(Cartesian3_default.clone(e[t])),c++,d=r}i.push(c)}return{positions:a,lengths:i}},PolylinePipeline.generateArc=function(e){defined_default(e)||(e={});const t=e.positions;if(!defined_default(t))throw new DeveloperError_default("options.positions is required.");const a=t.length,i=defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84);let r=defaultValue_default(e.height,0);const n=Array.isArray(r);if(a<1)return[];if(1===a){const e=i.scaleToGeodeticSurface(t[0],scaleFirst);if(r=n?r[0]:r,0!==r){const t=i.geodeticSurfaceNormal(e,cartesian);Cartesian3_default.multiplyByScalar(t,r,t),Cartesian3_default.add(e,t,e)}return[e.x,e.y,e.z]}let l=e.minDistance;if(!defined_default(l)){const t=defaultValue_default(e.granularity,Math_default.RADIANS_PER_DEGREE);l=Math_default.chordLength(t,i.maximumRadius)}let o,s=0;for(o=0;o<a-1;o++)s+=PolylinePipeline.numberOfPoints(t[o],t[o+1],l);const u=3*(s+1),c=new Array(u);let d=0;for(o=0;o<a-1;o++)d=generateCartesianArc(t[o],t[o+1],l,i,n?r[o]:r,n?r[o+1]:r,c,d);subdivideHeightsScratchArray.length=0;const f=t[a-1],p=i.cartesianToCartographic(f,carto1);p.height=n?r[a-1]:r;const h=i.cartographicToCartesian(p,cartesian);return Cartesian3_default.pack(h,c,u-3),c};var scratchCartographic0=new Cartographic_default,scratchCartographic1=new Cartographic_default;PolylinePipeline.generateRhumbArc=function(e){defined_default(e)||(e={});const t=e.positions;if(!defined_default(t))throw new DeveloperError_default("options.positions is required.");const a=t.length,i=defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84);let r=defaultValue_default(e.height,0);const n=Array.isArray(r);if(a<1)return[];if(1===a){const e=i.scaleToGeodeticSurface(t[0],scaleFirst);if(r=n?r[0]:r,0!==r){const t=i.geodeticSurfaceNormal(e,cartesian);Cartesian3_default.multiplyByScalar(t,r,t),Cartesian3_default.add(e,t,e)}return[e.x,e.y,e.z]}const l=defaultValue_default(e.granularity,Math_default.RADIANS_PER_DEGREE);let o,s,u=0,c=i.cartesianToCartographic(t[0],scratchCartographic0);for(o=0;o<a-1;o++)s=i.cartesianToCartographic(t[o+1],scratchCartographic1),u+=PolylinePipeline.numberOfPointsRhumbLine(c,s,l),c=Cartographic_default.clone(s,scratchCartographic0);const d=3*(u+1),f=new Array(d);let p=0;for(o=0;o<a-1;o++)p=generateCartesianRhumbArc(t[o],t[o+1],l,i,n?r[o]:r,n?r[o+1]:r,f,p);subdivideHeightsScratchArray.length=0;const h=t[a-1],g=i.cartesianToCartographic(h,carto1);g.height=n?r[a-1]:r;const _=i.cartographicToCartesian(g,cartesian);return Cartesian3_default.pack(_,f,d-3),f},PolylinePipeline.generateCartesianArc=function(e){const t=PolylinePipeline.generateArc(e),a=t.length/3,i=new Array(a);for(let e=0;e<a;e++)i[e]=Cartesian3_default.unpack(t,3*e);return i},PolylinePipeline.generateCartesianRhumbArc=function(e){const t=PolylinePipeline.generateRhumbArc(e),a=t.length/3,i=new Array(a);for(let e=0;e<a;e++)i[e]=Cartesian3_default.unpack(t,3*e);return i};var PolylinePipeline_default=PolylinePipeline;export{PolylinePipeline_default};