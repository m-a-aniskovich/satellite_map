define(["exports","./Transforms-e2d4a55a","./Matrix3-41c58dde","./Matrix2-e1298525","./Check-6ede7e26","./ComponentDatatype-cf1fa08e","./defaultValue-fe22d8c0","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./Math-0a2ac845","./Plane-4c3d403b","./VertexFormat-030f11ff"],(function(e,t,r,i,n,a,o,s,f,u,d,l){"use strict";function h(e){this.planes=o.defaultValue(e,[])}const p=[new r.Cartesian3,new r.Cartesian3,new r.Cartesian3];r.Cartesian3.clone(r.Cartesian3.UNIT_X,p[0]),r.Cartesian3.clone(r.Cartesian3.UNIT_Y,p[1]),r.Cartesian3.clone(r.Cartesian3.UNIT_Z,p[2]);const c=new r.Cartesian3,m=new r.Cartesian3,C=new d.Plane(new r.Cartesian3(1,0,0),0);function w(e){e=o.defaultValue(e,o.defaultValue.EMPTY_OBJECT),this.left=e.left,this._left=void 0,this.right=e.right,this._right=void 0,this.top=e.top,this._top=void 0,this.bottom=e.bottom,this._bottom=void 0,this.near=o.defaultValue(e.near,1),this._near=this.near,this.far=o.defaultValue(e.far,5e8),this._far=this.far,this._cullingVolume=new h,this._orthographicMatrix=new i.Matrix4}function _(e){if(!(o.defined(e.right)&&o.defined(e.left)&&o.defined(e.top)&&o.defined(e.bottom)&&o.defined(e.near)&&o.defined(e.far)))throw new n.DeveloperError("right, left, top, bottom, near, or far parameters are not set.");if(e.top!==e._top||e.bottom!==e._bottom||e.left!==e._left||e.right!==e._right||e.near!==e._near||e.far!==e._far){if(e.left>e.right)throw new n.DeveloperError("right must be greater than left.");if(e.bottom>e.top)throw new n.DeveloperError("top must be greater than bottom.");if(e.near<=0||e.near>e.far)throw new n.DeveloperError("near must be greater than zero and less than far.");e._left=e.left,e._right=e.right,e._top=e.top,e._bottom=e.bottom,e._near=e.near,e._far=e.far,e._orthographicMatrix=i.Matrix4.computeOrthographicOffCenter(e.left,e.right,e.bottom,e.top,e.near,e.far,e._orthographicMatrix)}}h.fromBoundingSphere=function(e,t){if(!o.defined(e))throw new n.DeveloperError("boundingSphere is required.");o.defined(t)||(t=new h);const a=p.length,s=t.planes;s.length=2*a;const f=e.center,u=e.radius;let d=0;for(let e=0;e<a;++e){const t=p[e];let n=s[d],a=s[d+1];o.defined(n)||(n=s[d]=new i.Cartesian4),o.defined(a)||(a=s[d+1]=new i.Cartesian4),r.Cartesian3.multiplyByScalar(t,-u,c),r.Cartesian3.add(f,c,c),n.x=t.x,n.y=t.y,n.z=t.z,n.w=-r.Cartesian3.dot(t,c),r.Cartesian3.multiplyByScalar(t,u,c),r.Cartesian3.add(f,c,c),a.x=-t.x,a.y=-t.y,a.z=-t.z,a.w=-r.Cartesian3.dot(r.Cartesian3.negate(t,m),c),d+=2}return t},h.prototype.computeVisibility=function(e){if(!o.defined(e))throw new n.DeveloperError("boundingVolume is required.");const r=this.planes;let i=!1;for(let n=0,a=r.length;n<a;++n){const a=e.intersectPlane(d.Plane.fromCartesian4(r[n],C));if(a===t.Intersect.OUTSIDE)return t.Intersect.OUTSIDE;a===t.Intersect.INTERSECTING&&(i=!0)}return i?t.Intersect.INTERSECTING:t.Intersect.INSIDE},h.prototype.computeVisibilityWithPlaneMask=function(e,r){if(!o.defined(e))throw new n.DeveloperError("boundingVolume is required.");if(!o.defined(r))throw new n.DeveloperError("parentPlaneMask is required.");if(r===h.MASK_OUTSIDE||r===h.MASK_INSIDE)return r;let i=h.MASK_INSIDE;const a=this.planes;for(let n=0,o=a.length;n<o;++n){const o=n<31?1<<n:0;if(n<31&&0==(r&o))continue;const s=e.intersectPlane(d.Plane.fromCartesian4(a[n],C));if(s===t.Intersect.OUTSIDE)return h.MASK_OUTSIDE;s===t.Intersect.INTERSECTING&&(i|=o)}return i},h.MASK_OUTSIDE=4294967295,h.MASK_INSIDE=0,h.MASK_INDETERMINATE=2147483647,Object.defineProperties(w.prototype,{projectionMatrix:{get:function(){return _(this),this._orthographicMatrix}}});const y=new r.Cartesian3,g=new r.Cartesian3,v=new r.Cartesian3,x=new r.Cartesian3;function b(e){e=o.defaultValue(e,o.defaultValue.EMPTY_OBJECT),this._offCenterFrustum=new w,this.width=e.width,this._width=void 0,this.aspectRatio=e.aspectRatio,this._aspectRatio=void 0,this.near=o.defaultValue(e.near,1),this._near=this.near,this.far=o.defaultValue(e.far,5e8),this._far=this.far}function E(e){if(!(o.defined(e.width)&&o.defined(e.aspectRatio)&&o.defined(e.near)&&o.defined(e.far)))throw new n.DeveloperError("width, aspectRatio, near, or far parameters are not set.");const t=e._offCenterFrustum;if(e.width!==e._width||e.aspectRatio!==e._aspectRatio||e.near!==e._near||e.far!==e._far){if(e.aspectRatio<0)throw new n.DeveloperError("aspectRatio must be positive.");if(e.near<0||e.near>e.far)throw new n.DeveloperError("near must be greater than zero and less than far.");e._aspectRatio=e.aspectRatio,e._width=e.width,e._near=e.near,e._far=e.far;const r=1/e.aspectRatio;t.right=.5*e.width,t.left=-t.right,t.top=r*t.right,t.bottom=-t.top,t.near=e.near,t.far=e.far}}function M(e){e=o.defaultValue(e,o.defaultValue.EMPTY_OBJECT),this.left=e.left,this._left=void 0,this.right=e.right,this._right=void 0,this.top=e.top,this._top=void 0,this.bottom=e.bottom,this._bottom=void 0,this.near=o.defaultValue(e.near,1),this._near=this.near,this.far=o.defaultValue(e.far,5e8),this._far=this.far,this._cullingVolume=new h,this._perspectiveMatrix=new i.Matrix4,this._infinitePerspective=new i.Matrix4}function D(e){if(!(o.defined(e.right)&&o.defined(e.left)&&o.defined(e.top)&&o.defined(e.bottom)&&o.defined(e.near)&&o.defined(e.far)))throw new n.DeveloperError("right, left, top, bottom, near, or far parameters are not set.");const t=e.top,r=e.bottom,a=e.right,s=e.left,f=e.near,u=e.far;if(t!==e._top||r!==e._bottom||s!==e._left||a!==e._right||f!==e._near||u!==e._far){if(e.near<=0||e.near>e.far)throw new n.DeveloperError("near must be greater than zero and less than far.");e._left=s,e._right=a,e._top=t,e._bottom=r,e._near=f,e._far=u,e._perspectiveMatrix=i.Matrix4.computePerspectiveOffCenter(s,a,r,t,f,u,e._perspectiveMatrix),e._infinitePerspective=i.Matrix4.computeInfinitePerspectiveOffCenter(s,a,r,t,f,e._infinitePerspective)}}w.prototype.computeCullingVolume=function(e,t,a){if(!o.defined(e))throw new n.DeveloperError("position is required.");if(!o.defined(t))throw new n.DeveloperError("direction is required.");if(!o.defined(a))throw new n.DeveloperError("up is required.");const s=this._cullingVolume.planes,f=this.top,u=this.bottom,d=this.right,l=this.left,h=this.near,p=this.far,c=r.Cartesian3.cross(t,a,y);r.Cartesian3.normalize(c,c);const m=g;r.Cartesian3.multiplyByScalar(t,h,m),r.Cartesian3.add(e,m,m);const C=v;r.Cartesian3.multiplyByScalar(c,l,C),r.Cartesian3.add(m,C,C);let w=s[0];return o.defined(w)||(w=s[0]=new i.Cartesian4),w.x=c.x,w.y=c.y,w.z=c.z,w.w=-r.Cartesian3.dot(c,C),r.Cartesian3.multiplyByScalar(c,d,C),r.Cartesian3.add(m,C,C),w=s[1],o.defined(w)||(w=s[1]=new i.Cartesian4),w.x=-c.x,w.y=-c.y,w.z=-c.z,w.w=-r.Cartesian3.dot(r.Cartesian3.negate(c,x),C),r.Cartesian3.multiplyByScalar(a,u,C),r.Cartesian3.add(m,C,C),w=s[2],o.defined(w)||(w=s[2]=new i.Cartesian4),w.x=a.x,w.y=a.y,w.z=a.z,w.w=-r.Cartesian3.dot(a,C),r.Cartesian3.multiplyByScalar(a,f,C),r.Cartesian3.add(m,C,C),w=s[3],o.defined(w)||(w=s[3]=new i.Cartesian4),w.x=-a.x,w.y=-a.y,w.z=-a.z,w.w=-r.Cartesian3.dot(r.Cartesian3.negate(a,x),C),w=s[4],o.defined(w)||(w=s[4]=new i.Cartesian4),w.x=t.x,w.y=t.y,w.z=t.z,w.w=-r.Cartesian3.dot(t,m),r.Cartesian3.multiplyByScalar(t,p,C),r.Cartesian3.add(e,C,C),w=s[5],o.defined(w)||(w=s[5]=new i.Cartesian4),w.x=-t.x,w.y=-t.y,w.z=-t.z,w.w=-r.Cartesian3.dot(r.Cartesian3.negate(t,x),C),this._cullingVolume},w.prototype.getPixelDimensions=function(e,t,r,i,a){if(_(this),!o.defined(e)||!o.defined(t))throw new n.DeveloperError("Both drawingBufferWidth and drawingBufferHeight are required.");if(e<=0)throw new n.DeveloperError("drawingBufferWidth must be greater than zero.");if(t<=0)throw new n.DeveloperError("drawingBufferHeight must be greater than zero.");if(!o.defined(r))throw new n.DeveloperError("distance is required.");if(!o.defined(i))throw new n.DeveloperError("pixelRatio is required.");if(i<=0)throw new n.DeveloperError("pixelRatio must be greater than zero.");if(!o.defined(a))throw new n.DeveloperError("A result object is required.");const s=i*(this.right-this.left)/e,f=i*(this.top-this.bottom)/t;return a.x=s,a.y=f,a},w.prototype.clone=function(e){return o.defined(e)||(e=new w),e.left=this.left,e.right=this.right,e.top=this.top,e.bottom=this.bottom,e.near=this.near,e.far=this.far,e._left=void 0,e._right=void 0,e._top=void 0,e._bottom=void 0,e._near=void 0,e._far=void 0,e},w.prototype.equals=function(e){return o.defined(e)&&e instanceof w&&this.right===e.right&&this.left===e.left&&this.top===e.top&&this.bottom===e.bottom&&this.near===e.near&&this.far===e.far},w.prototype.equalsEpsilon=function(e,t,r){return e===this||o.defined(e)&&e instanceof w&&u.CesiumMath.equalsEpsilon(this.right,e.right,t,r)&&u.CesiumMath.equalsEpsilon(this.left,e.left,t,r)&&u.CesiumMath.equalsEpsilon(this.top,e.top,t,r)&&u.CesiumMath.equalsEpsilon(this.bottom,e.bottom,t,r)&&u.CesiumMath.equalsEpsilon(this.near,e.near,t,r)&&u.CesiumMath.equalsEpsilon(this.far,e.far,t,r)},b.packedLength=4,b.pack=function(e,t,r){return n.Check.typeOf.object("value",e),n.Check.defined("array",t),r=o.defaultValue(r,0),t[r++]=e.width,t[r++]=e.aspectRatio,t[r++]=e.near,t[r]=e.far,t},b.unpack=function(e,t,r){return n.Check.defined("array",e),t=o.defaultValue(t,0),o.defined(r)||(r=new b),r.width=e[t++],r.aspectRatio=e[t++],r.near=e[t++],r.far=e[t],r},Object.defineProperties(b.prototype,{projectionMatrix:{get:function(){return E(this),this._offCenterFrustum.projectionMatrix}},offCenterFrustum:{get:function(){return E(this),this._offCenterFrustum}}}),b.prototype.computeCullingVolume=function(e,t,r){return E(this),this._offCenterFrustum.computeCullingVolume(e,t,r)},b.prototype.getPixelDimensions=function(e,t,r,i,n){return E(this),this._offCenterFrustum.getPixelDimensions(e,t,r,i,n)},b.prototype.clone=function(e){return o.defined(e)||(e=new b),e.aspectRatio=this.aspectRatio,e.width=this.width,e.near=this.near,e.far=this.far,e._aspectRatio=void 0,e._width=void 0,e._near=void 0,e._far=void 0,this._offCenterFrustum.clone(e._offCenterFrustum),e},b.prototype.equals=function(e){return!!(o.defined(e)&&e instanceof b)&&(E(this),E(e),this.width===e.width&&this.aspectRatio===e.aspectRatio&&this._offCenterFrustum.equals(e._offCenterFrustum))},b.prototype.equalsEpsilon=function(e,t,r){return!!(o.defined(e)&&e instanceof b)&&(E(this),E(e),u.CesiumMath.equalsEpsilon(this.width,e.width,t,r)&&u.CesiumMath.equalsEpsilon(this.aspectRatio,e.aspectRatio,t,r)&&this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum,t,r))},Object.defineProperties(M.prototype,{projectionMatrix:{get:function(){return D(this),this._perspectiveMatrix}},infiniteProjectionMatrix:{get:function(){return D(this),this._infinitePerspective}}});const F=new r.Cartesian3,V=new r.Cartesian3,O=new r.Cartesian3,z=new r.Cartesian3;function R(e){e=o.defaultValue(e,o.defaultValue.EMPTY_OBJECT),this._offCenterFrustum=new M,this.fov=e.fov,this._fov=void 0,this._fovy=void 0,this._sseDenominator=void 0,this.aspectRatio=e.aspectRatio,this._aspectRatio=void 0,this.near=o.defaultValue(e.near,1),this._near=this.near,this.far=o.defaultValue(e.far,5e8),this._far=this.far,this.xOffset=o.defaultValue(e.xOffset,0),this._xOffset=this.xOffset,this.yOffset=o.defaultValue(e.yOffset,0),this._yOffset=this.yOffset}function k(e){if(!(o.defined(e.fov)&&o.defined(e.aspectRatio)&&o.defined(e.near)&&o.defined(e.far)))throw new n.DeveloperError("fov, aspectRatio, near, or far parameters are not set.");const t=e._offCenterFrustum;if(e.fov!==e._fov||e.aspectRatio!==e._aspectRatio||e.near!==e._near||e.far!==e._far||e.xOffset!==e._xOffset||e.yOffset!==e._yOffset){if(e.fov<0||e.fov>=Math.PI)throw new n.DeveloperError("fov must be in the range [0, PI).");if(e.aspectRatio<0)throw new n.DeveloperError("aspectRatio must be positive.");if(e.near<0||e.near>e.far)throw new n.DeveloperError("near must be greater than zero and less than far.");e._aspectRatio=e.aspectRatio,e._fov=e.fov,e._fovy=e.aspectRatio<=1?e.fov:2*Math.atan(Math.tan(.5*e.fov)/e.aspectRatio),e._near=e.near,e._far=e.far,e._sseDenominator=2*Math.tan(.5*e._fovy),e._xOffset=e.xOffset,e._yOffset=e.yOffset,t.top=e.near*Math.tan(.5*e._fovy),t.bottom=-t.top,t.right=e.aspectRatio*t.top,t.left=-t.right,t.near=e.near,t.far=e.far,t.right+=e.xOffset,t.left+=e.xOffset,t.top+=e.yOffset,t.bottom+=e.yOffset}}function P(e){n.Check.typeOf.object("options",e),n.Check.typeOf.object("options.frustum",e.frustum),n.Check.typeOf.object("options.origin",e.origin),n.Check.typeOf.object("options.orientation",e.orientation);const i=e.frustum,a=e.orientation,s=e.origin,f=o.defaultValue(e.vertexFormat,l.VertexFormat.DEFAULT),u=o.defaultValue(e._drawNearPlane,!0);let d,h;i instanceof R?(d=0,h=R.packedLength):i instanceof b&&(d=1,h=b.packedLength),this._frustumType=d,this._frustum=i.clone(),this._origin=r.Cartesian3.clone(s),this._orientation=t.Quaternion.clone(a),this._drawNearPlane=u,this._vertexFormat=f,this._workerName="createFrustumGeometry",this.packedLength=2+h+r.Cartesian3.packedLength+t.Quaternion.packedLength+l.VertexFormat.packedLength}M.prototype.computeCullingVolume=function(e,t,a){if(!o.defined(e))throw new n.DeveloperError("position is required.");if(!o.defined(t))throw new n.DeveloperError("direction is required.");if(!o.defined(a))throw new n.DeveloperError("up is required.");const s=this._cullingVolume.planes,f=this.top,u=this.bottom,d=this.right,l=this.left,h=this.near,p=this.far,c=r.Cartesian3.cross(t,a,F),m=V;r.Cartesian3.multiplyByScalar(t,h,m),r.Cartesian3.add(e,m,m);const C=O;r.Cartesian3.multiplyByScalar(t,p,C),r.Cartesian3.add(e,C,C);const w=z;r.Cartesian3.multiplyByScalar(c,l,w),r.Cartesian3.add(m,w,w),r.Cartesian3.subtract(w,e,w),r.Cartesian3.normalize(w,w),r.Cartesian3.cross(w,a,w),r.Cartesian3.normalize(w,w);let _=s[0];return o.defined(_)||(_=s[0]=new i.Cartesian4),_.x=w.x,_.y=w.y,_.z=w.z,_.w=-r.Cartesian3.dot(w,e),r.Cartesian3.multiplyByScalar(c,d,w),r.Cartesian3.add(m,w,w),r.Cartesian3.subtract(w,e,w),r.Cartesian3.cross(a,w,w),r.Cartesian3.normalize(w,w),_=s[1],o.defined(_)||(_=s[1]=new i.Cartesian4),_.x=w.x,_.y=w.y,_.z=w.z,_.w=-r.Cartesian3.dot(w,e),r.Cartesian3.multiplyByScalar(a,u,w),r.Cartesian3.add(m,w,w),r.Cartesian3.subtract(w,e,w),r.Cartesian3.cross(c,w,w),r.Cartesian3.normalize(w,w),_=s[2],o.defined(_)||(_=s[2]=new i.Cartesian4),_.x=w.x,_.y=w.y,_.z=w.z,_.w=-r.Cartesian3.dot(w,e),r.Cartesian3.multiplyByScalar(a,f,w),r.Cartesian3.add(m,w,w),r.Cartesian3.subtract(w,e,w),r.Cartesian3.cross(w,c,w),r.Cartesian3.normalize(w,w),_=s[3],o.defined(_)||(_=s[3]=new i.Cartesian4),_.x=w.x,_.y=w.y,_.z=w.z,_.w=-r.Cartesian3.dot(w,e),_=s[4],o.defined(_)||(_=s[4]=new i.Cartesian4),_.x=t.x,_.y=t.y,_.z=t.z,_.w=-r.Cartesian3.dot(t,m),r.Cartesian3.negate(t,w),_=s[5],o.defined(_)||(_=s[5]=new i.Cartesian4),_.x=w.x,_.y=w.y,_.z=w.z,_.w=-r.Cartesian3.dot(w,C),this._cullingVolume},M.prototype.getPixelDimensions=function(e,t,r,i,a){if(D(this),!o.defined(e)||!o.defined(t))throw new n.DeveloperError("Both drawingBufferWidth and drawingBufferHeight are required.");if(e<=0)throw new n.DeveloperError("drawingBufferWidth must be greater than zero.");if(t<=0)throw new n.DeveloperError("drawingBufferHeight must be greater than zero.");if(!o.defined(r))throw new n.DeveloperError("distance is required.");if(!o.defined(i))throw new n.DeveloperError("pixelRatio is required");if(i<=0)throw new n.DeveloperError("pixelRatio must be greater than zero.");if(!o.defined(a))throw new n.DeveloperError("A result object is required.");const s=1/this.near;let f=this.top*s;const u=2*i*r*f/t;f=this.right*s;const d=2*i*r*f/e;return a.x=d,a.y=u,a},M.prototype.clone=function(e){return o.defined(e)||(e=new M),e.right=this.right,e.left=this.left,e.top=this.top,e.bottom=this.bottom,e.near=this.near,e.far=this.far,e._left=void 0,e._right=void 0,e._top=void 0,e._bottom=void 0,e._near=void 0,e._far=void 0,e},M.prototype.equals=function(e){return o.defined(e)&&e instanceof M&&this.right===e.right&&this.left===e.left&&this.top===e.top&&this.bottom===e.bottom&&this.near===e.near&&this.far===e.far},M.prototype.equalsEpsilon=function(e,t,r){return e===this||o.defined(e)&&e instanceof M&&u.CesiumMath.equalsEpsilon(this.right,e.right,t,r)&&u.CesiumMath.equalsEpsilon(this.left,e.left,t,r)&&u.CesiumMath.equalsEpsilon(this.top,e.top,t,r)&&u.CesiumMath.equalsEpsilon(this.bottom,e.bottom,t,r)&&u.CesiumMath.equalsEpsilon(this.near,e.near,t,r)&&u.CesiumMath.equalsEpsilon(this.far,e.far,t,r)},R.packedLength=6,R.pack=function(e,t,r){return n.Check.typeOf.object("value",e),n.Check.defined("array",t),r=o.defaultValue(r,0),t[r++]=e.fov,t[r++]=e.aspectRatio,t[r++]=e.near,t[r++]=e.far,t[r++]=e.xOffset,t[r]=e.yOffset,t},R.unpack=function(e,t,r){return n.Check.defined("array",e),t=o.defaultValue(t,0),o.defined(r)||(r=new R),r.fov=e[t++],r.aspectRatio=e[t++],r.near=e[t++],r.far=e[t++],r.xOffset=e[t++],r.yOffset=e[t],r},Object.defineProperties(R.prototype,{projectionMatrix:{get:function(){return k(this),this._offCenterFrustum.projectionMatrix}},infiniteProjectionMatrix:{get:function(){return k(this),this._offCenterFrustum.infiniteProjectionMatrix}},fovy:{get:function(){return k(this),this._fovy}},sseDenominator:{get:function(){return k(this),this._sseDenominator}},offCenterFrustum:{get:function(){return k(this),this._offCenterFrustum}}}),R.prototype.computeCullingVolume=function(e,t,r){return k(this),this._offCenterFrustum.computeCullingVolume(e,t,r)},R.prototype.getPixelDimensions=function(e,t,r,i,n){return k(this),this._offCenterFrustum.getPixelDimensions(e,t,r,i,n)},R.prototype.clone=function(e){return o.defined(e)||(e=new R),e.aspectRatio=this.aspectRatio,e.fov=this.fov,e.near=this.near,e.far=this.far,e._aspectRatio=void 0,e._fov=void 0,e._near=void 0,e._far=void 0,this._offCenterFrustum.clone(e._offCenterFrustum),e},R.prototype.equals=function(e){return!!(o.defined(e)&&e instanceof R)&&(k(this),k(e),this.fov===e.fov&&this.aspectRatio===e.aspectRatio&&this._offCenterFrustum.equals(e._offCenterFrustum))},R.prototype.equalsEpsilon=function(e,t,r){return!!(o.defined(e)&&e instanceof R)&&(k(this),k(e),u.CesiumMath.equalsEpsilon(this.fov,e.fov,t,r)&&u.CesiumMath.equalsEpsilon(this.aspectRatio,e.aspectRatio,t,r)&&this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum,t,r))},P.pack=function(e,i,a){n.Check.typeOf.object("value",e),n.Check.defined("array",i),a=o.defaultValue(a,0);const s=e._frustumType,f=e._frustum;return i[a++]=s,0===s?(R.pack(f,i,a),a+=R.packedLength):(b.pack(f,i,a),a+=b.packedLength),r.Cartesian3.pack(e._origin,i,a),a+=r.Cartesian3.packedLength,t.Quaternion.pack(e._orientation,i,a),a+=t.Quaternion.packedLength,l.VertexFormat.pack(e._vertexFormat,i,a),i[a+=l.VertexFormat.packedLength]=e._drawNearPlane?1:0,i};const q=new R,S=new b,T=new t.Quaternion,A=new r.Cartesian3,I=new l.VertexFormat;function B(e,t,r,i,n,a,s,f){const u=e/3*2;for(let n=0;n<4;++n)o.defined(t)&&(t[e]=a.x,t[e+1]=a.y,t[e+2]=a.z),o.defined(r)&&(r[e]=s.x,r[e+1]=s.y,r[e+2]=s.z),o.defined(i)&&(i[e]=f.x,i[e+1]=f.y,i[e+2]=f.z),e+=3;n[u]=0,n[u+1]=0,n[u+2]=1,n[u+3]=0,n[u+4]=1,n[u+5]=1,n[u+6]=0,n[u+7]=1}P.unpack=function(e,i,a){n.Check.defined("array",e),i=o.defaultValue(i,0);const s=e[i++];let f;0===s?(f=R.unpack(e,i,q),i+=R.packedLength):(f=b.unpack(e,i,S),i+=b.packedLength);const u=r.Cartesian3.unpack(e,i,A);i+=r.Cartesian3.packedLength;const d=t.Quaternion.unpack(e,i,T);i+=t.Quaternion.packedLength;const h=l.VertexFormat.unpack(e,i,I),p=1===e[i+=l.VertexFormat.packedLength];if(!o.defined(a))return new P({frustum:f,origin:u,orientation:d,vertexFormat:h,_drawNearPlane:p});const c=s===a._frustumType?a._frustum:void 0;return a._frustum=f.clone(c),a._frustumType=s,a._origin=r.Cartesian3.clone(u,a._origin),a._orientation=t.Quaternion.clone(d,a._orientation),a._vertexFormat=l.VertexFormat.clone(h,a._vertexFormat),a._drawNearPlane=p,a};const L=new r.Matrix3,N=new i.Matrix4,j=new i.Matrix4,G=new r.Cartesian3,U=new r.Cartesian3,Q=new r.Cartesian3,K=new r.Cartesian3,W=new r.Cartesian3,Y=new r.Cartesian3,H=new Array(3),J=new Array(4);J[0]=new i.Cartesian4(-1,-1,1,1),J[1]=new i.Cartesian4(1,-1,1,1),J[2]=new i.Cartesian4(1,1,1,1),J[3]=new i.Cartesian4(-1,1,1,1);const X=new Array(4);for(let e=0;e<4;++e)X[e]=new i.Cartesian4;P._computeNearFarPlanes=function(e,t,n,a,s,f,u,d){const l=r.Matrix3.fromQuaternion(t,L);let h=o.defaultValue(f,G),p=o.defaultValue(u,U),c=o.defaultValue(d,Q);h=r.Matrix3.getColumn(l,0,h),p=r.Matrix3.getColumn(l,1,p),c=r.Matrix3.getColumn(l,2,c),r.Cartesian3.normalize(h,h),r.Cartesian3.normalize(p,p),r.Cartesian3.normalize(c,c),r.Cartesian3.negate(h,h);const m=i.Matrix4.computeView(e,c,p,h,N);let C,w;const _=a.projectionMatrix;if(0===n){const e=i.Matrix4.multiply(_,m,j);w=i.Matrix4.inverse(e,j)}else C=i.Matrix4.inverseTransformation(m,j);o.defined(w)?(H[0]=a.near,H[1]=a.far):(H[0]=0,H[1]=a.near,H[2]=a.far);for(let t=0;t<2;++t)for(let n=0;n<4;++n){let f=i.Cartesian4.clone(J[n],X[n]);if(o.defined(w)){f=i.Matrix4.multiplyByVector(w,f,f);const n=1/f.w;r.Cartesian3.multiplyByScalar(f,n,f),r.Cartesian3.subtract(f,e,f),r.Cartesian3.normalize(f,f);const a=r.Cartesian3.dot(c,f);r.Cartesian3.multiplyByScalar(f,H[t]/a,f),r.Cartesian3.add(f,e,f)}else{const e=a.offCenterFrustum;o.defined(e)&&(a=e);const r=H[t],n=H[t+1];f.x=.5*(f.x*(a.right-a.left)+a.left+a.right),f.y=.5*(f.y*(a.top-a.bottom)+a.bottom+a.top),f.z=.5*(f.z*(r-n)-r-n),f.w=1,i.Matrix4.multiplyByVector(C,f,f)}s[12*t+3*n]=f.x,s[12*t+3*n+1]=f.y,s[12*t+3*n+2]=f.z}},P.createGeometry=function(e){const i=e._frustumType,n=e._frustum,u=e._origin,d=e._orientation,l=e._drawNearPlane,h=e._vertexFormat,p=l?6:5;let c=new Float64Array(72);P._computeNearFarPlanes(u,d,i,n,c);let m=24;c[m]=c[12],c[m+1]=c[13],c[m+2]=c[14],c[m+3]=c[0],c[m+4]=c[1],c[m+5]=c[2],c[m+6]=c[9],c[m+7]=c[10],c[m+8]=c[11],c[m+9]=c[21],c[m+10]=c[22],c[m+11]=c[23],m+=12,c[m]=c[15],c[m+1]=c[16],c[m+2]=c[17],c[m+3]=c[3],c[m+4]=c[4],c[m+5]=c[5],c[m+6]=c[0],c[m+7]=c[1],c[m+8]=c[2],c[m+9]=c[12],c[m+10]=c[13],c[m+11]=c[14],m+=12,c[m]=c[3],c[m+1]=c[4],c[m+2]=c[5],c[m+3]=c[15],c[m+4]=c[16],c[m+5]=c[17],c[m+6]=c[18],c[m+7]=c[19],c[m+8]=c[20],c[m+9]=c[6],c[m+10]=c[7],c[m+11]=c[8],m+=12,c[m]=c[6],c[m+1]=c[7],c[m+2]=c[8],c[m+3]=c[18],c[m+4]=c[19],c[m+5]=c[20],c[m+6]=c[21],c[m+7]=c[22],c[m+8]=c[23],c[m+9]=c[9],c[m+10]=c[10],c[m+11]=c[11],l||(c=c.subarray(12));const C=new f.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})});if(o.defined(h.normal)||o.defined(h.tangent)||o.defined(h.bitangent)||o.defined(h.st)){const e=o.defined(h.normal)?new Float32Array(12*p):void 0,t=o.defined(h.tangent)?new Float32Array(12*p):void 0,i=o.defined(h.bitangent)?new Float32Array(12*p):void 0,n=o.defined(h.st)?new Float32Array(8*p):void 0,f=G,u=U,d=Q,c=r.Cartesian3.negate(f,K),w=r.Cartesian3.negate(u,W),_=r.Cartesian3.negate(d,Y);m=0,l&&(B(m,e,t,i,n,_,f,u),m+=12),B(m,e,t,i,n,d,c,u),m+=12,B(m,e,t,i,n,c,_,u),m+=12,B(m,e,t,i,n,w,_,c),m+=12,B(m,e,t,i,n,f,d,u),m+=12,B(m,e,t,i,n,u,d,c),o.defined(e)&&(C.normal=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e})),o.defined(t)&&(C.tangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t})),o.defined(i)&&(C.bitangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:i})),o.defined(n)&&(C.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:n}))}const w=new Uint16Array(6*p);for(let e=0;e<p;++e){const t=6*e,r=4*e;w[t]=r,w[t+1]=r+1,w[t+2]=r+2,w[t+3]=r,w[t+4]=r+2,w[t+5]=r+3}return new s.Geometry({attributes:C,indices:w,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:t.BoundingSphere.fromVertices(c)})},e.FrustumGeometry=P,e.OrthographicFrustum=b,e.PerspectiveFrustum=R}));