/*! For license information please see createPolygonGeometry.js.LICENSE.txt */
import{BoundingRectangle_default}from"./chunk-KUB2HQXR.js";import{PolygonGeometryLibrary_default}from"./chunk-VODWDCX6.js";import{ArcType_default}from"./chunk-235MRXLH.js";import{GeometryInstance_default}from"./chunk-GTEXWEAP.js";import{GeometryPipeline_default}from"./chunk-36ESDRIZ.js";import"./chunk-I6TVJ6T7.js";import"./chunk-VOAZN4IP.js";import{oneTimeWarning_default}from"./chunk-7ONRI7T4.js";import{EllipsoidGeodesic_default}from"./chunk-LSGUCCKJ.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import{EllipsoidTangentPlane_default}from"./chunk-MOLGJDJV.js";import"./chunk-FGUP2QEP.js";import{PolygonPipeline_default,WindingOrder_default}from"./chunk-ZVUAJKAL.js";import"./chunk-DTNN3ODA.js";import"./chunk-6PWSSCRA.js";import{IntersectionTests_default,Ray_default}from"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default,Quaternion_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Cartesian2_default,Rectangle_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";function deprecationWarning(t,e){if(!defined_default(t)||!defined_default(e))throw new DeveloperError_default("identifier and message are required.");oneTimeWarning_default(t,e)}var deprecationWarning_default=deprecationWarning;function Stereographic(t,e){this.position=t,defined_default(this.position)||(this.position=new Cartesian2_default),this.tangentPlane=e,defined_default(this.tangentPlane)||(this.tangentPlane=Stereographic.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(Stereographic.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){const t=Cartesian2_default.magnitude(this.position),e=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(Math_default.PI_OVER_TWO-2*Math.atan2(t,e))}},longitude:{get:function(){let t=Math_default.PI_OVER_TWO+Math.atan2(this.y,this.x);return t>Math.PI&&(t-=Math_default.TWO_PI),t}}});var scratchCartographic=new Cartographic_default,scratchCartesian=new Cartesian3_default;Stereographic.prototype.getLatitude=function(t){defined_default(t)||(t=Ellipsoid_default.WGS84),scratchCartographic.latitude=this.conformalLatitude,scratchCartographic.longitude=this.longitude,scratchCartographic.height=0;const e=this.ellipsoid.cartographicToCartesian(scratchCartographic,scratchCartesian);return t.cartesianToCartographic(e,scratchCartographic),scratchCartographic.latitude};var scratchProjectPointOntoPlaneRay=new Ray_default,scratchProjectPointOntoPlaneRayDirection=new Cartesian3_default,scratchProjectPointOntoPlaneCartesian3=new Cartesian3_default;Stereographic.fromCartesian=function(t,e){Check_default.defined("cartesian",t);const a=Math_default.signNotZero(t.z);let o=Stereographic.NORTH_POLE_TANGENT_PLANE,r=Stereographic.SOUTH_POLE;a<0&&(o=Stereographic.SOUTH_POLE_TANGENT_PLANE,r=Stereographic.NORTH_POLE);const n=scratchProjectPointOntoPlaneRay;n.origin=o.ellipsoid.scaleToGeocentricSurface(t,n.origin),n.direction=Cartesian3_default.subtract(n.origin,r,scratchProjectPointOntoPlaneRayDirection),Cartesian3_default.normalize(n.direction,n.direction);const i=IntersectionTests_default.rayPlane(n,o.plane,scratchProjectPointOntoPlaneCartesian3),l=Cartesian3_default.subtract(i,r,i),s=Cartesian3_default.dot(o.xAxis,l),u=a*Cartesian3_default.dot(o.yAxis,l);return defined_default(e)?(e.position=new Cartesian2_default(s,u),e.tangentPlane=o,e):new Stereographic(new Cartesian2_default(s,u),o)},Stereographic.fromCartesianArray=function(t,e){Check_default.defined("cartesians",t);const a=t.length;defined_default(e)?e.length=a:e=new Array(a);for(let o=0;o<a;o++)e[o]=Stereographic.fromCartesian(t[o],e[o]);return e},Stereographic.clone=function(t,e){if(defined_default(t))return defined_default(e)?(e.position=t.position,e.tangentPlane=t.tangentPlane,e):new Stereographic(t.position,t.tangentPlane)},Stereographic.HALF_UNIT_SPHERE=Object.freeze(new Ellipsoid_default(.5,.5,.5)),Stereographic.NORTH_POLE=Object.freeze(new Cartesian3_default(0,0,.5)),Stereographic.SOUTH_POLE=Object.freeze(new Cartesian3_default(0,0,-.5)),Stereographic.NORTH_POLE_TANGENT_PLANE=Object.freeze(new EllipsoidTangentPlane_default(Stereographic.NORTH_POLE,Stereographic.HALF_UNIT_SPHERE)),Stereographic.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new EllipsoidTangentPlane_default(Stereographic.SOUTH_POLE,Stereographic.HALF_UNIT_SPHERE));var Stereographic_default=Stereographic,scratchCarto1=new Cartographic_default,scratchCarto2=new Cartographic_default;function adjustPosHeightsForNormal(t,e,a,o){const r=o.cartesianToCartographic(t,scratchCarto1).height,n=o.cartesianToCartographic(e,scratchCarto2);n.height=r,o.cartographicToCartesian(n,e);const i=o.cartesianToCartographic(a,scratchCarto2);i.height=r-100,o.cartographicToCartesian(i,a)}var scratchBoundingRectangle=new BoundingRectangle_default,scratchPosition=new Cartesian3_default,scratchNormal=new Cartesian3_default,scratchTangent=new Cartesian3_default,scratchBitangent=new Cartesian3_default,p1Scratch=new Cartesian3_default,p2Scratch=new Cartesian3_default,scratchPerPosNormal=new Cartesian3_default,scratchPerPosTangent=new Cartesian3_default,scratchPerPosBitangent=new Cartesian3_default,appendTextureCoordinatesOrigin=new Cartesian2_default,appendTextureCoordinatesCartesian2=new Cartesian2_default,appendTextureCoordinatesCartesian3=new Cartesian3_default,appendTextureCoordinatesQuaternion=new Quaternion_default,appendTextureCoordinatesMatrix3=new Matrix3_default,tangentMatrixScratch=new Matrix3_default;function computeAttributes(t){const e=t.vertexFormat,a=t.geometry,o=t.shadowVolume,r=a.attributes.position.values,n=defined_default(a.attributes.st)?a.attributes.st.values:void 0;let i=r.length;const l=t.wall,s=t.top||l,u=t.bottom||l;if(e.st||e.normal||e.tangent||e.bitangent||o){const d=t.boundingRectangle,c=t.rotationAxis,f=t.projectTo2d,h=t.ellipsoid,_=t.stRotation,p=t.perPositionHeight,g=appendTextureCoordinatesOrigin;g.x=d.x,g.y=d.y;const m=e.st?new Float32Array(i/3*2):void 0;let y;e.normal&&(y=p&&s&&!l?a.attributes.normal.values:new Float32Array(i));const P=e.tangent?new Float32Array(i):void 0,C=e.bitangent?new Float32Array(i):void 0,T=o?new Float32Array(i):void 0;let I=0,E=0,O=scratchNormal,w=scratchTangent,b=scratchBitangent,x=!0,A=appendTextureCoordinatesMatrix3,G=tangentMatrixScratch;if(0!==_){let t=Quaternion_default.fromAxisAngle(c,_,appendTextureCoordinatesQuaternion);A=Matrix3_default.fromQuaternion(t,A),t=Quaternion_default.fromAxisAngle(c,-_,appendTextureCoordinatesQuaternion),G=Matrix3_default.fromQuaternion(t,G)}else A=Matrix3_default.clone(Matrix3_default.IDENTITY,A),G=Matrix3_default.clone(Matrix3_default.IDENTITY,G);let N=0,v=0;s&&u&&(N=i/2,v=i/3,i/=2);for(let a=0;a<i;a+=3){const c=Cartesian3_default.fromArray(r,a,appendTextureCoordinatesCartesian3);if(e.st&&!defined_default(n)){let t=Matrix3_default.multiplyByVector(A,c,scratchPosition);t=h.scaleToGeodeticSurface(t,t);const e=f(t,appendTextureCoordinatesCartesian2);Cartesian2_default.subtract(e,g,e);const a=Math_default.clamp(e.x/d.width,0,1),o=Math_default.clamp(e.y/d.height,0,1);u&&(m[I+v]=a,m[I+1+v]=o),s&&(m[I]=a,m[I+1]=o),I+=2}if(e.normal||e.tangent||e.bitangent||o){const n=E+1,d=E+2;if(l){if(a+3<i){const t=Cartesian3_default.fromArray(r,a+3,p1Scratch);if(x){const e=Cartesian3_default.fromArray(r,a+i,p2Scratch);p&&adjustPosHeightsForNormal(c,t,e,h),Cartesian3_default.subtract(t,c,t),Cartesian3_default.subtract(e,c,e),O=Cartesian3_default.normalize(Cartesian3_default.cross(e,t,O),O),x=!1}Cartesian3_default.equalsEpsilon(t,c,Math_default.EPSILON10)&&(x=!0)}(e.tangent||e.bitangent)&&(b=h.geodeticSurfaceNormal(c,b),e.tangent&&(w=Cartesian3_default.normalize(Cartesian3_default.cross(b,O,w),w)))}else O=h.geodeticSurfaceNormal(c,O),(e.tangent||e.bitangent)&&(p&&(scratchPerPosNormal=Cartesian3_default.fromArray(y,E,scratchPerPosNormal),scratchPerPosTangent=Cartesian3_default.cross(Cartesian3_default.UNIT_Z,scratchPerPosNormal,scratchPerPosTangent),scratchPerPosTangent=Cartesian3_default.normalize(Matrix3_default.multiplyByVector(G,scratchPerPosTangent,scratchPerPosTangent),scratchPerPosTangent),e.bitangent&&(scratchPerPosBitangent=Cartesian3_default.normalize(Cartesian3_default.cross(scratchPerPosNormal,scratchPerPosTangent,scratchPerPosBitangent),scratchPerPosBitangent))),w=Cartesian3_default.cross(Cartesian3_default.UNIT_Z,O,w),w=Cartesian3_default.normalize(Matrix3_default.multiplyByVector(G,w,w),w),e.bitangent&&(b=Cartesian3_default.normalize(Cartesian3_default.cross(O,w,b),b)));e.normal&&(t.wall?(y[E+N]=O.x,y[n+N]=O.y,y[d+N]=O.z):u&&(y[E+N]=-O.x,y[n+N]=-O.y,y[d+N]=-O.z),(s&&!p||l)&&(y[E]=O.x,y[n]=O.y,y[d]=O.z)),o&&(l&&(O=h.geodeticSurfaceNormal(c,O)),T[E+N]=-O.x,T[n+N]=-O.y,T[d+N]=-O.z),e.tangent&&(t.wall?(P[E+N]=w.x,P[n+N]=w.y,P[d+N]=w.z):u&&(P[E+N]=-w.x,P[n+N]=-w.y,P[d+N]=-w.z),s&&(p?(P[E]=scratchPerPosTangent.x,P[n]=scratchPerPosTangent.y,P[d]=scratchPerPosTangent.z):(P[E]=w.x,P[n]=w.y,P[d]=w.z))),e.bitangent&&(u&&(C[E+N]=b.x,C[n+N]=b.y,C[d+N]=b.z),s&&(p?(C[E]=scratchPerPosBitangent.x,C[n]=scratchPerPosBitangent.y,C[d]=scratchPerPosBitangent.z):(C[E]=b.x,C[n]=b.y,C[d]=b.z))),E+=3}}e.st&&!defined_default(n)&&(a.attributes.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:m})),e.normal&&(a.attributes.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:y})),e.tangent&&(a.attributes.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:P})),e.bitangent&&(a.attributes.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:C})),o&&(a.attributes.extrudeDirection=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:T}))}if(t.extrude&&defined_default(t.offsetAttribute)){const e=r.length/3;let o=new Uint8Array(e);if(t.offsetAttribute===GeometryOffsetAttribute_default.TOP)s&&u||l?o=o.fill(1,0,e/2):s&&(o=o.fill(1));else{const e=t.offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1;o=o.fill(e)}a.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}return a}var startCartographicScratch=new Cartographic_default,endCartographicScratch=new Cartographic_default,idlCross={westOverIDL:0,eastOverIDL:0},ellipsoidGeodesic=new EllipsoidGeodesic_default;function computeRectangle(t,e,a,o,r){if(r=defaultValue_default(r,new Rectangle_default),!defined_default(t)||t.length<3)return r.west=0,r.north=0,r.south=0,r.east=0,r;if(a===ArcType_default.RHUMB)return Rectangle_default.fromCartesianArray(t,e,r);ellipsoidGeodesic.ellipsoid.equals(e)||(ellipsoidGeodesic=new EllipsoidGeodesic_default(void 0,void 0,e)),r.west=Number.POSITIVE_INFINITY,r.east=Number.NEGATIVE_INFINITY,r.south=Number.POSITIVE_INFINITY,r.north=Number.NEGATIVE_INFINITY,idlCross.westOverIDL=Number.POSITIVE_INFINITY,idlCross.eastOverIDL=Number.NEGATIVE_INFINITY;const n=1/Math_default.chordLength(o,e.maximumRadius),i=t.length;let l,s=e.cartesianToCartographic(t[0],endCartographicScratch),u=startCartographicScratch;for(let a=1;a<i;a++)l=u,u=s,s=e.cartesianToCartographic(t[a],l),ellipsoidGeodesic.setEndPoints(u,s),interpolateAndGrowRectangle(ellipsoidGeodesic,n,r,idlCross);return l=u,u=s,s=e.cartesianToCartographic(t[0],l),ellipsoidGeodesic.setEndPoints(u,s),interpolateAndGrowRectangle(ellipsoidGeodesic,n,r,idlCross),r.east-r.west>idlCross.eastOverIDL-idlCross.westOverIDL&&(r.west=idlCross.westOverIDL,r.east=idlCross.eastOverIDL,r.east>Math_default.PI&&(r.east=r.east-Math_default.TWO_PI),r.west>Math_default.PI&&(r.west=r.west-Math_default.TWO_PI)),r}var interpolatedCartographicScratch=new Cartographic_default;function interpolateAndGrowRectangle(t,e,a,o){const r=t.surfaceDistance,n=Math.ceil(r*e),i=n>0?r/(n-1):Number.POSITIVE_INFINITY;let l=0;for(let e=0;e<n;e++){const e=t.interpolateUsingSurfaceDistance(l,interpolatedCartographicScratch);l+=i;const r=e.longitude,n=e.latitude;a.west=Math.min(a.west,r),a.east=Math.max(a.east,r),a.south=Math.min(a.south,n),a.north=Math.max(a.north,n);const s=r>=0?r:r+Math_default.TWO_PI;o.westOverIDL=Math.min(o.westOverIDL,s),o.eastOverIDL=Math.max(o.eastOverIDL,s)}}var createGeometryFromPositionsExtrudedPositions=[];function createGeometryFromPositionsExtruded(t,e,a,o,r,n,i,l,s,u){const d={walls:[]};let c;if(i||l){const r=PolygonGeometryLibrary_default.createGeometryFromPositions(t,e,a,o,n,s,u),f=r.attributes.position.values,h=r.indices;let _,p;if(i&&l){const t=f.concat(f);_=t.length/3,p=IndexDatatype_default.createTypedArray(_,2*h.length),p.set(h);const e=h.length,o=_/2;for(c=0;c<e;c+=3){const t=p[c]+o,a=p[c+1]+o,r=p[c+2]+o;p[c+e]=r,p[c+1+e]=a,p[c+2+e]=t}if(r.attributes.position.values=t,n&&s.normal){const e=r.attributes.normal.values;r.attributes.normal.values=new Float32Array(t.length),r.attributes.normal.values.set(e)}if(s.st&&defined_default(a)){const t=r.attributes.st.values;r.attributes.st.values=new Float32Array(2*_),r.attributes.st.values=t.concat(t)}r.indices=p}else if(l){for(_=f.length/3,p=IndexDatatype_default.createTypedArray(_,h.length),c=0;c<h.length;c+=3)p[c]=h[c+2],p[c+1]=h[c+1],p[c+2]=h[c];r.indices=p}d.topAndBottom=new GeometryInstance_default({geometry:r})}let f=r.outerRing;const h=EllipsoidTangentPlane_default.fromPoints(f,t);let _=h.projectPointsOntoPlane(f,createGeometryFromPositionsExtrudedPositions),p=PolygonPipeline_default.computeWindingOrder2D(_);p===WindingOrder_default.CLOCKWISE&&(f=f.slice().reverse());let g=PolygonGeometryLibrary_default.computeWallGeometry(f,a,t,o,n,u);d.walls.push(new GeometryInstance_default({geometry:g}));const m=r.holes;for(c=0;c<m.length;c++){let e=m[c];_=h.projectPointsOntoPlane(e,createGeometryFromPositionsExtrudedPositions),p=PolygonPipeline_default.computeWindingOrder2D(_),p===WindingOrder_default.COUNTER_CLOCKWISE&&(e=e.slice().reverse()),g=PolygonGeometryLibrary_default.computeWallGeometry(e,a,t,o,n,u),d.walls.push(new GeometryInstance_default({geometry:g}))}return d}function PolygonGeometry(t){if(Check_default.typeOf.object("options",t),Check_default.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),defined_default(t.perPositionHeight)&&t.perPositionHeight&&defined_default(t.height))throw new DeveloperError_default("Cannot use both options.perPositionHeight and options.height");if(defined_default(t.arcType)&&t.arcType!==ArcType_default.GEODESIC&&t.arcType!==ArcType_default.RHUMB)throw new DeveloperError_default("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const e=t.polygonHierarchy,a=defaultValue_default(t.vertexFormat,VertexFormat_default.DEFAULT),o=defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84),r=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),n=defaultValue_default(t.stRotation,0),i=t.textureCoordinates,l=defaultValue_default(t.perPositionHeight,!1),s=l&&defined_default(t.extrudedHeight);let u=defaultValue_default(t.height,0),d=defaultValue_default(t.extrudedHeight,u);if(!s){const t=Math.max(u,d);d=Math.min(u,d),u=t}this._vertexFormat=VertexFormat_default.clone(a),this._ellipsoid=Ellipsoid_default.clone(o),this._granularity=r,this._stRotation=n,this._height=u,this._extrudedHeight=d,this._closeTop=defaultValue_default(t.closeTop,!0),this._closeBottom=defaultValue_default(t.closeBottom,!0),this._polygonHierarchy=e,this._perPositionHeight=l,this._perPositionHeightExtrude=s,this._shadowVolume=defaultValue_default(t.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=defaultValue_default(t.arcType,ArcType_default.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=i,this.packedLength=PolygonGeometryLibrary_default.computeHierarchyPackedLength(e,Cartesian3_default)+Ellipsoid_default.packedLength+VertexFormat_default.packedLength+(i?PolygonGeometryLibrary_default.computeHierarchyPackedLength(i,Cartesian2_default):1)+12}PolygonGeometry.fromPositions=function(t){return t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT),Check_default.defined("options.positions",t.positions),new PolygonGeometry({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},PolygonGeometry.pack=function(t,e,a){return Check_default.typeOf.object("value",t),Check_default.defined("array",e),a=defaultValue_default(a,0),a=PolygonGeometryLibrary_default.packPolygonHierarchy(t._polygonHierarchy,e,a,Cartesian3_default),Ellipsoid_default.pack(t._ellipsoid,e,a),a+=Ellipsoid_default.packedLength,VertexFormat_default.pack(t._vertexFormat,e,a),a+=VertexFormat_default.packedLength,e[a++]=t._height,e[a++]=t._extrudedHeight,e[a++]=t._granularity,e[a++]=t._stRotation,e[a++]=t._perPositionHeightExtrude?1:0,e[a++]=t._perPositionHeight?1:0,e[a++]=t._closeTop?1:0,e[a++]=t._closeBottom?1:0,e[a++]=t._shadowVolume?1:0,e[a++]=defaultValue_default(t._offsetAttribute,-1),e[a++]=t._arcType,defined_default(t._textureCoordinates)?a=PolygonGeometryLibrary_default.packPolygonHierarchy(t._textureCoordinates,e,a,Cartesian2_default):e[a++]=-1,e[a++]=t.packedLength,e};var scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchVertexFormat=new VertexFormat_default,dummyOptions={polygonHierarchy:{}};PolygonGeometry.unpack=function(t,e,a){Check_default.defined("array",t),e=defaultValue_default(e,0);const o=PolygonGeometryLibrary_default.unpackPolygonHierarchy(t,e,Cartesian3_default);e=o.startingIndex,delete o.startingIndex;const r=Ellipsoid_default.unpack(t,e,scratchEllipsoid);e+=Ellipsoid_default.packedLength;const n=VertexFormat_default.unpack(t,e,scratchVertexFormat);e+=VertexFormat_default.packedLength;const i=t[e++],l=t[e++],s=t[e++],u=t[e++],d=1===t[e++],c=1===t[e++],f=1===t[e++],h=1===t[e++],_=1===t[e++],p=t[e++],g=t[e++],m=-1===t[e]?void 0:PolygonGeometryLibrary_default.unpackPolygonHierarchy(t,e,Cartesian2_default);defined_default(m)?(e=m.startingIndex,delete m.startingIndex):e++;const y=t[e++];return defined_default(a)||(a=new PolygonGeometry(dummyOptions)),a._polygonHierarchy=o,a._ellipsoid=Ellipsoid_default.clone(r,a._ellipsoid),a._vertexFormat=VertexFormat_default.clone(n,a._vertexFormat),a._height=i,a._extrudedHeight=l,a._granularity=s,a._stRotation=u,a._perPositionHeightExtrude=d,a._perPositionHeight=c,a._closeTop=f,a._closeBottom=h,a._shadowVolume=_,a._offsetAttribute=-1===p?void 0:p,a._arcType=g,a._textureCoordinates=m,a.packedLength=y,a};var scratchCartesian0=new Cartesian2_default,scratchCartesian1=new Cartesian2_default,scratchPolarClosest=new Stereographic_default;function expandRectangle(t,e,a,o,r,n){const i=t.longitude,l=i>=0?i:i+Math_default.TWO_PI;r.westOverIdl=Math.min(r.westOverIdl,l),r.eastOverIdl=Math.max(r.eastOverIdl,l),n.west=Math.min(n.west,i),n.east=Math.max(n.east,i);const s=t.getLatitude(a);let u=s;if(n.south=Math.min(n.south,s),n.north=Math.max(n.north,s),o!==ArcType_default.RHUMB){const o=Cartesian2_default.subtract(e.position,t.position,scratchCartesian0),r=Cartesian2_default.dot(e.position,o)/Cartesian2_default.dot(o,o);if(r>0&&r<1){const t=Cartesian2_default.add(e.position,Cartesian2_default.multiplyByScalar(o,-r,o),scratchCartesian1),i=Stereographic_default.clone(e,scratchPolarClosest);i.position=t;const l=i.getLatitude(a);n.south=Math.min(n.south,l),n.north=Math.max(n.north,l),Math.abs(s)>Math.abs(l)&&(u=l)}}const d=e.x*t.y-t.x*e.y;let c=Math.sign(d);0!==c&&(c*=Cartesian2_default.angleBetween(e.position,t.position)),u>=0&&(r.northAngle+=c),u<=0&&(r.southAngle+=c)}var scratchPolar=new Stereographic_default,scratchPolarPrevious=new Stereographic_default,polygon={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};PolygonGeometry.computeRectangleFromPositions=function(t,e,a,o){if(Check_default.defined("positions",t),defined_default(o)||(o=new Rectangle_default),t.length<3)return o;o.west=Number.POSITIVE_INFINITY,o.east=Number.NEGATIVE_INFINITY,o.south=Number.POSITIVE_INFINITY,o.north=Number.NEGATIVE_INFINITY,polygon.northAngle=0,polygon.southAngle=0,polygon.westOverIdl=Number.POSITIVE_INFINITY,polygon.eastOverIdl=Number.NEGATIVE_INFINITY;const r=t.length;let n=Stereographic_default.fromCartesian(t[0],scratchPolarPrevious);for(let i=1;i<r;i++){const r=Stereographic_default.fromCartesian(t[i],scratchPolar);expandRectangle(r,n,e,a,polygon,o),n=Stereographic_default.clone(r,n)}return expandRectangle(Stereographic_default.fromCartesian(t[0],scratchPolar),n,e,a,polygon,o),o.east-o.west>polygon.eastOverIdl-polygon.westOverIdl&&(o.west=polygon.westOverIdl,o.east=polygon.eastOverIdl,o.east>Math_default.PI&&(o.east=o.east-Math_default.TWO_PI),o.west>Math_default.PI&&(o.west=o.west-Math_default.TWO_PI)),Math_default.equalsEpsilon(Math.abs(polygon.northAngle),Math_default.TWO_PI,Math_default.EPSILON10)&&(o.north=Math_default.PI_OVER_TWO,o.east=Math_default.PI,o.west=-Math_default.PI),Math_default.equalsEpsilon(Math.abs(polygon.southAngle),Math_default.TWO_PI,Math_default.EPSILON10)&&(o.south=-Math_default.PI_OVER_TWO,o.east=Math_default.PI,o.west=-Math_default.PI),o},PolygonGeometry.computeRectangle=function(t,e){Check_default.typeOf.object("options",t),Check_default.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),deprecationWarning_default("PolygonGeometry.computeRectangle","PolygonGeometry.computeRectangle was deprecated in CesiumJS 1.110.  It will be removed in CesiumJS 1.112. Use PolygonGeometry.computeRectangleFromPositions instead.");const a=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),o=defaultValue_default(t.arcType,ArcType_default.GEODESIC);if(o!==ArcType_default.GEODESIC&&o!==ArcType_default.RHUMB)throw new DeveloperError_default("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const r=t.polygonHierarchy,n=defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84);return computeRectangle(r.positions,n,o,a,e)};var scratchPolarForPlane=new Stereographic_default;function getTangentPlane(t,e,a){return t.height>=Math_default.PI||t.width>=Math_default.PI?Stereographic_default.fromCartesian(e[0],scratchPolarForPlane).tangentPlane:EllipsoidTangentPlane_default.fromPoints(e,a)}var scratchCartographicCyllindrical=new Cartographic_default;function createProjectTo2d(t,e,a){return(o,r)=>{if(t.height>=Math_default.PI||t.width>=Math_default.PI){if(t.south<0&&t.north>0){defined_default(r)||(r=[]);for(let t=0;t<o.length;++t){const e=a.cartesianToCartographic(o[t],scratchCartographicCyllindrical);r[t]=new Cartesian2_default(e.longitude/Math_default.PI,e.latitude/Math_default.PI_OVER_TWO)}return r.length=o.length,r}return Stereographic_default.fromCartesianArray(o,r)}return EllipsoidTangentPlane_default.fromPoints(e,a).projectPointsOntoPlane(o,r)}}function createProjectPositionTo2d(t,e,a){if(t.height>=Math_default.PI||t.width>=Math_default.PI)return(e,o)=>{if(t.south<0&&t.north>0){const t=a.cartesianToCartographic(e,scratchCartographicCyllindrical);return defined_default(o)||(o=new Cartesian2_default),o.x=t.longitude/Math_default.PI,o.y=t.latitude/Math_default.PI_OVER_TWO,o}return Stereographic_default.fromCartesian(e,o)};const o=EllipsoidTangentPlane_default.fromPoints(e,a);return(t,e)=>o.projectPointsOntoPlane(t,e)}function createSplitPolygons(t,e,a,o){return(r,n)=>!o&&(t.height>=Math_default.PI_OVER_TWO||t.width>=2*Math_default.PI_OVER_THREE)?PolygonGeometryLibrary_default.splitPolygonsOnEquator(r,e,a,n):r}function computeBoundingRectangle(t,e,a,o){if(e.height>=Math_default.PI||e.width>=Math_default.PI)return BoundingRectangle_default.fromRectangle(e,void 0,scratchBoundingRectangle);const r=t,n=EllipsoidTangentPlane_default.fromPoints(r,a);return PolygonGeometryLibrary_default.computeBoundingRectangle(n.plane.normal,n.projectPointOntoPlane.bind(n),r,o,scratchBoundingRectangle)}function textureCoordinateRotationPoints(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const a=t._ellipsoid,o=t._polygonHierarchy.positions,r=t.rectangle;return Geometry_default._textureCoordinateRotationPoints(o,e,a,r)}PolygonGeometry.createGeometry=function(t){const e=t._vertexFormat,a=t._ellipsoid,o=t._granularity,r=t._stRotation,n=t._polygonHierarchy,i=t._perPositionHeight,l=t._closeTop,s=t._closeBottom,u=t._arcType,d=t._textureCoordinates,c=defined_default(d),f=n.positions;if(f.length<3)return;const h=t.rectangle,_=PolygonGeometryLibrary_default.polygonsFromHierarchy(n,c,createProjectTo2d(h,f,a),!i,a,createSplitPolygons(h,a,u,i)),p=_.hierarchy,g=_.polygons,m=c?PolygonGeometryLibrary_default.polygonsFromHierarchy(d,!0,(function(t){return t}),!1,a).polygons:void 0;if(0===p.length)return;const y=p[0].outerRing,P=computeBoundingRectangle(y,h,a,r),C=[],T=t._height,I=t._extrudedHeight,E=t._perPositionHeightExtrude||!Math_default.equalsEpsilon(T,I,0,Math_default.EPSILON2),O={perPositionHeight:i,vertexFormat:e,geometry:void 0,rotationAxis:getTangentPlane(h,y,a).plane.normal,projectTo2d:createProjectPositionTo2d(h,y,a),boundingRectangle:P,ellipsoid:a,stRotation:r,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:u};let w;if(E)for(O.extrude=!0,O.top=l,O.bottom=s,O.shadowVolume=t._shadowVolume,O.offsetAttribute=t._offsetAttribute,w=0;w<g.length;w++){const t=createGeometryFromPositionsExtruded(a,g[w],c?m[w]:void 0,o,p[w],i,l,s,e,u);let r;l&&s?(r=t.topAndBottom,O.geometry=PolygonGeometryLibrary_default.scaleToGeodeticHeightExtruded(r.geometry,T,I,a,i)):l?(r=t.topAndBottom,r.geometry.attributes.position.values=PolygonPipeline_default.scaleToGeodeticHeight(r.geometry.attributes.position.values,T,a,!i),O.geometry=r.geometry):s&&(r=t.topAndBottom,r.geometry.attributes.position.values=PolygonPipeline_default.scaleToGeodeticHeight(r.geometry.attributes.position.values,I,a,!0),O.geometry=r.geometry),(l||s)&&(O.wall=!1,r.geometry=computeAttributes(O),C.push(r));const n=t.walls;O.wall=!0;for(let t=0;t<n.length;t++){const e=n[t];O.geometry=PolygonGeometryLibrary_default.scaleToGeodeticHeightExtruded(e.geometry,T,I,a,i),e.geometry=computeAttributes(O),C.push(e)}}else for(w=0;w<g.length;w++){const r=new GeometryInstance_default({geometry:PolygonGeometryLibrary_default.createGeometryFromPositions(a,g[w],c?m[w]:void 0,o,i,e,u)});if(r.geometry.attributes.position.values=PolygonPipeline_default.scaleToGeodeticHeight(r.geometry.attributes.position.values,T,a,!i),O.geometry=r.geometry,r.geometry=computeAttributes(O),defined_default(t._offsetAttribute)){const e=r.geometry.attributes.position.values.length,a=t._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,o=new Uint8Array(e/3).fill(a);r.geometry.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}C.push(r)}const b=GeometryPipeline_default.combineInstances(C)[0];b.attributes.position.values=new Float64Array(b.attributes.position.values),b.indices=IndexDatatype_default.createTypedArray(b.attributes.position.values.length/3,b.indices);const x=b.attributes,A=BoundingSphere_default.fromVertices(x.position.values);return e.position||delete x.position,new Geometry_default({attributes:x,indices:b.indices,primitiveType:b.primitiveType,boundingSphere:A,offsetAttribute:t._offsetAttribute})},PolygonGeometry.createShadowVolume=function(t,e,a){const o=t._granularity,r=t._ellipsoid,n=e(o,r),i=a(o,r);return new PolygonGeometry({polygonHierarchy:t._polygonHierarchy,ellipsoid:r,stRotation:t._stRotation,granularity:o,perPositionHeight:!1,extrudedHeight:n,height:i,vertexFormat:VertexFormat_default.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(PolygonGeometry.prototype,{rectangle:{get:function(){if(!defined_default(this._rectangle)){const t=this._polygonHierarchy.positions;this._rectangle=PolygonGeometry.computeRectangleFromPositions(t,this._ellipsoid,this._arcType)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return defined_default(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=textureCoordinateRotationPoints(this)),this._textureCoordinateRotationPoints}}});var PolygonGeometry_default=PolygonGeometry;function createPolygonGeometry(t,e){return defined_default(e)&&(t=PolygonGeometry_default.unpack(t,e)),t._ellipsoid=Ellipsoid_default.clone(t._ellipsoid),PolygonGeometry_default.createGeometry(t)}var createPolygonGeometry_default=createPolygonGeometry;export{createPolygonGeometry_default as default};