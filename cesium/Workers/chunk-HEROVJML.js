/*! For license information please see chunk-HEROVJML.js.LICENSE.txt */
import{Interval_default}from"./chunk-D4YHO4NZ.js";import{Cartesian3_default,Cartographic_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var QuadraticRealPolynomial={};function addWithCancellationCheck(e,t,a){const r=e+t;return Math_default.sign(e)!==Math_default.sign(t)&&Math.abs(r/Math.max(Math.abs(e),Math.abs(t)))<a?0:r}QuadraticRealPolynomial.computeDiscriminant=function(e,t,a){if("number"!=typeof e)throw new DeveloperError_default("a is a required number.");if("number"!=typeof t)throw new DeveloperError_default("b is a required number.");if("number"!=typeof a)throw new DeveloperError_default("c is a required number.");return t*t-4*e*a},QuadraticRealPolynomial.computeRealRoots=function(e,t,a){if("number"!=typeof e)throw new DeveloperError_default("a is a required number.");if("number"!=typeof t)throw new DeveloperError_default("b is a required number.");if("number"!=typeof a)throw new DeveloperError_default("c is a required number.");let r;if(0===e)return 0===t?[]:[-a/t];if(0===t){if(0===a)return[0,0];const t=Math.abs(a),n=Math.abs(e);if(t<n&&t/n<Math_default.EPSILON14)return[0,0];if(t>n&&n/t<Math_default.EPSILON14)return[];if(r=-a/e,r<0)return[];const i=Math.sqrt(r);return[-i,i]}if(0===a)return r=-t/e,r<0?[r,0]:[0,r];const n=addWithCancellationCheck(t*t,-4*e*a,Math_default.EPSILON14);if(n<0)return[];const i=-.5*addWithCancellationCheck(t,Math_default.sign(t)*Math.sqrt(n),Math_default.EPSILON14);return t>0?[i/e,a/i]:[a/i,i/e]};var QuadraticRealPolynomial_default=QuadraticRealPolynomial,CubicRealPolynomial={};function computeRealRoots(e,t,a,r){const n=e,i=t/3,l=a/3,u=r,o=n*l,d=i*u,s=i*i,f=l*l,c=n*l-s,_=n*u-i*l,h=i*u-f,m=4*c*h-_*_;let p,C;if(m<0){let e,t,a;s*d>=o*f?(e=n,t=c,a=-2*i*c+n*_):(e=u,t=h,a=-u*_+2*l*h);const r=-(a<0?-1:1)*Math.abs(e)*Math.sqrt(-m);C=-a+r;const w=C/2,M=w<0?-Math.pow(-w,1/3):Math.pow(w,1/3),y=C===r?-M:-t/M;return p=t<=0?M+y:-a/(M*M+y*y+t),s*d>=o*f?[(p-i)/n]:[-u/(p+l)]}const w=c,M=-2*i*c+n*_,y=h,R=-u*_+2*l*h,b=Math.sqrt(m),g=Math.sqrt(3)/2;let S=Math.abs(Math.atan2(n*b,-M)/3);p=2*Math.sqrt(-w);let E=Math.cos(S);C=p*E;let q=p*(-E/2-g*Math.sin(S));const v=C+q>2*i?C-i:q-i,P=n,D=v/P;S=Math.abs(Math.atan2(u*b,-R)/3),p=2*Math.sqrt(-y),E=Math.cos(S),C=p*E,q=p*(-E/2-g*Math.sin(S));const x=-u,I=C+q<2*l?C+l:q+l,O=x/I,T=-v*I-P*x,L=(l*T-i*(v*x))/(-i*T+l*(P*I));return D<=L?D<=O?L<=O?[D,L,O]:[D,O,L]:[O,D,L]:D<=O?[L,D,O]:L<=O?[L,O,D]:[O,L,D]}CubicRealPolynomial.computeDiscriminant=function(e,t,a,r){if("number"!=typeof e)throw new DeveloperError_default("a is a required number.");if("number"!=typeof t)throw new DeveloperError_default("b is a required number.");if("number"!=typeof a)throw new DeveloperError_default("c is a required number.");if("number"!=typeof r)throw new DeveloperError_default("d is a required number.");const n=t*t,i=a*a;return 18*e*t*a*r+n*i-e*e*27*(r*r)-4*(e*i*a+n*t*r)},CubicRealPolynomial.computeRealRoots=function(e,t,a,r){if("number"!=typeof e)throw new DeveloperError_default("a is a required number.");if("number"!=typeof t)throw new DeveloperError_default("b is a required number.");if("number"!=typeof a)throw new DeveloperError_default("c is a required number.");if("number"!=typeof r)throw new DeveloperError_default("d is a required number.");let n,i;if(0===e)return QuadraticRealPolynomial_default.computeRealRoots(t,a,r);if(0===t){if(0===a){if(0===r)return[0,0,0];i=-r/e;const t=i<0?-Math.pow(-i,1/3):Math.pow(i,1/3);return[t,t,t]}return 0===r?(n=QuadraticRealPolynomial_default.computeRealRoots(e,0,a),0===n.Length?[0]:[n[0],0,n[1]]):computeRealRoots(e,0,a,r)}return 0===a?0===r?(i=-t/e,i<0?[i,0,0]:[0,0,i]):computeRealRoots(e,t,0,r):0===r?(n=QuadraticRealPolynomial_default.computeRealRoots(e,t,a),0===n.length?[0]:n[1]<=0?[n[0],n[1],0]:n[0]>=0?[0,n[0],n[1]]:[n[0],0,n[1]]):computeRealRoots(e,t,a,r)};var CubicRealPolynomial_default=CubicRealPolynomial,QuarticRealPolynomial={};function original(e,t,a,r){const n=e*e,i=t-3*n/8,l=a-t*e/2+n*e/8,u=r-a*e/4+t*n/16-3*n*n/256,o=CubicRealPolynomial_default.computeRealRoots(1,2*i,i*i-4*u,-l*l);if(o.length>0){const t=-e/4,a=o[o.length-1];if(Math.abs(a)<Math_default.EPSILON14){const e=QuadraticRealPolynomial_default.computeRealRoots(1,i,u);if(2===e.length){const a=e[0],r=e[1];let n;if(a>=0&&r>=0){const e=Math.sqrt(a),n=Math.sqrt(r);return[t-n,t-e,t+e,t+n]}if(a>=0&&r<0)return n=Math.sqrt(a),[t-n,t+n];if(a<0&&r>=0)return n=Math.sqrt(r),[t-n,t+n]}return[]}if(a>0){const e=Math.sqrt(a),r=(i+a-l/e)/2,n=(i+a+l/e)/2,u=QuadraticRealPolynomial_default.computeRealRoots(1,e,r),o=QuadraticRealPolynomial_default.computeRealRoots(1,-e,n);return 0!==u.length?(u[0]+=t,u[1]+=t,0!==o.length?(o[0]+=t,o[1]+=t,u[1]<=o[0]?[u[0],u[1],o[0],o[1]]:o[1]<=u[0]?[o[0],o[1],u[0],u[1]]:u[0]>=o[0]&&u[1]<=o[1]?[o[0],u[0],u[1],o[1]]:o[0]>=u[0]&&o[1]<=u[1]?[u[0],o[0],o[1],u[1]]:u[0]>o[0]&&u[0]<o[1]?[o[0],u[0],o[1],u[1]]:[u[0],o[0],u[1],o[1]]):u):0!==o.length?(o[0]+=t,o[1]+=t,o):[]}}return[]}function neumark(e,t,a,r){const n=e*e,i=-2*t,l=a*e+t*t-4*r,u=n*r-a*t*e+a*a,o=CubicRealPolynomial_default.computeRealRoots(1,i,l,u);if(o.length>0){const i=o[0],l=t-i,u=l*l,d=e/2,s=l/2,f=u-4*r,c=u+4*Math.abs(r),_=n-4*i,h=n+4*Math.abs(i);let m,p,C,w,M,y;if(i<0||f*h<_*c){const t=Math.sqrt(_);m=t/2,p=0===t?0:(e*s-a)/t}else{const t=Math.sqrt(f);m=0===t?0:(e*s-a)/t,p=t/2}0===d&&0===m?(C=0,w=0):Math_default.sign(d)===Math_default.sign(m)?(C=d+m,w=i/C):(w=d-m,C=i/w),0===s&&0===p?(M=0,y=0):Math_default.sign(s)===Math_default.sign(p)?(M=s+p,y=r/M):(y=s-p,M=r/y);const R=QuadraticRealPolynomial_default.computeRealRoots(1,C,M),b=QuadraticRealPolynomial_default.computeRealRoots(1,w,y);if(0!==R.length)return 0!==b.length?R[1]<=b[0]?[R[0],R[1],b[0],b[1]]:b[1]<=R[0]?[b[0],b[1],R[0],R[1]]:R[0]>=b[0]&&R[1]<=b[1]?[b[0],R[0],R[1],b[1]]:b[0]>=R[0]&&b[1]<=R[1]?[R[0],b[0],b[1],R[1]]:R[0]>b[0]&&R[0]<b[1]?[b[0],R[0],b[1],R[1]]:[R[0],b[0],R[1],b[1]]:R;if(0!==b.length)return b}return[]}QuarticRealPolynomial.computeDiscriminant=function(e,t,a,r,n){if("number"!=typeof e)throw new DeveloperError_default("a is a required number.");if("number"!=typeof t)throw new DeveloperError_default("b is a required number.");if("number"!=typeof a)throw new DeveloperError_default("c is a required number.");if("number"!=typeof r)throw new DeveloperError_default("d is a required number.");if("number"!=typeof n)throw new DeveloperError_default("e is a required number.");const i=e*e,l=t*t,u=l*t,o=a*a,d=o*a,s=r*r,f=s*r,c=n*n;return l*o*s-4*u*f-4*e*d*s+18*e*t*a*f-27*i*s*s+i*e*256*(c*n)+n*(18*u*a*r-4*l*d+16*e*o*o-80*e*t*o*r-6*e*l*s+144*i*a*s)+c*(144*e*l*a-27*l*l-128*i*o-192*i*t*r)},QuarticRealPolynomial.computeRealRoots=function(e,t,a,r,n){if("number"!=typeof e)throw new DeveloperError_default("a is a required number.");if("number"!=typeof t)throw new DeveloperError_default("b is a required number.");if("number"!=typeof a)throw new DeveloperError_default("c is a required number.");if("number"!=typeof r)throw new DeveloperError_default("d is a required number.");if("number"!=typeof n)throw new DeveloperError_default("e is a required number.");if(Math.abs(e)<Math_default.EPSILON15)return CubicRealPolynomial_default.computeRealRoots(t,a,r,n);const i=t/e,l=a/e,u=r/e,o=n/e;let d=i<0?1:0;switch(d+=l<0?d+1:d,d+=u<0?d+1:d,d+=o<0?d+1:d,d){case 0:case 3:case 4:case 6:case 7:case 9:case 10:case 12:case 13:case 14:case 15:return original(i,l,u,o);case 1:case 2:case 5:case 8:case 11:return neumark(i,l,u,o);default:return}};var QuarticRealPolynomial_default=QuarticRealPolynomial;function Ray(e,t){t=Cartesian3_default.clone(defaultValue_default(t,Cartesian3_default.ZERO)),Cartesian3_default.equals(t,Cartesian3_default.ZERO)||Cartesian3_default.normalize(t,t),this.origin=Cartesian3_default.clone(defaultValue_default(e,Cartesian3_default.ZERO)),this.direction=t}Ray.clone=function(e,t){if(defined_default(e))return defined_default(t)?(t.origin=Cartesian3_default.clone(e.origin),t.direction=Cartesian3_default.clone(e.direction),t):new Ray(e.origin,e.direction)},Ray.getPoint=function(e,t,a){return Check_default.typeOf.object("ray",e),Check_default.typeOf.number("t",t),defined_default(a)||(a=new Cartesian3_default),a=Cartesian3_default.multiplyByScalar(e.direction,t,a),Cartesian3_default.add(e.origin,a,a)};var Ray_default=Ray,IntersectionTests={rayPlane:function(e,t,a){if(!defined_default(e))throw new DeveloperError_default("ray is required.");if(!defined_default(t))throw new DeveloperError_default("plane is required.");defined_default(a)||(a=new Cartesian3_default);const r=e.origin,n=e.direction,i=t.normal,l=Cartesian3_default.dot(i,n);if(Math.abs(l)<Math_default.EPSILON15)return;const u=(-t.distance-Cartesian3_default.dot(i,r))/l;return u<0?void 0:(a=Cartesian3_default.multiplyByScalar(n,u,a),Cartesian3_default.add(r,a,a))}},scratchEdge0=new Cartesian3_default,scratchEdge1=new Cartesian3_default,scratchPVec=new Cartesian3_default,scratchTVec=new Cartesian3_default,scratchQVec=new Cartesian3_default;IntersectionTests.rayTriangleParametric=function(e,t,a,r,n){if(!defined_default(e))throw new DeveloperError_default("ray is required.");if(!defined_default(t))throw new DeveloperError_default("p0 is required.");if(!defined_default(a))throw new DeveloperError_default("p1 is required.");if(!defined_default(r))throw new DeveloperError_default("p2 is required.");n=defaultValue_default(n,!1);const i=e.origin,l=e.direction,u=Cartesian3_default.subtract(a,t,scratchEdge0),o=Cartesian3_default.subtract(r,t,scratchEdge1),d=Cartesian3_default.cross(l,o,scratchPVec),s=Cartesian3_default.dot(u,d);let f,c,_,h,m;if(n){if(s<Math_default.EPSILON6)return;if(f=Cartesian3_default.subtract(i,t,scratchTVec),_=Cartesian3_default.dot(f,d),_<0||_>s)return;if(c=Cartesian3_default.cross(f,u,scratchQVec),h=Cartesian3_default.dot(l,c),h<0||_+h>s)return;m=Cartesian3_default.dot(o,c)/s}else{if(Math.abs(s)<Math_default.EPSILON6)return;const e=1/s;if(f=Cartesian3_default.subtract(i,t,scratchTVec),_=Cartesian3_default.dot(f,d)*e,_<0||_>1)return;if(c=Cartesian3_default.cross(f,u,scratchQVec),h=Cartesian3_default.dot(l,c)*e,h<0||_+h>1)return;m=Cartesian3_default.dot(o,c)*e}return m},IntersectionTests.rayTriangle=function(e,t,a,r,n,i){const l=IntersectionTests.rayTriangleParametric(e,t,a,r,n);if(defined_default(l)&&!(l<0))return defined_default(i)||(i=new Cartesian3_default),Cartesian3_default.multiplyByScalar(e.direction,l,i),Cartesian3_default.add(e.origin,i,i)};var scratchLineSegmentTriangleRay=new Ray_default;function solveQuadratic(e,t,a,r){const n=t*t-4*e*a;if(n<0)return;if(n>0){const a=1/(2*e),i=Math.sqrt(n),l=(-t+i)*a,u=(-t-i)*a;return l<u?(r.root0=l,r.root1=u):(r.root0=u,r.root1=l),r}const i=-t/(2*e);return 0!==i?(r.root0=r.root1=i,r):void 0}IntersectionTests.lineSegmentTriangle=function(e,t,a,r,n,i,l){if(!defined_default(e))throw new DeveloperError_default("v0 is required.");if(!defined_default(t))throw new DeveloperError_default("v1 is required.");if(!defined_default(a))throw new DeveloperError_default("p0 is required.");if(!defined_default(r))throw new DeveloperError_default("p1 is required.");if(!defined_default(n))throw new DeveloperError_default("p2 is required.");const u=scratchLineSegmentTriangleRay;Cartesian3_default.clone(e,u.origin),Cartesian3_default.subtract(t,e,u.direction),Cartesian3_default.normalize(u.direction,u.direction);const o=IntersectionTests.rayTriangleParametric(u,a,r,n,i);if(!(!defined_default(o)||o<0||o>Cartesian3_default.distance(e,t)))return defined_default(l)||(l=new Cartesian3_default),Cartesian3_default.multiplyByScalar(u.direction,o,l),Cartesian3_default.add(u.origin,l,l)};var raySphereRoots={root0:0,root1:0};function raySphere(e,t,a){defined_default(a)||(a=new Interval_default);const r=e.origin,n=e.direction,i=t.center,l=t.radius*t.radius,u=Cartesian3_default.subtract(r,i,scratchPVec),o=solveQuadratic(Cartesian3_default.dot(n,n),2*Cartesian3_default.dot(n,u),Cartesian3_default.magnitudeSquared(u)-l,raySphereRoots);if(defined_default(o))return a.start=o.root0,a.stop=o.root1,a}IntersectionTests.raySphere=function(e,t,a){if(!defined_default(e))throw new DeveloperError_default("ray is required.");if(!defined_default(t))throw new DeveloperError_default("sphere is required.");if(a=raySphere(e,t,a),defined_default(a)&&!(a.stop<0))return a.start=Math.max(a.start,0),a};var scratchLineSegmentRay=new Ray_default;IntersectionTests.lineSegmentSphere=function(e,t,a,r){if(!defined_default(e))throw new DeveloperError_default("p0 is required.");if(!defined_default(t))throw new DeveloperError_default("p1 is required.");if(!defined_default(a))throw new DeveloperError_default("sphere is required.");const n=scratchLineSegmentRay;Cartesian3_default.clone(e,n.origin);const i=Cartesian3_default.subtract(t,e,n.direction),l=Cartesian3_default.magnitude(i);if(Cartesian3_default.normalize(i,i),r=raySphere(n,a,r),!(!defined_default(r)||r.stop<0||r.start>l))return r.start=Math.max(r.start,0),r.stop=Math.min(r.stop,l),r};var scratchQ=new Cartesian3_default,scratchW=new Cartesian3_default;function addWithCancellationCheck2(e,t,a){const r=e+t;return Math_default.sign(e)!==Math_default.sign(t)&&Math.abs(r/Math.max(Math.abs(e),Math.abs(t)))<a?0:r}function quadraticVectorExpression(e,t,a,r,n){const i=r*r,l=n*n,u=(e[Matrix3_default.COLUMN1ROW1]-e[Matrix3_default.COLUMN2ROW2])*l,o=n*(r*addWithCancellationCheck2(e[Matrix3_default.COLUMN1ROW0],e[Matrix3_default.COLUMN0ROW1],Math_default.EPSILON15)+t.y),d=e[Matrix3_default.COLUMN0ROW0]*i+e[Matrix3_default.COLUMN2ROW2]*l+r*t.x+a,s=l*addWithCancellationCheck2(e[Matrix3_default.COLUMN2ROW1],e[Matrix3_default.COLUMN1ROW2],Math_default.EPSILON15),f=n*(r*addWithCancellationCheck2(e[Matrix3_default.COLUMN2ROW0],e[Matrix3_default.COLUMN0ROW2])+t.z);let c;const _=[];if(0===f&&0===s){if(c=QuadraticRealPolynomial_default.computeRealRoots(u,o,d),0===c.length)return _;const e=c[0],t=Math.sqrt(Math.max(1-e*e,0));if(_.push(new Cartesian3_default(r,n*e,n*-t)),_.push(new Cartesian3_default(r,n*e,n*t)),2===c.length){const e=c[1],t=Math.sqrt(Math.max(1-e*e,0));_.push(new Cartesian3_default(r,n*e,n*-t)),_.push(new Cartesian3_default(r,n*e,n*t))}return _}const h=f*f,m=s*s,p=f*s,C=u*u+m,w=2*(o*u+p),M=2*d*u+o*o-m+h,y=2*(d*o-p),R=d*d-h;if(0===C&&0===w&&0===M&&0===y)return _;c=QuarticRealPolynomial_default.computeRealRoots(C,w,M,y,R);const b=c.length;if(0===b)return _;for(let e=0;e<b;++e){const t=c[e],a=t*t,i=Math.max(1-a,0),l=Math.sqrt(i);let h;h=Math_default.sign(u)===Math_default.sign(d)?addWithCancellationCheck2(u*a+d,o*t,Math_default.EPSILON12):Math_default.sign(d)===Math_default.sign(o*t)?addWithCancellationCheck2(u*a,o*t+d,Math_default.EPSILON12):addWithCancellationCheck2(u*a+o*t,d,Math_default.EPSILON12);const m=h*addWithCancellationCheck2(s*t,f,Math_default.EPSILON15);m<0?_.push(new Cartesian3_default(r,n*t,n*l)):m>0?_.push(new Cartesian3_default(r,n*t,n*-l)):0!==l?(_.push(new Cartesian3_default(r,n*t,n*-l)),_.push(new Cartesian3_default(r,n*t,n*l)),++e):_.push(new Cartesian3_default(r,n*t,n*l))}return _}IntersectionTests.rayEllipsoid=function(e,t){if(!defined_default(e))throw new DeveloperError_default("ray is required.");if(!defined_default(t))throw new DeveloperError_default("ellipsoid is required.");const a=t.oneOverRadii,r=Cartesian3_default.multiplyComponents(a,e.origin,scratchQ),n=Cartesian3_default.multiplyComponents(a,e.direction,scratchW),i=Cartesian3_default.magnitudeSquared(r),l=Cartesian3_default.dot(r,n);let u,o,d,s,f;if(i>1){if(l>=0)return;const e=l*l;if(u=i-1,o=Cartesian3_default.magnitudeSquared(n),d=o*u,e<d)return;if(e>d){s=l*l-d,f=-l+Math.sqrt(s);const e=f/o,t=u/f;return e<t?new Interval_default(e,t):{start:t,stop:e}}const t=Math.sqrt(u/o);return new Interval_default(t,t)}return i<1?(u=i-1,o=Cartesian3_default.magnitudeSquared(n),d=o*u,s=l*l-d,f=-l+Math.sqrt(s),new Interval_default(0,f/o)):l<0?(o=Cartesian3_default.magnitudeSquared(n),new Interval_default(0,-l/o)):void 0};var firstAxisScratch=new Cartesian3_default,secondAxisScratch=new Cartesian3_default,thirdAxisScratch=new Cartesian3_default,referenceScratch=new Cartesian3_default,bCart=new Cartesian3_default,bScratch=new Matrix3_default,btScratch=new Matrix3_default,diScratch=new Matrix3_default,dScratch=new Matrix3_default,cScratch=new Matrix3_default,tempMatrix=new Matrix3_default,aScratch=new Matrix3_default,sScratch=new Cartesian3_default,closestScratch=new Cartesian3_default,surfPointScratch=new Cartographic_default;IntersectionTests.grazingAltitudeLocation=function(e,t){if(!defined_default(e))throw new DeveloperError_default("ray is required.");if(!defined_default(t))throw new DeveloperError_default("ellipsoid is required.");const a=e.origin,r=e.direction;if(!Cartesian3_default.equals(a,Cartesian3_default.ZERO)){const e=t.geodeticSurfaceNormal(a,firstAxisScratch);if(Cartesian3_default.dot(r,e)>=0)return a}const n=defined_default(this.rayEllipsoid(e,t)),i=t.transformPositionToScaledSpace(r,firstAxisScratch),l=Cartesian3_default.normalize(i,i),u=Cartesian3_default.mostOrthogonalAxis(i,referenceScratch),o=Cartesian3_default.normalize(Cartesian3_default.cross(u,l,secondAxisScratch),secondAxisScratch),d=Cartesian3_default.normalize(Cartesian3_default.cross(l,o,thirdAxisScratch),thirdAxisScratch),s=bScratch;s[0]=l.x,s[1]=l.y,s[2]=l.z,s[3]=o.x,s[4]=o.y,s[5]=o.z,s[6]=d.x,s[7]=d.y,s[8]=d.z;const f=Matrix3_default.transpose(s,btScratch),c=Matrix3_default.fromScale(t.radii,diScratch),_=Matrix3_default.fromScale(t.oneOverRadii,dScratch),h=cScratch;h[0]=0,h[1]=-r.z,h[2]=r.y,h[3]=r.z,h[4]=0,h[5]=-r.x,h[6]=-r.y,h[7]=r.x,h[8]=0;const m=Matrix3_default.multiply(Matrix3_default.multiply(f,_,tempMatrix),h,tempMatrix),p=Matrix3_default.multiply(Matrix3_default.multiply(m,c,aScratch),s,aScratch),C=Matrix3_default.multiplyByVector(m,a,bCart),w=quadraticVectorExpression(p,Cartesian3_default.negate(C,firstAxisScratch),0,0,1);let M,y;const R=w.length;if(R>0){let e=Cartesian3_default.clone(Cartesian3_default.ZERO,closestScratch),i=Number.NEGATIVE_INFINITY;for(let t=0;t<R;++t){M=Matrix3_default.multiplyByVector(c,Matrix3_default.multiplyByVector(s,w[t],sScratch),sScratch);const n=Cartesian3_default.normalize(Cartesian3_default.subtract(M,a,referenceScratch),referenceScratch),l=Cartesian3_default.dot(n,r);l>i&&(i=l,e=Cartesian3_default.clone(M,e))}const l=t.cartesianToCartographic(e,surfPointScratch);return i=Math_default.clamp(i,0,1),y=Cartesian3_default.magnitude(Cartesian3_default.subtract(e,a,referenceScratch))*Math.sqrt(1-i*i),y=n?-y:y,l.height=y,t.cartographicToCartesian(l,new Cartesian3_default)}};var lineSegmentPlaneDifference=new Cartesian3_default;IntersectionTests.lineSegmentPlane=function(e,t,a,r){if(!defined_default(e))throw new DeveloperError_default("endPoint0 is required.");if(!defined_default(t))throw new DeveloperError_default("endPoint1 is required.");if(!defined_default(a))throw new DeveloperError_default("plane is required.");defined_default(r)||(r=new Cartesian3_default);const n=Cartesian3_default.subtract(t,e,lineSegmentPlaneDifference),i=a.normal,l=Cartesian3_default.dot(i,n);if(Math.abs(l)<Math_default.EPSILON6)return;const u=Cartesian3_default.dot(i,e),o=-(a.distance+u)/l;return o<0||o>1?void 0:(Cartesian3_default.multiplyByScalar(n,o,r),Cartesian3_default.add(e,r,r),r)},IntersectionTests.trianglePlaneIntersection=function(e,t,a,r){if(!(defined_default(e)&&defined_default(t)&&defined_default(a)&&defined_default(r)))throw new DeveloperError_default("p0, p1, p2, and plane are required.");const n=r.normal,i=r.distance,l=Cartesian3_default.dot(n,e)+i<0,u=Cartesian3_default.dot(n,t)+i<0,o=Cartesian3_default.dot(n,a)+i<0;let d,s,f=0;if(f+=l?1:0,f+=u?1:0,f+=o?1:0,1!==f&&2!==f||(d=new Cartesian3_default,s=new Cartesian3_default),1===f){if(l)return IntersectionTests.lineSegmentPlane(e,t,r,d),IntersectionTests.lineSegmentPlane(e,a,r,s),{positions:[e,t,a,d,s],indices:[0,3,4,1,2,4,1,4,3]};if(u)return IntersectionTests.lineSegmentPlane(t,a,r,d),IntersectionTests.lineSegmentPlane(t,e,r,s),{positions:[e,t,a,d,s],indices:[1,3,4,2,0,4,2,4,3]};if(o)return IntersectionTests.lineSegmentPlane(a,e,r,d),IntersectionTests.lineSegmentPlane(a,t,r,s),{positions:[e,t,a,d,s],indices:[2,3,4,0,1,4,0,4,3]}}else if(2===f){if(!l)return IntersectionTests.lineSegmentPlane(t,e,r,d),IntersectionTests.lineSegmentPlane(a,e,r,s),{positions:[e,t,a,d,s],indices:[1,2,4,1,4,3,0,3,4]};if(!u)return IntersectionTests.lineSegmentPlane(a,t,r,d),IntersectionTests.lineSegmentPlane(e,t,r,s),{positions:[e,t,a,d,s],indices:[2,0,4,2,4,3,1,3,4]};if(!o)return IntersectionTests.lineSegmentPlane(e,a,r,d),IntersectionTests.lineSegmentPlane(t,a,r,s),{positions:[e,t,a,d,s],indices:[0,1,4,0,4,3,2,3,4]}}};var IntersectionTests_default=IntersectionTests;export{Ray_default,IntersectionTests_default};