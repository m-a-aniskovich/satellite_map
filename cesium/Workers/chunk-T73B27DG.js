/*! For license information please see chunk-T73B27DG.js.LICENSE.txt */
import{EllipseGeometryLibrary_default}from"./chunk-FRG2Z7DE.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var scratchCartesian1=new Cartesian3_default,boundingSphereCenter=new Cartesian3_default;function computeEllipse(e){const t=e.center;boundingSphereCenter=Cartesian3_default.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(t,boundingSphereCenter),e.height,boundingSphereCenter),boundingSphereCenter=Cartesian3_default.add(t,boundingSphereCenter,boundingSphereCenter);const i=new BoundingSphere_default(boundingSphereCenter,e.semiMajorAxis),r=EllipseGeometryLibrary_default.computeEllipsePositions(e,!1,!0).outerPositions,a=new GeometryAttributes_default({position:new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:EllipseGeometryLibrary_default.raisePositionsToHeight(r,e,!1)})}),o=r.length/3,n=IndexDatatype_default.createTypedArray(o,2*o);let l=0;for(let e=0;e<o;++e)n[l++]=e,n[l++]=(e+1)%o;return{boundingSphere:i,attributes:a,indices:n}}var topBoundingSphere=new BoundingSphere_default,bottomBoundingSphere=new BoundingSphere_default;function computeExtrudedEllipse(e){const t=e.center,i=e.ellipsoid,r=e.semiMajorAxis;let a=Cartesian3_default.multiplyByScalar(i.geodeticSurfaceNormal(t,scratchCartesian1),e.height,scratchCartesian1);topBoundingSphere.center=Cartesian3_default.add(t,a,topBoundingSphere.center),topBoundingSphere.radius=r,a=Cartesian3_default.multiplyByScalar(i.geodeticSurfaceNormal(t,a),e.extrudedHeight,a),bottomBoundingSphere.center=Cartesian3_default.add(t,a,bottomBoundingSphere.center),bottomBoundingSphere.radius=r;let o=EllipseGeometryLibrary_default.computeEllipsePositions(e,!1,!0).outerPositions;const n=new GeometryAttributes_default({position:new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:EllipseGeometryLibrary_default.raisePositionsToHeight(o,e,!0)})});o=n.position.values;const l=BoundingSphere_default.union(topBoundingSphere,bottomBoundingSphere);let u=o.length/3;if(defined_default(e.offsetAttribute)){let t=new Uint8Array(u);if(e.offsetAttribute===GeometryOffsetAttribute_default.TOP)t=t.fill(1,0,u/2);else{const i=e.offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1;t=t.fill(i)}n.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let s=defaultValue_default(e.numberOfVerticalLines,16);s=Math_default.clamp(s,0,u/2);const d=IndexDatatype_default.createTypedArray(u,2*u+2*s);u/=2;let f,p,_=0;for(f=0;f<u;++f)d[_++]=f,d[_++]=(f+1)%u,d[_++]=f+u,d[_++]=(f+1)%u+u;if(s>0){const e=Math.min(s,u);p=Math.round(u/e);const t=Math.min(p*s,u);for(f=0;f<t;f+=p)d[_++]=f,d[_++]=f+u}return{boundingSphere:l,attributes:n,indices:d}}function EllipseOutlineGeometry(e){const t=(e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT)).center,i=defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84),r=e.semiMajorAxis,a=e.semiMinorAxis,o=defaultValue_default(e.granularity,Math_default.RADIANS_PER_DEGREE);if(!defined_default(t))throw new DeveloperError_default("center is required.");if(!defined_default(r))throw new DeveloperError_default("semiMajorAxis is required.");if(!defined_default(a))throw new DeveloperError_default("semiMinorAxis is required.");if(r<a)throw new DeveloperError_default("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(o<=0)throw new DeveloperError_default("granularity must be greater than zero.");const n=defaultValue_default(e.height,0),l=defaultValue_default(e.extrudedHeight,n);this._center=Cartesian3_default.clone(t),this._semiMajorAxis=r,this._semiMinorAxis=a,this._ellipsoid=Ellipsoid_default.clone(i),this._rotation=defaultValue_default(e.rotation,0),this._height=Math.max(l,n),this._granularity=o,this._extrudedHeight=Math.min(l,n),this._numberOfVerticalLines=Math.max(defaultValue_default(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}EllipseOutlineGeometry.packedLength=Cartesian3_default.packedLength+Ellipsoid_default.packedLength+8,EllipseOutlineGeometry.pack=function(e,t,i){if(!defined_default(e))throw new DeveloperError_default("value is required");if(!defined_default(t))throw new DeveloperError_default("array is required");return i=defaultValue_default(i,0),Cartesian3_default.pack(e._center,t,i),i+=Cartesian3_default.packedLength,Ellipsoid_default.pack(e._ellipsoid,t,i),i+=Ellipsoid_default.packedLength,t[i++]=e._semiMajorAxis,t[i++]=e._semiMinorAxis,t[i++]=e._rotation,t[i++]=e._height,t[i++]=e._granularity,t[i++]=e._extrudedHeight,t[i++]=e._numberOfVerticalLines,t[i]=defaultValue_default(e._offsetAttribute,-1),t};var scratchCenter=new Cartesian3_default,scratchEllipsoid=new Ellipsoid_default,scratchOptions={center:scratchCenter,ellipsoid:scratchEllipsoid,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};EllipseOutlineGeometry.unpack=function(e,t,i){if(!defined_default(e))throw new DeveloperError_default("array is required");t=defaultValue_default(t,0);const r=Cartesian3_default.unpack(e,t,scratchCenter);t+=Cartesian3_default.packedLength;const a=Ellipsoid_default.unpack(e,t,scratchEllipsoid);t+=Ellipsoid_default.packedLength;const o=e[t++],n=e[t++],l=e[t++],u=e[t++],s=e[t++],d=e[t++],f=e[t++],p=e[t];return defined_default(i)?(i._center=Cartesian3_default.clone(r,i._center),i._ellipsoid=Ellipsoid_default.clone(a,i._ellipsoid),i._semiMajorAxis=o,i._semiMinorAxis=n,i._rotation=l,i._height=u,i._granularity=s,i._extrudedHeight=d,i._numberOfVerticalLines=f,i._offsetAttribute=-1===p?void 0:p,i):(scratchOptions.height=u,scratchOptions.extrudedHeight=d,scratchOptions.granularity=s,scratchOptions.rotation=l,scratchOptions.semiMajorAxis=o,scratchOptions.semiMinorAxis=n,scratchOptions.numberOfVerticalLines=f,scratchOptions.offsetAttribute=-1===p?void 0:p,new EllipseOutlineGeometry(scratchOptions))},EllipseOutlineGeometry.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const t=e._height,i=e._extrudedHeight,r=!Math_default.equalsEpsilon(t,i,0,Math_default.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const a={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:t,granularity:e._granularity,numberOfVerticalLines:e._numberOfVerticalLines};let o;if(r)a.extrudedHeight=i,a.offsetAttribute=e._offsetAttribute,o=computeExtrudedEllipse(a);else if(o=computeEllipse(a),defined_default(e._offsetAttribute)){const t=o.attributes.position.values.length,i=e._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,r=new Uint8Array(t/3).fill(i);o.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new Geometry_default({attributes:o.attributes,indices:o.indices,primitiveType:PrimitiveType_default.LINES,boundingSphere:o.boundingSphere,offsetAttribute:e._offsetAttribute})};var EllipseOutlineGeometry_default=EllipseOutlineGeometry;export{EllipseOutlineGeometry_default};