/*! For license information please see createPolygonOutlineGeometry.js.LICENSE.txt */
import{PolygonGeometryLibrary_default}from"./chunk-VODWDCX6.js";import{ArcType_default}from"./chunk-235MRXLH.js";import{GeometryInstance_default}from"./chunk-GTEXWEAP.js";import{GeometryPipeline_default}from"./chunk-36ESDRIZ.js";import"./chunk-I6TVJ6T7.js";import"./chunk-VOAZN4IP.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{EllipsoidTangentPlane_default}from"./chunk-MOLGJDJV.js";import"./chunk-FGUP2QEP.js";import{PolygonPipeline_default,WindingOrder_default}from"./chunk-ZVUAJKAL.js";import"./chunk-DTNN3ODA.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var createGeometryFromPositionsPositions=[],createGeometryFromPositionsSubdivided=[];function createGeometryFromPositions(e,t,o,i,r){const n=EllipsoidTangentPlane_default.fromPoints(t,e).projectPointsOntoPlane(t,createGeometryFromPositionsPositions);let l,a;PolygonPipeline_default.computeWindingOrder2D(n)===WindingOrder_default.CLOCKWISE&&(n.reverse(),t=t.slice().reverse());let u=t.length,d=0;if(i)for(l=new Float64Array(2*u*3),a=0;a<u;a++){const e=t[a],o=t[(a+1)%u];l[d++]=e.x,l[d++]=e.y,l[d++]=e.z,l[d++]=o.x,l[d++]=o.y,l[d++]=o.z}else{let i=0;if(r===ArcType_default.GEODESIC)for(a=0;a<u;a++)i+=PolygonGeometryLibrary_default.subdivideLineCount(t[a],t[(a+1)%u],o);else if(r===ArcType_default.RHUMB)for(a=0;a<u;a++)i+=PolygonGeometryLibrary_default.subdivideRhumbLineCount(e,t[a],t[(a+1)%u],o);for(l=new Float64Array(3*i),a=0;a<u;a++){let i;r===ArcType_default.GEODESIC?i=PolygonGeometryLibrary_default.subdivideLine(t[a],t[(a+1)%u],o,createGeometryFromPositionsSubdivided):r===ArcType_default.RHUMB&&(i=PolygonGeometryLibrary_default.subdivideRhumbLine(e,t[a],t[(a+1)%u],o,createGeometryFromPositionsSubdivided));const n=i.length;for(let e=0;e<n;++e)l[d++]=i[e]}}u=l.length/3;const s=2*u,f=IndexDatatype_default.createTypedArray(u,s);for(d=0,a=0;a<u-1;a++)f[d++]=a,f[d++]=a+1;return f[d++]=u-1,f[d++]=0,new GeometryInstance_default({geometry:new Geometry_default({attributes:new GeometryAttributes_default({position:new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:l})}),indices:f,primitiveType:PrimitiveType_default.LINES})})}function createGeometryFromPositionsExtruded(e,t,o,i,r){const n=EllipsoidTangentPlane_default.fromPoints(t,e).projectPointsOntoPlane(t,createGeometryFromPositionsPositions);let l,a;PolygonPipeline_default.computeWindingOrder2D(n)===WindingOrder_default.CLOCKWISE&&(n.reverse(),t=t.slice().reverse());let u=t.length;const d=new Array(u);let s=0;if(i)for(l=new Float64Array(2*u*3*2),a=0;a<u;++a){d[a]=s/3;const e=t[a],o=t[(a+1)%u];l[s++]=e.x,l[s++]=e.y,l[s++]=e.z,l[s++]=o.x,l[s++]=o.y,l[s++]=o.z}else{let i=0;if(r===ArcType_default.GEODESIC)for(a=0;a<u;a++)i+=PolygonGeometryLibrary_default.subdivideLineCount(t[a],t[(a+1)%u],o);else if(r===ArcType_default.RHUMB)for(a=0;a<u;a++)i+=PolygonGeometryLibrary_default.subdivideRhumbLineCount(e,t[a],t[(a+1)%u],o);for(l=new Float64Array(3*i*2),a=0;a<u;++a){let i;d[a]=s/3,r===ArcType_default.GEODESIC?i=PolygonGeometryLibrary_default.subdivideLine(t[a],t[(a+1)%u],o,createGeometryFromPositionsSubdivided):r===ArcType_default.RHUMB&&(i=PolygonGeometryLibrary_default.subdivideRhumbLine(e,t[a],t[(a+1)%u],o,createGeometryFromPositionsSubdivided));const n=i.length;for(let e=0;e<n;++e)l[s++]=i[e]}}u=l.length/6;const f=d.length,y=2*(2*u+f),p=IndexDatatype_default.createTypedArray(u+f,y);for(s=0,a=0;a<u;++a)p[s++]=a,p[s++]=(a+1)%u,p[s++]=a+u,p[s++]=(a+1)%u+u;for(a=0;a<f;a++){const e=d[a];p[s++]=e,p[s++]=e+u}return new GeometryInstance_default({geometry:new Geometry_default({attributes:new GeometryAttributes_default({position:new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:l})}),indices:p,primitiveType:PrimitiveType_default.LINES})})}function PolygonOutlineGeometry(e){if(Check_default.typeOf.object("options",e),Check_default.typeOf.object("options.polygonHierarchy",e.polygonHierarchy),e.perPositionHeight&&defined_default(e.height))throw new DeveloperError_default("Cannot use both options.perPositionHeight and options.height");if(defined_default(e.arcType)&&e.arcType!==ArcType_default.GEODESIC&&e.arcType!==ArcType_default.RHUMB)throw new DeveloperError_default("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const t=e.polygonHierarchy,o=defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84),i=defaultValue_default(e.granularity,Math_default.RADIANS_PER_DEGREE),r=defaultValue_default(e.perPositionHeight,!1),n=r&&defined_default(e.extrudedHeight),l=defaultValue_default(e.arcType,ArcType_default.GEODESIC);let a=defaultValue_default(e.height,0),u=defaultValue_default(e.extrudedHeight,a);if(!n){const e=Math.max(a,u);u=Math.min(a,u),a=e}this._ellipsoid=Ellipsoid_default.clone(o),this._granularity=i,this._height=a,this._extrudedHeight=u,this._arcType=l,this._polygonHierarchy=t,this._perPositionHeight=r,this._perPositionHeightExtrude=n,this._offsetAttribute=e.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=PolygonGeometryLibrary_default.computeHierarchyPackedLength(t,Cartesian3_default)+Ellipsoid_default.packedLength+8}PolygonOutlineGeometry.pack=function(e,t,o){return Check_default.typeOf.object("value",e),Check_default.defined("array",t),o=defaultValue_default(o,0),o=PolygonGeometryLibrary_default.packPolygonHierarchy(e._polygonHierarchy,t,o,Cartesian3_default),Ellipsoid_default.pack(e._ellipsoid,t,o),o+=Ellipsoid_default.packedLength,t[o++]=e._height,t[o++]=e._extrudedHeight,t[o++]=e._granularity,t[o++]=e._perPositionHeightExtrude?1:0,t[o++]=e._perPositionHeight?1:0,t[o++]=e._arcType,t[o++]=defaultValue_default(e._offsetAttribute,-1),t[o]=e.packedLength,t};var scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),dummyOptions={polygonHierarchy:{}};PolygonOutlineGeometry.unpack=function(e,t,o){Check_default.defined("array",e),t=defaultValue_default(t,0);const i=PolygonGeometryLibrary_default.unpackPolygonHierarchy(e,t,Cartesian3_default);t=i.startingIndex,delete i.startingIndex;const r=Ellipsoid_default.unpack(e,t,scratchEllipsoid);t+=Ellipsoid_default.packedLength;const n=e[t++],l=e[t++],a=e[t++],u=1===e[t++],d=1===e[t++],s=e[t++],f=e[t++],y=e[t];return defined_default(o)||(o=new PolygonOutlineGeometry(dummyOptions)),o._polygonHierarchy=i,o._ellipsoid=Ellipsoid_default.clone(r,o._ellipsoid),o._height=n,o._extrudedHeight=l,o._granularity=a,o._perPositionHeight=d,o._perPositionHeightExtrude=u,o._arcType=s,o._offsetAttribute=-1===f?void 0:f,o.packedLength=y,o},PolygonOutlineGeometry.fromPositions=function(e){return e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT),Check_default.defined("options.positions",e.positions),new PolygonOutlineGeometry({polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute})},PolygonOutlineGeometry.createGeometry=function(e){const t=e._ellipsoid,o=e._granularity,i=e._polygonHierarchy,r=e._perPositionHeight,n=e._arcType,l=PolygonGeometryLibrary_default.polygonOutlinesFromHierarchy(i,!r,t);if(0===l.length)return;let a;const u=[],d=Math_default.chordLength(o,t.maximumRadius),s=e._height,f=e._extrudedHeight;let y,p;if(e._perPositionHeightExtrude||!Math_default.equalsEpsilon(s,f,0,Math_default.EPSILON2))for(p=0;p<l.length;p++){if(a=createGeometryFromPositionsExtruded(t,l[p],d,r,n),a.geometry=PolygonGeometryLibrary_default.scaleToGeodeticHeightExtruded(a.geometry,s,f,t,r),defined_default(e._offsetAttribute)){const t=a.geometry.attributes.position.values.length/3;let o=new Uint8Array(t);e._offsetAttribute===GeometryOffsetAttribute_default.TOP?o=o.fill(1,0,t/2):(y=e._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,o=o.fill(y)),a.geometry.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}u.push(a)}else for(p=0;p<l.length;p++){if(a=createGeometryFromPositions(t,l[p],d,r,n),a.geometry.attributes.position.values=PolygonPipeline_default.scaleToGeodeticHeight(a.geometry.attributes.position.values,s,t,!r),defined_default(e._offsetAttribute)){const t=a.geometry.attributes.position.values.length;y=e._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1;const o=new Uint8Array(t/3).fill(y);a.geometry.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}u.push(a)}const c=GeometryPipeline_default.combineInstances(u)[0],_=BoundingSphere_default.fromVertices(c.attributes.position.values);return new Geometry_default({attributes:c.attributes,indices:c.indices,primitiveType:c.primitiveType,boundingSphere:_,offsetAttribute:e._offsetAttribute})};var PolygonOutlineGeometry_default=PolygonOutlineGeometry;function createPolygonOutlineGeometry(e,t){return defined_default(t)&&(e=PolygonOutlineGeometry_default.unpack(e,t)),e._ellipsoid=Ellipsoid_default.clone(e._ellipsoid),PolygonOutlineGeometry_default.createGeometry(e)}var createPolygonOutlineGeometry_default=createPolygonOutlineGeometry;export{createPolygonOutlineGeometry_default as default};