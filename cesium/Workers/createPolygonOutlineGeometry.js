define(["./defaultValue-fe22d8c0","./Matrix3-41c58dde","./ArcType-2d9abbbc","./Transforms-e2d4a55a","./Check-6ede7e26","./ComponentDatatype-cf1fa08e","./EllipsoidTangentPlane-546c0d5e","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./GeometryInstance-34d9e21e","./GeometryOffsetAttribute-9ad0019c","./GeometryPipeline-03bc5709","./IndexDatatype-2643aa47","./Math-0a2ac845","./PolygonGeometryLibrary-d447448d","./PolygonPipeline-460cce4e","./Matrix2-e1298525","./RuntimeError-ef395448","./combine-d9581036","./WebGLConstants-0b1ce7ba","./AxisAlignedBoundingBox-4bfd84f3","./IntersectionTests-85350792","./Plane-4c3d403b","./AttributeCompression-f9f6c717","./EncodedCartesian3-57415c8a","./arrayRemoveDuplicates-d2061e85","./EllipsoidRhumbLine-ef872433"],(function(e,t,i,o,r,n,a,s,l,y,p,d,u,c,f,g,h,m,b,P,E,A,G,_,T,H,C){"use strict";const L=[],v=[];function O(e,t,o,r,p){const d=a.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,L);let c,h;g.PolygonPipeline.computeWindingOrder2D(d)===g.WindingOrder.CLOCKWISE&&(d.reverse(),t=t.slice().reverse());let m=t.length,b=0;if(r)for(c=new Float64Array(2*m*3),h=0;h<m;h++){const e=t[h],i=t[(h+1)%m];c[b++]=e.x,c[b++]=e.y,c[b++]=e.z,c[b++]=i.x,c[b++]=i.y,c[b++]=i.z}else{let r=0;if(p===i.ArcType.GEODESIC)for(h=0;h<m;h++)r+=f.PolygonGeometryLibrary.subdivideLineCount(t[h],t[(h+1)%m],o);else if(p===i.ArcType.RHUMB)for(h=0;h<m;h++)r+=f.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[h],t[(h+1)%m],o);for(c=new Float64Array(3*r),h=0;h<m;h++){let r;p===i.ArcType.GEODESIC?r=f.PolygonGeometryLibrary.subdivideLine(t[h],t[(h+1)%m],o,v):p===i.ArcType.RHUMB&&(r=f.PolygonGeometryLibrary.subdivideRhumbLine(e,t[h],t[(h+1)%m],o,v));const n=r.length;for(let e=0;e<n;++e)c[b++]=r[e]}}m=c.length/3;const P=2*m,E=u.IndexDatatype.createTypedArray(m,P);for(b=0,h=0;h<m-1;h++)E[b++]=h,E[b++]=h+1;return E[b++]=m-1,E[b++]=0,new y.GeometryInstance({geometry:new s.Geometry({attributes:new l.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})}),indices:E,primitiveType:s.PrimitiveType.LINES})})}function D(e,t,o,r,p){const d=a.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,L);let c,h;g.PolygonPipeline.computeWindingOrder2D(d)===g.WindingOrder.CLOCKWISE&&(d.reverse(),t=t.slice().reverse());let m=t.length;const b=new Array(m);let P=0;if(r)for(c=new Float64Array(2*m*3*2),h=0;h<m;++h){b[h]=P/3;const e=t[h],i=t[(h+1)%m];c[P++]=e.x,c[P++]=e.y,c[P++]=e.z,c[P++]=i.x,c[P++]=i.y,c[P++]=i.z}else{let r=0;if(p===i.ArcType.GEODESIC)for(h=0;h<m;h++)r+=f.PolygonGeometryLibrary.subdivideLineCount(t[h],t[(h+1)%m],o);else if(p===i.ArcType.RHUMB)for(h=0;h<m;h++)r+=f.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[h],t[(h+1)%m],o);for(c=new Float64Array(3*r*2),h=0;h<m;++h){let r;b[h]=P/3,p===i.ArcType.GEODESIC?r=f.PolygonGeometryLibrary.subdivideLine(t[h],t[(h+1)%m],o,v):p===i.ArcType.RHUMB&&(r=f.PolygonGeometryLibrary.subdivideRhumbLine(e,t[h],t[(h+1)%m],o,v));const n=r.length;for(let e=0;e<n;++e)c[P++]=r[e]}}m=c.length/6;const E=b.length,A=2*(2*m+E),G=u.IndexDatatype.createTypedArray(m+E,A);for(P=0,h=0;h<m;++h)G[P++]=h,G[P++]=(h+1)%m,G[P++]=h+m,G[P++]=(h+1)%m+m;for(h=0;h<E;h++){const e=b[h];G[P++]=e,G[P++]=e+m}return new y.GeometryInstance({geometry:new s.Geometry({attributes:new l.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})}),indices:G,primitiveType:s.PrimitiveType.LINES})})}function x(o){if(r.Check.typeOf.object("options",o),r.Check.typeOf.object("options.polygonHierarchy",o.polygonHierarchy),o.perPositionHeight&&e.defined(o.height))throw new r.DeveloperError("Cannot use both options.perPositionHeight and options.height");if(e.defined(o.arcType)&&o.arcType!==i.ArcType.GEODESIC&&o.arcType!==i.ArcType.RHUMB)throw new r.DeveloperError("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const n=o.polygonHierarchy,a=e.defaultValue(o.ellipsoid,t.Ellipsoid.WGS84),s=e.defaultValue(o.granularity,c.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(o.perPositionHeight,!1),y=l&&e.defined(o.extrudedHeight),p=e.defaultValue(o.arcType,i.ArcType.GEODESIC);let d=e.defaultValue(o.height,0),u=e.defaultValue(o.extrudedHeight,d);if(!y){const e=Math.max(d,u);u=Math.min(d,u),d=e}this._ellipsoid=t.Ellipsoid.clone(a),this._granularity=s,this._height=d,this._extrudedHeight=u,this._arcType=p,this._polygonHierarchy=n,this._perPositionHeight=l,this._perPositionHeightExtrude=y,this._offsetAttribute=o.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=f.PolygonGeometryLibrary.computeHierarchyPackedLength(n,t.Cartesian3)+t.Ellipsoid.packedLength+8}x.pack=function(i,o,n){return r.Check.typeOf.object("value",i),r.Check.defined("array",o),n=e.defaultValue(n,0),n=f.PolygonGeometryLibrary.packPolygonHierarchy(i._polygonHierarchy,o,n,t.Cartesian3),t.Ellipsoid.pack(i._ellipsoid,o,n),n+=t.Ellipsoid.packedLength,o[n++]=i._height,o[n++]=i._extrudedHeight,o[n++]=i._granularity,o[n++]=i._perPositionHeightExtrude?1:0,o[n++]=i._perPositionHeight?1:0,o[n++]=i._arcType,o[n++]=e.defaultValue(i._offsetAttribute,-1),o[n]=i.packedLength,o};const I=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),w={polygonHierarchy:{}};return x.unpack=function(i,o,n){r.Check.defined("array",i),o=e.defaultValue(o,0);const a=f.PolygonGeometryLibrary.unpackPolygonHierarchy(i,o,t.Cartesian3);o=a.startingIndex,delete a.startingIndex;const s=t.Ellipsoid.unpack(i,o,I);o+=t.Ellipsoid.packedLength;const l=i[o++],y=i[o++],p=i[o++],d=1===i[o++],u=1===i[o++],c=i[o++],g=i[o++],h=i[o];return e.defined(n)||(n=new x(w)),n._polygonHierarchy=a,n._ellipsoid=t.Ellipsoid.clone(s,n._ellipsoid),n._height=l,n._extrudedHeight=y,n._granularity=p,n._perPositionHeight=u,n._perPositionHeightExtrude=d,n._arcType=c,n._offsetAttribute=-1===g?void 0:g,n.packedLength=h,n},x.fromPositions=function(t){return t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT),r.Check.defined("options.positions",t.positions),new x({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,arcType:t.arcType,offsetAttribute:t.offsetAttribute})},x.createGeometry=function(t){const i=t._ellipsoid,r=t._granularity,a=t._polygonHierarchy,l=t._perPositionHeight,y=t._arcType,u=f.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(a,!l,i);if(0===u.length)return;let h;const m=[],b=c.CesiumMath.chordLength(r,i.maximumRadius),P=t._height,E=t._extrudedHeight;let A,G;if(t._perPositionHeightExtrude||!c.CesiumMath.equalsEpsilon(P,E,0,c.CesiumMath.EPSILON2))for(G=0;G<u.length;G++){if(h=D(i,u[G],b,l,y),h.geometry=f.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(h.geometry,P,E,i,l),e.defined(t._offsetAttribute)){const e=h.geometry.attributes.position.values.length/3;let i=new Uint8Array(e);t._offsetAttribute===p.GeometryOffsetAttribute.TOP?i=i.fill(1,0,e/2):(A=t._offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1,i=i.fill(A)),h.geometry.attributes.applyOffset=new s.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}m.push(h)}else for(G=0;G<u.length;G++){if(h=O(i,u[G],b,l,y),h.geometry.attributes.position.values=g.PolygonPipeline.scaleToGeodeticHeight(h.geometry.attributes.position.values,P,i,!l),e.defined(t._offsetAttribute)){const e=h.geometry.attributes.position.values.length;A=t._offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1;const i=new Uint8Array(e/3).fill(A);h.geometry.attributes.applyOffset=new s.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}m.push(h)}const _=d.GeometryPipeline.combineInstances(m)[0],T=o.BoundingSphere.fromVertices(_.attributes.position.values);return new s.Geometry({attributes:_.attributes,indices:_.indices,primitiveType:_.primitiveType,boundingSphere:T,offsetAttribute:t._offsetAttribute})},function(i,o){return e.defined(o)&&(i=x.unpack(i,o)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),x.createGeometry(i)}}));