/*! For license information please see chunk-36ESDRIZ.js.LICENSE.txt */
import{AttributeCompression_default}from"./chunk-I6TVJ6T7.js";import{EncodedCartesian3_default}from"./chunk-VOAZN4IP.js";import{IntersectionTests_default}from"./chunk-HEROVJML.js";import{Plane_default}from"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttribute_default,GeometryType_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default,GeographicProjection_default,Intersect_default}from"./chunk-D4YHO4NZ.js";import{Cartesian2_default,Cartesian4_default,Matrix4_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var scratchCartesian1=new Cartesian3_default,scratchCartesian2=new Cartesian3_default,scratchCartesian3=new Cartesian3_default;function barycentricCoordinates(e,t,a,r,n){let i,o,s,u,l,d,f,c;if(Check_default.defined("point",e),Check_default.defined("p0",t),Check_default.defined("p1",a),Check_default.defined("p2",r),defined_default(n)||(n=new Cartesian3_default),defined_default(t.z)){if(Cartesian3_default.equalsEpsilon(e,t,Math_default.EPSILON14))return Cartesian3_default.clone(Cartesian3_default.UNIT_X,n);if(Cartesian3_default.equalsEpsilon(e,a,Math_default.EPSILON14))return Cartesian3_default.clone(Cartesian3_default.UNIT_Y,n);if(Cartesian3_default.equalsEpsilon(e,r,Math_default.EPSILON14))return Cartesian3_default.clone(Cartesian3_default.UNIT_Z,n);i=Cartesian3_default.subtract(a,t,scratchCartesian1),o=Cartesian3_default.subtract(r,t,scratchCartesian2),s=Cartesian3_default.subtract(e,t,scratchCartesian3),u=Cartesian3_default.dot(i,i),l=Cartesian3_default.dot(i,o),d=Cartesian3_default.dot(i,s),f=Cartesian3_default.dot(o,o),c=Cartesian3_default.dot(o,s)}else{if(Cartesian2_default.equalsEpsilon(e,t,Math_default.EPSILON14))return Cartesian3_default.clone(Cartesian3_default.UNIT_X,n);if(Cartesian2_default.equalsEpsilon(e,a,Math_default.EPSILON14))return Cartesian3_default.clone(Cartesian3_default.UNIT_Y,n);if(Cartesian2_default.equalsEpsilon(e,r,Math_default.EPSILON14))return Cartesian3_default.clone(Cartesian3_default.UNIT_Z,n);i=Cartesian2_default.subtract(a,t,scratchCartesian1),o=Cartesian2_default.subtract(r,t,scratchCartesian2),s=Cartesian2_default.subtract(e,t,scratchCartesian3),u=Cartesian2_default.dot(i,i),l=Cartesian2_default.dot(i,o),d=Cartesian2_default.dot(i,s),f=Cartesian2_default.dot(o,o),c=Cartesian2_default.dot(o,s)}n.y=f*d-l*c,n.z=u*c-l*d;const p=u*f-l*l;if(0!==p)return n.y/=p,n.z/=p,n.x=1-n.y-n.z,n}var barycentricCoordinates_default=barycentricCoordinates,Tipsify={calculateACMR:function(e){const t=(e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT)).indices;let a=e.maximumIndex;const r=defaultValue_default(e.cacheSize,24);if(!defined_default(t))throw new DeveloperError_default("indices is required.");const n=t.length;if(n<3||n%3!=0)throw new DeveloperError_default("indices length must be a multiple of three.");if(a<=0)throw new DeveloperError_default("maximumIndex must be greater than zero.");if(r<3)throw new DeveloperError_default("cacheSize must be greater than two.");if(!defined_default(a)){a=0;let e=0,r=t[e];for(;e<n;)r>a&&(a=r),++e,r=t[e]}const i=[];for(let e=0;e<a+1;e++)i[e]=0;let o=r+1;for(let e=0;e<n;++e)o-i[t[e]]>r&&(i[t[e]]=o,++o);return(o-r+1)/(n/3)},tipsify:function(e){const t=(e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT)).indices,a=e.maximumIndex,r=defaultValue_default(e.cacheSize,24);let n;function i(e,t,a,r,i,o,s){let u,l=-1,d=-1,f=0;for(;f<a.length;){const e=a[f];r[e].numLiveTriangles&&(u=0,i-r[e].timeStamp+2*r[e].numLiveTriangles<=t&&(u=i-r[e].timeStamp),(u>d||-1===d)&&(d=u,l=e)),++f}return-1===l?function(e,t,a,r){for(;t.length>=1;){const a=t[t.length-1];if(t.splice(t.length-1,1),e[a].numLiveTriangles>0)return a}for(;n<r;){if(e[n].numLiveTriangles>0)return++n,n-1;++n}return-1}(r,o,0,s):l}if(!defined_default(t))throw new DeveloperError_default("indices is required.");const o=t.length;if(o<3||o%3!=0)throw new DeveloperError_default("indices length must be a multiple of three.");if(a<=0)throw new DeveloperError_default("maximumIndex must be greater than zero.");if(r<3)throw new DeveloperError_default("cacheSize must be greater than two.");let s=0,u=0,l=t[u];const d=o;if(defined_default(a))s=a+1;else{for(;u<d;)l>s&&(s=l),++u,l=t[u];if(-1===s)return 0;++s}const f=[];let c;for(c=0;c<s;c++)f[c]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};u=0;let p=0;for(;u<d;)f[t[u]].vertexTriangles.push(p),++f[t[u]].numLiveTriangles,f[t[u+1]].vertexTriangles.push(p),++f[t[u+1]].numLiveTriangles,f[t[u+2]].vertexTriangles.push(p),++f[t[u+2]].numLiveTriangles,++p,u+=3;let _=0,m=r+1;n=1;let y=[];const h=[];let v,C,g=0;const b=[],T=o/3,w=[];for(c=0;c<T;c++)w[c]=!1;let P,A;for(;-1!==_;){y=[],C=f[_],A=C.vertexTriangles.length;for(let e=0;e<A;++e)if(p=C.vertexTriangles[e],!w[p]){w[p]=!0,u=p+p+p;for(let e=0;e<3;++e)P=t[u],y.push(P),h.push(P),b[g]=P,++g,v=f[P],--v.numLiveTriangles,m-v.timeStamp>r&&(v.timeStamp=m,++m),++u}_=i(0,r,y,f,m,h,s)}return b}},Tipsify_default=Tipsify,GeometryPipeline={};function addTriangle(e,t,a,r,n){e[t++]=a,e[t++]=r,e[t++]=r,e[t++]=n,e[t++]=n,e[t]=a}function trianglesToLines(e){const t=e.length,a=t/3*6,r=IndexDatatype_default.createTypedArray(t,a);let n=0;for(let a=0;a<t;a+=3,n+=6)addTriangle(r,n,e[a],e[a+1],e[a+2]);return r}function triangleStripToLines(e){const t=e.length;if(t>=3){const a=6*(t-2),r=IndexDatatype_default.createTypedArray(t,a);addTriangle(r,0,e[0],e[1],e[2]);let n=6;for(let a=3;a<t;++a,n+=6)addTriangle(r,n,e[a-1],e[a],e[a-2]);return r}return new Uint16Array}function triangleFanToLines(e){if(e.length>0){const t=e.length-1,a=6*(t-1),r=IndexDatatype_default.createTypedArray(t,a),n=e[0];let i=0;for(let a=1;a<t;++a,i+=6)addTriangle(r,i,n,e[a],e[a+1]);return r}return new Uint16Array}function copyAttributesDescriptions(e){const t={};for(const a in e)if(e.hasOwnProperty(a)&&defined_default(e[a])&&defined_default(e[a].values)){const r=e[a];t[a]=new GeometryAttribute_default({componentDatatype:r.componentDatatype,componentsPerAttribute:r.componentsPerAttribute,normalize:r.normalize,values:[]})}return t}function copyVertex(e,t,a){for(const r in t)if(t.hasOwnProperty(r)&&defined_default(t[r])&&defined_default(t[r].values)){const n=t[r];for(let t=0;t<n.componentsPerAttribute;++t)e[r].values.push(n.values[a*n.componentsPerAttribute+t])}}GeometryPipeline.toWireframe=function(e){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");const t=e.indices;if(defined_default(t)){switch(e.primitiveType){case PrimitiveType_default.TRIANGLES:e.indices=trianglesToLines(t);break;case PrimitiveType_default.TRIANGLE_STRIP:e.indices=triangleStripToLines(t);break;case PrimitiveType_default.TRIANGLE_FAN:e.indices=triangleFanToLines(t);break;default:throw new DeveloperError_default("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=PrimitiveType_default.LINES}return e},GeometryPipeline.createLineSegmentsForVectors=function(e,t,a){if(t=defaultValue_default(t,"normal"),!defined_default(e))throw new DeveloperError_default("geometry is required.");if(!defined_default(e.attributes.position))throw new DeveloperError_default("geometry.attributes.position is required.");if(!defined_default(e.attributes[t]))throw new DeveloperError_default(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${t}.`);a=defaultValue_default(a,1e4);const r=e.attributes.position.values,n=e.attributes[t].values,i=r.length,o=new Float64Array(2*i);let s,u=0;for(let e=0;e<i;e+=3)o[u++]=r[e],o[u++]=r[e+1],o[u++]=r[e+2],o[u++]=r[e]+n[e]*a,o[u++]=r[e+1]+n[e+1]*a,o[u++]=r[e+2]+n[e+2]*a;const l=e.boundingSphere;return defined_default(l)&&(s=new BoundingSphere_default(l.center,l.radius+a)),new Geometry_default({attributes:{position:new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:o})},primitiveType:PrimitiveType_default.LINES,boundingSphere:s})},GeometryPipeline.createAttributeLocations=function(e){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],a=e.attributes,r={};let n,i=0;const o=t.length;for(n=0;n<o;++n){const e=t[n];defined_default(a[e])&&(r[e]=i++)}for(const e in a)a.hasOwnProperty(e)&&!defined_default(r[e])&&(r[e]=i++);return r},GeometryPipeline.reorderForPreVertexCache=function(e){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");const t=Geometry_default.computeNumberOfVertices(e),a=e.indices;if(defined_default(a)){const r=new Int32Array(t);for(let e=0;e<t;e++)r[e]=-1;const n=a,i=n.length,o=IndexDatatype_default.createTypedArray(t,i);let s,u=0,l=0,d=0;for(;u<i;)s=r[n[u]],-1!==s?o[l]=s:(s=n[u],r[s]=d,o[l]=d,++d),++u,++l;e.indices=o;const f=e.attributes;for(const e in f)if(f.hasOwnProperty(e)&&defined_default(f[e])&&defined_default(f[e].values)){const a=f[e],n=a.values;let i=0;const o=a.componentsPerAttribute,s=ComponentDatatype_default.createTypedArray(a.componentDatatype,d*o);for(;i<t;){const e=r[i];if(-1!==e)for(let t=0;t<o;t++)s[o*e+t]=n[o*i+t];++i}a.values=s}}return e},GeometryPipeline.reorderForPostVertexCache=function(e,t){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");const a=e.indices;if(e.primitiveType===PrimitiveType_default.TRIANGLES&&defined_default(a)){const r=a.length;let n=0;for(let e=0;e<r;e++)a[e]>n&&(n=a[e]);e.indices=Tipsify_default.tipsify({indices:a,maximumIndex:n,cacheSize:t})}return e},GeometryPipeline.fitToUnsignedShortIndices=function(e){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");if(defined_default(e.indices)&&e.primitiveType!==PrimitiveType_default.TRIANGLES&&e.primitiveType!==PrimitiveType_default.LINES&&e.primitiveType!==PrimitiveType_default.POINTS)throw new DeveloperError_default("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");const t=[],a=Geometry_default.computeNumberOfVertices(e);if(defined_default(e.indices)&&a>=Math_default.SIXTY_FOUR_KILOBYTES){let a=[],r=[],n=0,i=copyAttributesDescriptions(e.attributes);const o=e.indices,s=o.length;let u;e.primitiveType===PrimitiveType_default.TRIANGLES?u=3:e.primitiveType===PrimitiveType_default.LINES?u=2:e.primitiveType===PrimitiveType_default.POINTS&&(u=1);for(let l=0;l<s;l+=u){for(let t=0;t<u;++t){const s=o[l+t];let u=a[s];defined_default(u)||(u=n++,a[s]=u,copyVertex(i,e.attributes,s)),r.push(u)}n+u>=Math_default.SIXTY_FOUR_KILOBYTES&&(t.push(new Geometry_default({attributes:i,indices:r,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),a=[],r=[],n=0,i=copyAttributesDescriptions(e.attributes))}0!==r.length&&t.push(new Geometry_default({attributes:i,indices:r,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};var scratchProjectTo2DCartesian3=new Cartesian3_default,scratchProjectTo2DCartographic=new Cartographic_default;GeometryPipeline.projectTo2D=function(e,t,a,r,n){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");if(!defined_default(t))throw new DeveloperError_default("attributeName is required.");if(!defined_default(a))throw new DeveloperError_default("attributeName3D is required.");if(!defined_default(r))throw new DeveloperError_default("attributeName2D is required.");if(!defined_default(e.attributes[t]))throw new DeveloperError_default(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==ComponentDatatype_default.DOUBLE)throw new DeveloperError_default("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const i=e.attributes[t],o=(n=defined_default(n)?n:new GeographicProjection_default).ellipsoid,s=i.values,u=new Float64Array(s.length);let l=0;for(let e=0;e<s.length;e+=3){const t=Cartesian3_default.fromArray(s,e,scratchProjectTo2DCartesian3),a=o.cartesianToCartographic(t,scratchProjectTo2DCartographic);if(!defined_default(a))throw new DeveloperError_default(`Could not project point (${t.x}, ${t.y}, ${t.z}) to 2D.`);const r=n.project(a,scratchProjectTo2DCartesian3);u[l++]=r.x,u[l++]=r.y,u[l++]=r.z}return e.attributes[a]=i,e.attributes[r]=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:u}),delete e.attributes[t],e};var encodedResult={high:0,low:0};GeometryPipeline.encodeAttribute=function(e,t,a,r){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");if(!defined_default(t))throw new DeveloperError_default("attributeName is required.");if(!defined_default(a))throw new DeveloperError_default("attributeHighName is required.");if(!defined_default(r))throw new DeveloperError_default("attributeLowName is required.");if(!defined_default(e.attributes[t]))throw new DeveloperError_default(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==ComponentDatatype_default.DOUBLE)throw new DeveloperError_default("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const n=e.attributes[t],i=n.values,o=i.length,s=new Float32Array(o),u=new Float32Array(o);for(let e=0;e<o;++e)EncodedCartesian3_default.encode(i[e],encodedResult),s[e]=encodedResult.high,u[e]=encodedResult.low;const l=n.componentsPerAttribute;return e.attributes[a]=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:l,values:s}),e.attributes[r]=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:l,values:u}),delete e.attributes[t],e};var scratchCartesian32=new Cartesian3_default;function transformPoint(e,t){if(defined_default(t)){const a=t.values,r=a.length;for(let t=0;t<r;t+=3)Cartesian3_default.unpack(a,t,scratchCartesian32),Matrix4_default.multiplyByPoint(e,scratchCartesian32,scratchCartesian32),Cartesian3_default.pack(scratchCartesian32,a,t)}}function transformVector(e,t){if(defined_default(t)){const a=t.values,r=a.length;for(let t=0;t<r;t+=3)Cartesian3_default.unpack(a,t,scratchCartesian32),Matrix3_default.multiplyByVector(e,scratchCartesian32,scratchCartesian32),scratchCartesian32=Cartesian3_default.normalize(scratchCartesian32,scratchCartesian32),Cartesian3_default.pack(scratchCartesian32,a,t)}}var inverseTranspose=new Matrix4_default,normalMatrix=new Matrix3_default;function findAttributesInAllGeometries(e,t){const a=e.length,r={},n=e[0][t].attributes;let i;for(i in n)if(n.hasOwnProperty(i)&&defined_default(n[i])&&defined_default(n[i].values)){const o=n[i];let s=o.values.length,u=!0;for(let r=1;r<a;++r){const a=e[r][t].attributes[i];if(!defined_default(a)||o.componentDatatype!==a.componentDatatype||o.componentsPerAttribute!==a.componentsPerAttribute||o.normalize!==a.normalize){u=!1;break}s+=a.values.length}u&&(r[i]=new GeometryAttribute_default({componentDatatype:o.componentDatatype,componentsPerAttribute:o.componentsPerAttribute,normalize:o.normalize,values:ComponentDatatype_default.createTypedArray(o.componentDatatype,s)}))}return r}GeometryPipeline.transformToWorldCoordinates=function(e){if(!defined_default(e))throw new DeveloperError_default("instance is required.");const t=e.modelMatrix;if(Matrix4_default.equals(t,Matrix4_default.IDENTITY))return e;const a=e.geometry.attributes;transformPoint(t,a.position),transformPoint(t,a.prevPosition),transformPoint(t,a.nextPosition),(defined_default(a.normal)||defined_default(a.tangent)||defined_default(a.bitangent))&&(Matrix4_default.inverse(t,inverseTranspose),Matrix4_default.transpose(inverseTranspose,inverseTranspose),Matrix4_default.getMatrix3(inverseTranspose,normalMatrix),transformVector(normalMatrix,a.normal),transformVector(normalMatrix,a.tangent),transformVector(normalMatrix,a.bitangent));const r=e.geometry.boundingSphere;return defined_default(r)&&(e.geometry.boundingSphere=BoundingSphere_default.transform(r,t,r)),e.modelMatrix=Matrix4_default.clone(Matrix4_default.IDENTITY),e};var tempScratch=new Cartesian3_default;function combineGeometries(e,t){const a=e.length;let r,n,i,o;const s=e[0].modelMatrix,u=defined_default(e[0][t].indices),l=e[0][t].primitiveType;for(n=1;n<a;++n){if(!Matrix4_default.equals(e[n].modelMatrix,s))throw new DeveloperError_default("All instances must have the same modelMatrix.");if(defined_default(e[n][t].indices)!==u)throw new DeveloperError_default("All instance geometries must have an indices or not have one.");if(e[n][t].primitiveType!==l)throw new DeveloperError_default("All instance geometries must have the same primitiveType.")}const d=findAttributesInAllGeometries(e,t);let f,c,p,_;for(r in d)if(d.hasOwnProperty(r))for(f=d[r].values,o=0,n=0;n<a;++n)for(c=e[n][t].attributes[r].values,p=c.length,i=0;i<p;++i)f[o++]=c[i];if(u){let r=0;for(n=0;n<a;++n)r+=e[n][t].indices.length;const i=Geometry_default.computeNumberOfVertices(new Geometry_default({attributes:d,primitiveType:PrimitiveType_default.POINTS})),s=IndexDatatype_default.createTypedArray(i,r);let u=0,l=0;for(n=0;n<a;++n){const a=e[n][t].indices,r=a.length;for(o=0;o<r;++o)s[u++]=l+a[o];l+=Geometry_default.computeNumberOfVertices(e[n][t])}_=s}let m,y=new Cartesian3_default,h=0;for(n=0;n<a;++n){if(m=e[n][t].boundingSphere,!defined_default(m)){y=void 0;break}Cartesian3_default.add(m.center,y,y)}if(defined_default(y))for(Cartesian3_default.divideByScalar(y,a,y),n=0;n<a;++n){m=e[n][t].boundingSphere;const a=Cartesian3_default.magnitude(Cartesian3_default.subtract(m.center,y,tempScratch))+m.radius;a>h&&(h=a)}return new Geometry_default({attributes:d,indices:_,primitiveType:l,boundingSphere:defined_default(y)?new BoundingSphere_default(y,h):void 0})}GeometryPipeline.combineInstances=function(e){if(!defined_default(e)||e.length<1)throw new DeveloperError_default("instances is required and must have length greater than zero.");const t=[],a=[],r=e.length;for(let n=0;n<r;++n){const r=e[n];defined_default(r.geometry)?t.push(r):defined_default(r.westHemisphereGeometry)&&defined_default(r.eastHemisphereGeometry)&&a.push(r)}const n=[];return t.length>0&&n.push(combineGeometries(t,"geometry")),a.length>0&&(n.push(combineGeometries(a,"westHemisphereGeometry")),n.push(combineGeometries(a,"eastHemisphereGeometry"))),n};var normal=new Cartesian3_default,v0=new Cartesian3_default,v1=new Cartesian3_default,v2=new Cartesian3_default;GeometryPipeline.computeNormal=function(e){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");if(!defined_default(e.attributes.position)||!defined_default(e.attributes.position.values))throw new DeveloperError_default("geometry.attributes.position.values is required.");if(!defined_default(e.indices))throw new DeveloperError_default("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!=0)throw new DeveloperError_default("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==PrimitiveType_default.TRIANGLES)throw new DeveloperError_default("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const t=e.indices,a=e.attributes,r=a.position.values,n=a.position.values.length/3,i=t.length,o=new Array(n),s=new Array(i/3),u=new Array(i);let l;for(l=0;l<n;l++)o[l]={indexOffset:0,count:0,currentCount:0};let d=0;for(l=0;l<i;l+=3){const e=t[l],a=t[l+1],n=t[l+2],i=3*e,u=3*a,f=3*n;v0.x=r[i],v0.y=r[i+1],v0.z=r[i+2],v1.x=r[u],v1.y=r[u+1],v1.z=r[u+2],v2.x=r[f],v2.y=r[f+1],v2.z=r[f+2],o[e].count++,o[a].count++,o[n].count++,Cartesian3_default.subtract(v1,v0,v1),Cartesian3_default.subtract(v2,v0,v2),s[d]=Cartesian3_default.cross(v1,v2,new Cartesian3_default),d++}let f,c=0;for(l=0;l<n;l++)o[l].indexOffset+=c,c+=o[l].count;for(d=0,l=0;l<i;l+=3){f=o[t[l]];let e=f.indexOffset+f.currentCount;u[e]=d,f.currentCount++,f=o[t[l+1]],e=f.indexOffset+f.currentCount,u[e]=d,f.currentCount++,f=o[t[l+2]],e=f.indexOffset+f.currentCount,u[e]=d,f.currentCount++,d++}const p=new Float32Array(3*n);for(l=0;l<n;l++){const e=3*l;if(f=o[l],Cartesian3_default.clone(Cartesian3_default.ZERO,normal),f.count>0){for(d=0;d<f.count;d++)Cartesian3_default.add(normal,s[u[f.indexOffset+d]],normal);Cartesian3_default.equalsEpsilon(Cartesian3_default.ZERO,normal,Math_default.EPSILON10)&&Cartesian3_default.clone(s[u[f.indexOffset]],normal)}Cartesian3_default.equalsEpsilon(Cartesian3_default.ZERO,normal,Math_default.EPSILON10)&&(normal.z=1),Cartesian3_default.normalize(normal,normal),p[e]=normal.x,p[e+1]=normal.y,p[e+2]=normal.z}return e.attributes.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:p}),e};var normalScratch=new Cartesian3_default,normalScale=new Cartesian3_default,tScratch=new Cartesian3_default;GeometryPipeline.computeTangentAndBitangent=function(e){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");const t=e.attributes,a=e.indices;if(!defined_default(t.position)||!defined_default(t.position.values))throw new DeveloperError_default("geometry.attributes.position.values is required.");if(!defined_default(t.normal)||!defined_default(t.normal.values))throw new DeveloperError_default("geometry.attributes.normal.values is required.");if(!defined_default(t.st)||!defined_default(t.st.values))throw new DeveloperError_default("geometry.attributes.st.values is required.");if(!defined_default(a))throw new DeveloperError_default("geometry.indices is required.");if(a.length<2||a.length%3!=0)throw new DeveloperError_default("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==PrimitiveType_default.TRIANGLES)throw new DeveloperError_default("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const r=e.attributes.position.values,n=e.attributes.normal.values,i=e.attributes.st.values,o=e.attributes.position.values.length/3,s=a.length,u=new Array(3*o);let l,d,f,c;for(l=0;l<u.length;l++)u[l]=0;for(l=0;l<s;l+=3){const e=a[l],t=a[l+1],n=a[l+2];d=3*e,f=3*t,c=3*n;const o=2*e,s=2*t,p=2*n,_=r[d],m=r[d+1],y=r[d+2],h=i[o],v=i[o+1],C=i[s+1]-v,g=i[p+1]-v,b=1/((i[s]-h)*g-(i[p]-h)*C),T=(g*(r[f]-_)-C*(r[c]-_))*b,w=(g*(r[f+1]-m)-C*(r[c+1]-m))*b,P=(g*(r[f+2]-y)-C*(r[c+2]-y))*b;u[d]+=T,u[d+1]+=w,u[d+2]+=P,u[f]+=T,u[f+1]+=w,u[f+2]+=P,u[c]+=T,u[c+1]+=w,u[c+2]+=P}const p=new Float32Array(3*o),_=new Float32Array(3*o);for(l=0;l<o;l++){d=3*l,f=d+1,c=d+2;const e=Cartesian3_default.fromArray(n,d,normalScratch),t=Cartesian3_default.fromArray(u,d,tScratch),a=Cartesian3_default.dot(e,t);Cartesian3_default.multiplyByScalar(e,a,normalScale),Cartesian3_default.normalize(Cartesian3_default.subtract(t,normalScale,t),t),p[d]=t.x,p[f]=t.y,p[c]=t.z,Cartesian3_default.normalize(Cartesian3_default.cross(e,t,t),t),_[d]=t.x,_[f]=t.y,_[c]=t.z}return e.attributes.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:p}),e.attributes.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:_}),e};var scratchCartesian22=new Cartesian2_default,toEncode1=new Cartesian3_default,toEncode2=new Cartesian3_default,toEncode3=new Cartesian3_default,encodeResult2=new Cartesian2_default;function indexTriangles(e){if(defined_default(e.indices))return e;const t=Geometry_default.computeNumberOfVertices(e);if(t<3)throw new DeveloperError_default("The number of vertices must be at least three.");if(t%3!=0)throw new DeveloperError_default("The number of vertices must be a multiple of three.");const a=IndexDatatype_default.createTypedArray(t,t);for(let e=0;e<t;++e)a[e]=e;return e.indices=a,e}function indexTriangleFan(e){const t=Geometry_default.computeNumberOfVertices(e);if(t<3)throw new DeveloperError_default("The number of vertices must be at least three.");const a=IndexDatatype_default.createTypedArray(t,3*(t-2));a[0]=1,a[1]=0,a[2]=2;let r=3;for(let e=3;e<t;++e)a[r++]=e-1,a[r++]=0,a[r++]=e;return e.indices=a,e.primitiveType=PrimitiveType_default.TRIANGLES,e}function indexTriangleStrip(e){const t=Geometry_default.computeNumberOfVertices(e);if(t<3)throw new DeveloperError_default("The number of vertices must be at least 3.");const a=IndexDatatype_default.createTypedArray(t,3*(t-2));a[0]=0,a[1]=1,a[2]=2,t>3&&(a[3]=0,a[4]=2,a[5]=3);let r=6;for(let e=3;e<t-1;e+=2)a[r++]=e,a[r++]=e-1,a[r++]=e+1,e+2<t&&(a[r++]=e,a[r++]=e+1,a[r++]=e+2);return e.indices=a,e.primitiveType=PrimitiveType_default.TRIANGLES,e}function indexLines(e){if(defined_default(e.indices))return e;const t=Geometry_default.computeNumberOfVertices(e);if(t<2)throw new DeveloperError_default("The number of vertices must be at least two.");if(t%2!=0)throw new DeveloperError_default("The number of vertices must be a multiple of 2.");const a=IndexDatatype_default.createTypedArray(t,t);for(let e=0;e<t;++e)a[e]=e;return e.indices=a,e}function indexLineStrip(e){const t=Geometry_default.computeNumberOfVertices(e);if(t<2)throw new DeveloperError_default("The number of vertices must be at least two.");const a=IndexDatatype_default.createTypedArray(t,2*(t-1));a[0]=0,a[1]=1;let r=2;for(let e=2;e<t;++e)a[r++]=e-1,a[r++]=e;return e.indices=a,e.primitiveType=PrimitiveType_default.LINES,e}function indexLineLoop(e){const t=Geometry_default.computeNumberOfVertices(e);if(t<2)throw new DeveloperError_default("The number of vertices must be at least two.");const a=IndexDatatype_default.createTypedArray(t,2*t);a[0]=0,a[1]=1;let r=2;for(let e=2;e<t;++e)a[r++]=e-1,a[r++]=e;return a[r++]=t-1,a[r]=0,e.indices=a,e.primitiveType=PrimitiveType_default.LINES,e}function indexPrimitive(e){switch(e.primitiveType){case PrimitiveType_default.TRIANGLE_FAN:return indexTriangleFan(e);case PrimitiveType_default.TRIANGLE_STRIP:return indexTriangleStrip(e);case PrimitiveType_default.TRIANGLES:return indexTriangles(e);case PrimitiveType_default.LINE_STRIP:return indexLineStrip(e);case PrimitiveType_default.LINE_LOOP:return indexLineLoop(e);case PrimitiveType_default.LINES:return indexLines(e)}return e}function offsetPointFromXZPlane(e,t){Math.abs(e.y)<Math_default.EPSILON6&&(e.y=t?-Math_default.EPSILON6:Math_default.EPSILON6)}function offsetTriangleFromXZPlane(e,t,a){if(0!==e.y&&0!==t.y&&0!==a.y)return offsetPointFromXZPlane(e,e.y<0),offsetPointFromXZPlane(t,t.y<0),void offsetPointFromXZPlane(a,a.y<0);const r=Math.abs(e.y),n=Math.abs(t.y),i=Math.abs(a.y);let o;o=r>n?r>i?Math_default.sign(e.y):Math_default.sign(a.y):n>i?Math_default.sign(t.y):Math_default.sign(a.y);const s=o<0;offsetPointFromXZPlane(e,s),offsetPointFromXZPlane(t,s),offsetPointFromXZPlane(a,s)}GeometryPipeline.compressVertices=function(e){if(!defined_default(e))throw new DeveloperError_default("geometry is required.");const t=e.attributes.extrudeDirection;let a,r;if(defined_default(t)){const n=t.values;r=n.length/3;const i=new Float32Array(2*r);let o=0;for(a=0;a<r;++a)Cartesian3_default.fromArray(n,3*a,toEncode1),Cartesian3_default.equals(toEncode1,Cartesian3_default.ZERO)?o+=2:(encodeResult2=AttributeCompression_default.octEncodeInRange(toEncode1,65535,encodeResult2),i[o++]=encodeResult2.x,i[o++]=encodeResult2.y);return e.attributes.compressedAttributes=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:i}),delete e.attributes.extrudeDirection,e}const n=e.attributes.normal,i=e.attributes.st,o=defined_default(n),s=defined_default(i);if(!o&&!s)return e;const u=e.attributes.tangent,l=e.attributes.bitangent,d=defined_default(u),f=defined_default(l);let c,p,_,m;o&&(c=n.values),s&&(p=i.values),d&&(_=u.values),f&&(m=l.values),r=(o?c.length:p.length)/(o?3:2);let y=r,h=s&&o?2:1;h+=d||f?1:0,y*=h;const v=new Float32Array(y);let C=0;for(a=0;a<r;++a){s&&(Cartesian2_default.fromArray(p,2*a,scratchCartesian22),v[C++]=AttributeCompression_default.compressTextureCoordinates(scratchCartesian22));const e=3*a;o&&defined_default(_)&&defined_default(m)?(Cartesian3_default.fromArray(c,e,toEncode1),Cartesian3_default.fromArray(_,e,toEncode2),Cartesian3_default.fromArray(m,e,toEncode3),AttributeCompression_default.octPack(toEncode1,toEncode2,toEncode3,scratchCartesian22),v[C++]=scratchCartesian22.x,v[C++]=scratchCartesian22.y):(o&&(Cartesian3_default.fromArray(c,e,toEncode1),v[C++]=AttributeCompression_default.octEncodeFloat(toEncode1)),d&&(Cartesian3_default.fromArray(_,e,toEncode1),v[C++]=AttributeCompression_default.octEncodeFloat(toEncode1)),f&&(Cartesian3_default.fromArray(m,e,toEncode1),v[C++]=AttributeCompression_default.octEncodeFloat(toEncode1)))}return e.attributes.compressedAttributes=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:h,values:v}),o&&delete e.attributes.normal,s&&delete e.attributes.st,f&&delete e.attributes.bitangent,d&&delete e.attributes.tangent,e};var c3=new Cartesian3_default;function getXZIntersectionOffsetPoints(e,t,a,r){Cartesian3_default.add(e,Cartesian3_default.multiplyByScalar(Cartesian3_default.subtract(t,e,c3),e.y/(e.y-t.y),c3),a),Cartesian3_default.clone(a,r),offsetPointFromXZPlane(a,!0),offsetPointFromXZPlane(r,!1)}var u1=new Cartesian3_default,u2=new Cartesian3_default,q1=new Cartesian3_default,q2=new Cartesian3_default,splitTriangleResult={positions:new Array(7),indices:new Array(9)};function splitTriangle(e,t,a){if(e.x>=0||t.x>=0||a.x>=0)return;offsetTriangleFromXZPlane(e,t,a);const r=e.y<0,n=t.y<0,i=a.y<0;let o=0;o+=r?1:0,o+=n?1:0,o+=i?1:0;const s=splitTriangleResult.indices;1===o?(s[1]=3,s[2]=4,s[5]=6,s[7]=6,s[8]=5,r?(getXZIntersectionOffsetPoints(e,t,u1,q1),getXZIntersectionOffsetPoints(e,a,u2,q2),s[0]=0,s[3]=1,s[4]=2,s[6]=1):n?(getXZIntersectionOffsetPoints(t,a,u1,q1),getXZIntersectionOffsetPoints(t,e,u2,q2),s[0]=1,s[3]=2,s[4]=0,s[6]=2):i&&(getXZIntersectionOffsetPoints(a,e,u1,q1),getXZIntersectionOffsetPoints(a,t,u2,q2),s[0]=2,s[3]=0,s[4]=1,s[6]=0)):2===o&&(s[2]=4,s[4]=4,s[5]=3,s[7]=5,s[8]=6,r?n?i||(getXZIntersectionOffsetPoints(a,e,u1,q1),getXZIntersectionOffsetPoints(a,t,u2,q2),s[0]=0,s[1]=1,s[3]=0,s[6]=2):(getXZIntersectionOffsetPoints(t,a,u1,q1),getXZIntersectionOffsetPoints(t,e,u2,q2),s[0]=2,s[1]=0,s[3]=2,s[6]=1):(getXZIntersectionOffsetPoints(e,t,u1,q1),getXZIntersectionOffsetPoints(e,a,u2,q2),s[0]=1,s[1]=2,s[3]=1,s[6]=0));const u=splitTriangleResult.positions;return u[0]=e,u[1]=t,u[2]=a,u.length=3,1!==o&&2!==o||(u[3]=u1,u[4]=u2,u[5]=q1,u[6]=q2,u.length=7),splitTriangleResult}function updateGeometryAfterSplit(e,t){const a=e.attributes;if(0===a.position.values.length)return;for(const e in a)if(a.hasOwnProperty(e)&&defined_default(a[e])&&defined_default(a[e].values)){const t=a[e];t.values=ComponentDatatype_default.createTypedArray(t.componentDatatype,t.values)}const r=Geometry_default.computeNumberOfVertices(e);return e.indices=IndexDatatype_default.createTypedArray(r,e.indices),t&&(e.boundingSphere=BoundingSphere_default.fromVertices(a.position.values)),e}function copyGeometryForSplit(e){const t=e.attributes,a={};for(const e in t)if(t.hasOwnProperty(e)&&defined_default(t[e])&&defined_default(t[e].values)){const r=t[e];a[e]=new GeometryAttribute_default({componentDatatype:r.componentDatatype,componentsPerAttribute:r.componentsPerAttribute,normalize:r.normalize,values:[]})}return new Geometry_default({attributes:a,indices:[],primitiveType:e.primitiveType})}function updateInstanceAfterSplit(e,t,a){const r=defined_default(e.geometry.boundingSphere);t=updateGeometryAfterSplit(t,r),a=updateGeometryAfterSplit(a,r),defined_default(a)&&!defined_default(t)?e.geometry=a:!defined_default(a)&&defined_default(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=a,e.geometry=void 0)}function generateBarycentricInterpolateFunction(e,t){const a=new e,r=new e,n=new e;return function(i,o,s,u,l,d,f,c){const p=e.fromArray(l,i*t,a),_=e.fromArray(l,o*t,r),m=e.fromArray(l,s*t,n);e.multiplyByScalar(p,u.x,p),e.multiplyByScalar(_,u.y,_),e.multiplyByScalar(m,u.z,m);const y=e.add(p,_,p);e.add(y,m,y),c&&e.normalize(y,y),e.pack(y,d,f*t)}}var interpolateAndPackCartesian4=generateBarycentricInterpolateFunction(Cartesian4_default,4),interpolateAndPackCartesian3=generateBarycentricInterpolateFunction(Cartesian3_default,3),interpolateAndPackCartesian2=generateBarycentricInterpolateFunction(Cartesian2_default,2),interpolateAndPackBoolean=function(e,t,a,r,n,i,o){const s=n[e]*r.x,u=n[t]*r.y,l=n[a]*r.z;i[o]=s+u+l>Math_default.EPSILON6?1:0},p0Scratch=new Cartesian3_default,p1Scratch=new Cartesian3_default,p2Scratch=new Cartesian3_default,barycentricScratch=new Cartesian3_default;function computeTriangleAttributes(e,t,a,r,n,i,o,s,u,l,d,f,c,p,_,m){if(!(defined_default(i)||defined_default(o)||defined_default(s)||defined_default(u)||defined_default(l)||0!==p))return;const y=Cartesian3_default.fromArray(n,3*e,p0Scratch),h=Cartesian3_default.fromArray(n,3*t,p1Scratch),v=Cartesian3_default.fromArray(n,3*a,p2Scratch),C=barycentricCoordinates_default(r,y,h,v,barycentricScratch);if(defined_default(C)){if(defined_default(i)&&interpolateAndPackCartesian3(e,t,a,C,i,f.normal.values,m,!0),defined_default(l)){const r=Cartesian3_default.fromArray(l,3*e,p0Scratch),n=Cartesian3_default.fromArray(l,3*t,p1Scratch),i=Cartesian3_default.fromArray(l,3*a,p2Scratch);let o;Cartesian3_default.multiplyByScalar(r,C.x,r),Cartesian3_default.multiplyByScalar(n,C.y,n),Cartesian3_default.multiplyByScalar(i,C.z,i),Cartesian3_default.equals(r,Cartesian3_default.ZERO)&&Cartesian3_default.equals(n,Cartesian3_default.ZERO)&&Cartesian3_default.equals(i,Cartesian3_default.ZERO)?(o=p0Scratch,o.x=0,o.y=0,o.z=0):(o=Cartesian3_default.add(r,n,r),Cartesian3_default.add(o,i,o),Cartesian3_default.normalize(o,o)),Cartesian3_default.pack(o,f.extrudeDirection.values,3*m)}if(defined_default(d)&&interpolateAndPackBoolean(e,t,a,C,d,f.applyOffset.values,m),defined_default(o)&&interpolateAndPackCartesian3(e,t,a,C,o,f.tangent.values,m,!0),defined_default(s)&&interpolateAndPackCartesian3(e,t,a,C,s,f.bitangent.values,m,!0),defined_default(u)&&interpolateAndPackCartesian2(e,t,a,C,u,f.st.values,m),p>0)for(let r=0;r<p;r++){const n=c[r];genericInterpolate(e,t,a,C,m,_[n],f[n])}}}function genericInterpolate(e,t,a,r,n,i,o){const s=i.componentsPerAttribute,u=i.values,l=o.values;switch(s){case 4:interpolateAndPackCartesian4(e,t,a,r,u,l,n,!1);break;case 3:interpolateAndPackCartesian3(e,t,a,r,u,l,n,!1);break;case 2:interpolateAndPackCartesian2(e,t,a,r,u,l,n,!1);break;default:l[n]=u[e]*r.x+u[t]*r.y+u[a]*r.z}}function insertSplitPoint(e,t,a,r,n,i){const o=e.position.values.length/3;if(-1!==n){const s=r[n],u=a[s];return-1===u?(a[s]=o,e.position.values.push(i.x,i.y,i.z),t.push(o),o):(t.push(u),u)}return e.position.values.push(i.x,i.y,i.z),t.push(o),o}var NAMED_ATTRIBUTES={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function splitLongitudeTriangles(e){const t=e.geometry,a=t.attributes,r=a.position.values,n=defined_default(a.normal)?a.normal.values:void 0,i=defined_default(a.bitangent)?a.bitangent.values:void 0,o=defined_default(a.tangent)?a.tangent.values:void 0,s=defined_default(a.st)?a.st.values:void 0,u=defined_default(a.extrudeDirection)?a.extrudeDirection.values:void 0,l=defined_default(a.applyOffset)?a.applyOffset.values:void 0,d=t.indices,f=[];for(const e in a)a.hasOwnProperty(e)&&!NAMED_ATTRIBUTES[e]&&defined_default(a[e])&&f.push(e);const c=f.length,p=copyGeometryForSplit(t),_=copyGeometryForSplit(t);let m,y,h,v,C;const g=[];g.length=r.length/3;const b=[];for(b.length=r.length/3,C=0;C<g.length;++C)g[C]=-1,b[C]=-1;const T=d.length;for(C=0;C<T;C+=3){const e=d[C],t=d[C+1],T=d[C+2];let w=Cartesian3_default.fromArray(r,3*e),P=Cartesian3_default.fromArray(r,3*t),A=Cartesian3_default.fromArray(r,3*T);const S=splitTriangle(w,P,A);if(defined_default(S)&&S.positions.length>3){const w=S.positions,P=S.indices,A=P.length;for(let S=0;S<A;++S){const A=P[S],E=w[A];E.y<0?(m=_.attributes,y=_.indices,h=g):(m=p.attributes,y=p.indices,h=b),v=insertSplitPoint(m,y,h,d,A<3?C+A:-1,E),computeTriangleAttributes(e,t,T,E,r,n,o,i,s,u,l,m,f,c,a,v)}}else defined_default(S)&&(w=S.positions[0],P=S.positions[1],A=S.positions[2]),w.y<0?(m=_.attributes,y=_.indices,h=g):(m=p.attributes,y=p.indices,h=b),v=insertSplitPoint(m,y,h,d,C,w),computeTriangleAttributes(e,t,T,w,r,n,o,i,s,u,l,m,f,c,a,v),v=insertSplitPoint(m,y,h,d,C+1,P),computeTriangleAttributes(e,t,T,P,r,n,o,i,s,u,l,m,f,c,a,v),v=insertSplitPoint(m,y,h,d,C+2,A),computeTriangleAttributes(e,t,T,A,r,n,o,i,s,u,l,m,f,c,a,v)}updateInstanceAfterSplit(e,_,p)}var xzPlane=Plane_default.fromPointNormal(Cartesian3_default.ZERO,Cartesian3_default.UNIT_Y),offsetScratch=new Cartesian3_default,offsetPointScratch=new Cartesian3_default;function computeLineAttributes(e,t,a,r,n,i,o){if(!defined_default(o))return;const s=Cartesian3_default.fromArray(r,3*e,p0Scratch);Cartesian3_default.equalsEpsilon(s,a,Math_default.EPSILON10)?i.applyOffset.values[n]=o[e]:i.applyOffset.values[n]=o[t]}function splitLongitudeLines(e){const t=e.geometry,a=t.attributes,r=a.position.values,n=defined_default(a.applyOffset)?a.applyOffset.values:void 0,i=t.indices,o=copyGeometryForSplit(t),s=copyGeometryForSplit(t);let u;const l=i.length,d=[];d.length=r.length/3;const f=[];for(f.length=r.length/3,u=0;u<d.length;++u)d[u]=-1,f[u]=-1;for(u=0;u<l;u+=2){const e=i[u],t=i[u+1],a=Cartesian3_default.fromArray(r,3*e,p0Scratch),l=Cartesian3_default.fromArray(r,3*t,p1Scratch);let c;Math.abs(a.y)<Math_default.EPSILON6&&(a.y<0?a.y=-Math_default.EPSILON6:a.y=Math_default.EPSILON6),Math.abs(l.y)<Math_default.EPSILON6&&(l.y<0?l.y=-Math_default.EPSILON6:l.y=Math_default.EPSILON6);let p=o.attributes,_=o.indices,m=f,y=s.attributes,h=s.indices,v=d;const C=IntersectionTests_default.lineSegmentPlane(a,l,xzPlane,p2Scratch);if(defined_default(C)){const g=Cartesian3_default.multiplyByScalar(Cartesian3_default.UNIT_Y,5*Math_default.EPSILON9,offsetScratch);a.y<0&&(Cartesian3_default.negate(g,g),p=s.attributes,_=s.indices,m=d,y=o.attributes,h=o.indices,v=f);const b=Cartesian3_default.add(C,g,offsetPointScratch);c=insertSplitPoint(p,_,m,i,u,a),computeLineAttributes(e,t,a,r,c,p,n),c=insertSplitPoint(p,_,m,i,-1,b),computeLineAttributes(e,t,b,r,c,p,n),Cartesian3_default.negate(g,g),Cartesian3_default.add(C,g,b),c=insertSplitPoint(y,h,v,i,-1,b),computeLineAttributes(e,t,b,r,c,y,n),c=insertSplitPoint(y,h,v,i,u+1,l),computeLineAttributes(e,t,l,r,c,y,n)}else{let p,_,m;a.y<0?(p=s.attributes,_=s.indices,m=d):(p=o.attributes,_=o.indices,m=f),c=insertSplitPoint(p,_,m,i,u,a),computeLineAttributes(e,t,a,r,c,p,n),c=insertSplitPoint(p,_,m,i,u+1,l),computeLineAttributes(e,t,l,r,c,p,n)}}updateInstanceAfterSplit(e,s,o)}var cartesian2Scratch0=new Cartesian2_default,cartesian2Scratch1=new Cartesian2_default,cartesian3Scratch0=new Cartesian3_default,cartesian3Scratch2=new Cartesian3_default,cartesian3Scratch3=new Cartesian3_default,cartesian3Scratch4=new Cartesian3_default,cartesian3Scratch5=new Cartesian3_default,cartesian3Scratch6=new Cartesian3_default,cartesian4Scratch0=new Cartesian4_default;function updateAdjacencyAfterSplit(e){const t=e.attributes,a=t.position.values,r=t.prevPosition.values,n=t.nextPosition.values,i=a.length;for(let e=0;e<i;e+=3){const t=Cartesian3_default.unpack(a,e,cartesian3Scratch0);if(t.x>0)continue;const o=Cartesian3_default.unpack(r,e,cartesian3Scratch2);(t.y<0&&o.y>0||t.y>0&&o.y<0)&&(e-3>0?(r[e]=a[e-3],r[e+1]=a[e-2],r[e+2]=a[e-1]):Cartesian3_default.pack(t,r,e));const s=Cartesian3_default.unpack(n,e,cartesian3Scratch3);(t.y<0&&s.y>0||t.y>0&&s.y<0)&&(e+3<i?(n[e]=a[e+3],n[e+1]=a[e+4],n[e+2]=a[e+5]):Cartesian3_default.pack(t,n,e))}}var offsetScalar=5*Math_default.EPSILON9,coplanarOffset=Math_default.EPSILON6;function splitLongitudePolyline(e){const t=e.geometry,a=t.attributes,r=a.position.values,n=a.prevPosition.values,i=a.nextPosition.values,o=a.expandAndWidth.values,s=defined_default(a.st)?a.st.values:void 0,u=defined_default(a.color)?a.color.values:void 0,l=copyGeometryForSplit(t),d=copyGeometryForSplit(t);let f,c,p,_=!1;const m=r.length/3;for(f=0;f<m;f+=4){const e=f,t=f+2,a=Cartesian3_default.fromArray(r,3*e,cartesian3Scratch0),m=Cartesian3_default.fromArray(r,3*t,cartesian3Scratch2);if(Math.abs(a.y)<coplanarOffset)for(a.y=coplanarOffset*(m.y<0?-1:1),r[3*f+1]=a.y,r[3*(f+1)+1]=a.y,c=3*e;c<3*e+12;c+=3)n[c]=r[3*f],n[c+1]=r[3*f+1],n[c+2]=r[3*f+2];if(Math.abs(m.y)<coplanarOffset)for(m.y=coplanarOffset*(a.y<0?-1:1),r[3*(f+2)+1]=m.y,r[3*(f+3)+1]=m.y,c=3*e;c<3*e+12;c+=3)i[c]=r[3*(f+2)],i[c+1]=r[3*(f+2)+1],i[c+2]=r[3*(f+2)+2];let y=l.attributes,h=l.indices,v=d.attributes,C=d.indices;const g=IntersectionTests_default.lineSegmentPlane(a,m,xzPlane,cartesian3Scratch4);if(defined_default(g)){_=!0;const r=Cartesian3_default.multiplyByScalar(Cartesian3_default.UNIT_Y,offsetScalar,cartesian3Scratch5);a.y<0&&(Cartesian3_default.negate(r,r),y=d.attributes,h=d.indices,v=l.attributes,C=l.indices);const b=Cartesian3_default.add(g,r,cartesian3Scratch6);y.position.values.push(a.x,a.y,a.z,a.x,a.y,a.z),y.position.values.push(b.x,b.y,b.z),y.position.values.push(b.x,b.y,b.z),y.prevPosition.values.push(n[3*e],n[3*e+1],n[3*e+2]),y.prevPosition.values.push(n[3*e+3],n[3*e+4],n[3*e+5]),y.prevPosition.values.push(a.x,a.y,a.z,a.x,a.y,a.z),y.nextPosition.values.push(b.x,b.y,b.z),y.nextPosition.values.push(b.x,b.y,b.z),y.nextPosition.values.push(b.x,b.y,b.z),y.nextPosition.values.push(b.x,b.y,b.z),Cartesian3_default.negate(r,r),Cartesian3_default.add(g,r,b),v.position.values.push(b.x,b.y,b.z),v.position.values.push(b.x,b.y,b.z),v.position.values.push(m.x,m.y,m.z,m.x,m.y,m.z),v.prevPosition.values.push(b.x,b.y,b.z),v.prevPosition.values.push(b.x,b.y,b.z),v.prevPosition.values.push(b.x,b.y,b.z),v.prevPosition.values.push(b.x,b.y,b.z),v.nextPosition.values.push(m.x,m.y,m.z,m.x,m.y,m.z),v.nextPosition.values.push(i[3*t],i[3*t+1],i[3*t+2]),v.nextPosition.values.push(i[3*t+3],i[3*t+4],i[3*t+5]);const T=Cartesian2_default.fromArray(o,2*e,cartesian2Scratch0),w=Math.abs(T.y);y.expandAndWidth.values.push(-1,w,1,w),y.expandAndWidth.values.push(-1,-w,1,-w),v.expandAndWidth.values.push(-1,w,1,w),v.expandAndWidth.values.push(-1,-w,1,-w);let P=Cartesian3_default.magnitudeSquared(Cartesian3_default.subtract(g,a,cartesian3Scratch3));if(P/=Cartesian3_default.magnitudeSquared(Cartesian3_default.subtract(m,a,cartesian3Scratch3)),defined_default(u)){const a=Cartesian4_default.fromArray(u,4*e,cartesian4Scratch0),r=Cartesian4_default.fromArray(u,4*t,cartesian4Scratch0),n=Math_default.lerp(a.x,r.x,P),i=Math_default.lerp(a.y,r.y,P),o=Math_default.lerp(a.z,r.z,P),s=Math_default.lerp(a.w,r.w,P);for(c=4*e;c<4*e+8;++c)y.color.values.push(u[c]);for(y.color.values.push(n,i,o,s),y.color.values.push(n,i,o,s),v.color.values.push(n,i,o,s),v.color.values.push(n,i,o,s),c=4*t;c<4*t+8;++c)v.color.values.push(u[c])}if(defined_default(s)){const a=Cartesian2_default.fromArray(s,2*e,cartesian2Scratch0),r=Cartesian2_default.fromArray(s,2*(f+3),cartesian2Scratch1),n=Math_default.lerp(a.x,r.x,P);for(c=2*e;c<2*e+4;++c)y.st.values.push(s[c]);for(y.st.values.push(n,a.y),y.st.values.push(n,r.y),v.st.values.push(n,a.y),v.st.values.push(n,r.y),c=2*t;c<2*t+4;++c)v.st.values.push(s[c])}p=y.position.values.length/3-4,h.push(p,p+2,p+1),h.push(p+1,p+2,p+3),p=v.position.values.length/3-4,C.push(p,p+2,p+1),C.push(p+1,p+2,p+3)}else{let e,t;for(a.y<0?(e=d.attributes,t=d.indices):(e=l.attributes,t=l.indices),e.position.values.push(a.x,a.y,a.z),e.position.values.push(a.x,a.y,a.z),e.position.values.push(m.x,m.y,m.z),e.position.values.push(m.x,m.y,m.z),c=3*f;c<3*f+12;++c)e.prevPosition.values.push(n[c]),e.nextPosition.values.push(i[c]);for(c=2*f;c<2*f+8;++c)e.expandAndWidth.values.push(o[c]),defined_default(s)&&e.st.values.push(s[c]);if(defined_default(u))for(c=4*f;c<4*f+16;++c)e.color.values.push(u[c]);p=e.position.values.length/3-4,t.push(p,p+2,p+1),t.push(p+1,p+2,p+3)}}_&&(updateAdjacencyAfterSplit(d),updateAdjacencyAfterSplit(l)),updateInstanceAfterSplit(e,d,l)}GeometryPipeline.splitLongitude=function(e){if(!defined_default(e))throw new DeveloperError_default("instance is required.");const t=e.geometry,a=t.boundingSphere;if(defined_default(a)&&(a.center.x-a.radius>0||BoundingSphere_default.intersectPlane(a,Plane_default.ORIGIN_ZX_PLANE)!==Intersect_default.INTERSECTING))return e;if(t.geometryType!==GeometryType_default.NONE)switch(t.geometryType){case GeometryType_default.POLYLINES:splitLongitudePolyline(e);break;case GeometryType_default.TRIANGLES:splitLongitudeTriangles(e);break;case GeometryType_default.LINES:splitLongitudeLines(e)}else indexPrimitive(t),t.primitiveType===PrimitiveType_default.TRIANGLES?splitLongitudeTriangles(e):t.primitiveType===PrimitiveType_default.LINES&&splitLongitudeLines(e);return e};var GeometryPipeline_default=GeometryPipeline;export{GeometryPipeline_default};