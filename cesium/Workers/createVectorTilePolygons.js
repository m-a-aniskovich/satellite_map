/*! For license information please see createVectorTilePolygons.js.LICENSE.txt */
import{Color_default}from"./chunk-QUXSQQEF.js";import{createTaskProcessorWorker_default}from"./chunk-AI3KSNM6.js";import{OrientedBoundingBox_default}from"./chunk-QY2WY5XJ.js";import{AttributeCompression_default}from"./chunk-I6TVJ6T7.js";import"./chunk-MOLGJDJV.js";import"./chunk-FGUP2QEP.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Rectangle_default}from"./chunk-RSWBNJPT.js";import"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import"./chunk-C53JYYKX.js";import"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var scratchCenter=new Cartesian3_default,scratchEllipsoid=new Ellipsoid_default,scratchRectangle=new Rectangle_default,scratchScalars={min:void 0,max:void 0,indexBytesPerElement:void 0};function unpackBuffer(t){const e=new Float64Array(t);let a=0;scratchScalars.indexBytesPerElement=e[a++],scratchScalars.min=e[a++],scratchScalars.max=e[a++],Cartesian3_default.unpack(e,a,scratchCenter),a+=Cartesian3_default.packedLength,Ellipsoid_default.unpack(e,a,scratchEllipsoid),a+=Ellipsoid_default.packedLength,Rectangle_default.unpack(e,a,scratchRectangle)}function packedBatchedIndicesLength(t){const e=t.length;let a=0;for(let n=0;n<e;++n)a+=Color_default.packedLength+3+t[n].batchIds.length;return a}function packBuffer(t,e,a){const n=e.length,r=2+n*OrientedBoundingBox_default.packedLength+1+packedBatchedIndicesLength(a),c=new Float64Array(r);let o=0;c[o++]=t,c[o++]=n;for(let t=0;t<n;++t)OrientedBoundingBox_default.pack(e[t],c,o),o+=OrientedBoundingBox_default.packedLength;const s=a.length;c[o++]=s;for(let t=0;t<s;++t){const e=a[t];Color_default.pack(e.color,c,o),o+=Color_default.packedLength,c[o++]=e.offset,c[o++]=e.count;const n=e.batchIds,r=n.length;c[o++]=r;for(let t=0;t<r;++t)c[o++]=n[t]}return c}var maxShort=32767,scratchEncodedPosition=new Cartesian3_default,scratchNormal=new Cartesian3_default,scratchScaledNormal=new Cartesian3_default,scratchMinHeightPosition=new Cartesian3_default,scratchMaxHeightPosition=new Cartesian3_default,scratchBVCartographic=new Cartographic_default,scratchBVRectangle=new Rectangle_default;function createVectorTilePolygons(t,e){let a;unpackBuffer(t.packedBuffer),a=2===scratchScalars.indexBytesPerElement?new Uint16Array(t.indices):new Uint32Array(t.indices);const n=new Uint16Array(t.positions),r=new Uint32Array(t.counts),c=new Uint32Array(t.indexCounts),o=new Uint32Array(t.batchIds),s=new Uint32Array(t.batchTableColors),i=new Array(r.length),l=scratchCenter,f=scratchEllipsoid;let d=scratchRectangle;const u=scratchScalars.min,h=scratchScalars.max;let p,g,m,_=t.minimumHeights,k=t.maximumHeights;defined_default(_)&&defined_default(k)&&(_=new Float32Array(_),k=new Float32Array(k));const C=n.length/2,I=n.subarray(0,C),y=n.subarray(C,2*C);AttributeCompression_default.zigZagDeltaDecode(I,y);const x=new Float64Array(3*C);for(p=0;p<C;++p){const t=I[p],e=y[p],a=Math_default.lerp(d.west,d.east,t/maxShort),n=Math_default.lerp(d.south,d.north,e/maxShort),r=Cartographic_default.fromRadians(a,n,0,scratchBVCartographic),c=f.cartographicToCartesian(r,scratchEncodedPosition);Cartesian3_default.pack(c,x,3*p)}const b=r.length,w=new Array(b),E=new Array(b);let N=0,B=0;for(p=0;p<b;++p)w[p]=N,E[p]=B,N+=r[p],B+=c[p];const S=new Float32Array(3*C*2),P=new Uint16Array(2*C),A=new Uint32Array(E.length),T=new Uint32Array(c.length);let L=[];const O={};for(p=0;p<b;++p)m=s[p],defined_default(O[m])?(O[m].positionLength+=r[p],O[m].indexLength+=c[p],O[m].batchIds.push(p)):O[m]={positionLength:r[p],indexLength:c[p],offset:0,indexOffset:0,batchIds:[p]};let V,j=0,R=0;for(m in O)if(O.hasOwnProperty(m)){V=O[m],V.offset=j,V.indexOffset=R;const t=2*V.positionLength,e=2*V.indexLength+6*V.positionLength;j+=t,R+=e,V.indexLength=e}const U=[];for(m in O)O.hasOwnProperty(m)&&(V=O[m],U.push({color:Color_default.fromRgba(parseInt(m)),offset:V.indexOffset,count:V.indexLength,batchIds:V.batchIds}));for(p=0;p<b;++p){m=s[p],V=O[m];const t=V.offset;let e=3*t,n=t;const C=w[p],I=r[p],y=o[p];let b=u,N=h;defined_default(_)&&defined_default(k)&&(b=_[p],N=k[p]);let B=Number.POSITIVE_INFINITY,j=Number.NEGATIVE_INFINITY,R=Number.POSITIVE_INFINITY,U=Number.NEGATIVE_INFINITY;for(g=0;g<I;++g){const t=Cartesian3_default.unpack(x,3*C+3*g,scratchEncodedPosition);f.scaleToGeodeticSurface(t,t);const a=f.cartesianToCartographic(t,scratchBVCartographic),r=a.latitude,c=a.longitude;B=Math.min(r,B),j=Math.max(r,j),R=Math.min(c,R),U=Math.max(c,U);const o=f.geodeticSurfaceNormal(t,scratchNormal);let s=Cartesian3_default.multiplyByScalar(o,b,scratchScaledNormal);const i=Cartesian3_default.add(t,s,scratchMinHeightPosition);s=Cartesian3_default.multiplyByScalar(o,N,s);const d=Cartesian3_default.add(t,s,scratchMaxHeightPosition);Cartesian3_default.subtract(d,l,d),Cartesian3_default.subtract(i,l,i),Cartesian3_default.pack(d,S,e),Cartesian3_default.pack(i,S,e+3),P[n]=y,P[n+1]=y,e+=6,n+=2}d=scratchBVRectangle,d.west=R,d.east=U,d.south=B,d.north=j,i[p]=OrientedBoundingBox_default.fromRectangle(d,u,h,f);let D=V.indexOffset;const M=E[p],F=c[p];for(A[p]=D,g=0;g<F;g+=3){const e=a[M+g]-C,n=a[M+g+1]-C,r=a[M+g+2]-C;L[D++]=2*e+t,L[D++]=2*n+t,L[D++]=2*r+t,L[D++]=2*r+1+t,L[D++]=2*n+1+t,L[D++]=2*e+1+t}for(g=0;g<I;++g){const e=g,a=(g+1)%I;L[D++]=2*e+1+t,L[D++]=2*a+t,L[D++]=2*e+t,L[D++]=2*e+1+t,L[D++]=2*a+1+t,L[D++]=2*a+t}V.offset+=2*I,V.indexOffset=D,T[p]=D-A[p]}L=IndexDatatype_default.createTypedArray(S.length/3,L);const D=U.length;for(let t=0;t<D;++t){const e=U[t].batchIds;let a=0;const n=e.length;for(let t=0;t<n;++t)a+=T[e[t]];U[t].count=a}const M=packBuffer(2===L.BYTES_PER_ELEMENT?IndexDatatype_default.UNSIGNED_SHORT:IndexDatatype_default.UNSIGNED_INT,i,U);return e.push(S.buffer,L.buffer,A.buffer,T.buffer,P.buffer,M.buffer),{positions:S.buffer,indices:L.buffer,indexOffsets:A.buffer,indexCounts:T.buffer,batchIds:P.buffer,packedBuffer:M.buffer}}var createVectorTilePolygons_default=createTaskProcessorWorker_default(createVectorTilePolygons);export{createVectorTilePolygons_default as default};