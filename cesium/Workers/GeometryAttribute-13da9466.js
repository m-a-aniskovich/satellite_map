define(["exports","./Matrix2-e1298525","./Matrix3-41c58dde","./Check-6ede7e26","./defaultValue-fe22d8c0","./WebGLConstants-0b1ce7ba","./Transforms-e2d4a55a"],(function(t,e,r,n,i,a,o){"use strict";var s=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});const u={POINTS:a.WebGLConstants.POINTS,LINES:a.WebGLConstants.LINES,LINE_LOOP:a.WebGLConstants.LINE_LOOP,LINE_STRIP:a.WebGLConstants.LINE_STRIP,TRIANGLES:a.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:a.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:a.WebGLConstants.TRIANGLE_FAN,isLines:function(t){return t===u.LINES||t===u.LINE_LOOP||t===u.LINE_STRIP},isTriangles:function(t){return t===u.TRIANGLES||t===u.TRIANGLE_STRIP||t===u.TRIANGLE_FAN},validate:function(t){return t===u.POINTS||t===u.LINES||t===u.LINE_LOOP||t===u.LINE_STRIP||t===u.TRIANGLES||t===u.TRIANGLE_STRIP||t===u.TRIANGLE_FAN}};var c=Object.freeze(u);function I(t){t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT),n.Check.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=i.defaultValue(t.primitiveType,c.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=i.defaultValue(t.geometryType,s.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}I.computeNumberOfVertices=function(t){n.Check.typeOf.object("geometry",t);let e=-1;for(const r in t.attributes)if(t.attributes.hasOwnProperty(r)&&i.defined(t.attributes[r])&&i.defined(t.attributes[r].values)){const i=t.attributes[r],a=i.values.length/i.componentsPerAttribute;if(e!==a&&-1!==e)throw new n.DeveloperError("All attribute lists must have the same number of attributes.");e=a}return e};const p=new r.Cartographic,l=new r.Cartesian3,N=new e.Matrix4,b=[new r.Cartographic,new r.Cartographic,new r.Cartographic],f=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],T=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],m=new r.Cartesian3,E=new o.Quaternion,d=new e.Matrix4,h=new e.Matrix2;I._textureCoordinateRotationPoints=function(t,n,i,a){let s;const u=e.Rectangle.center(a,p),c=r.Cartographic.toCartesian(u,i,l),I=o.Transforms.eastNorthUpToFixedFrame(c,i,N),L=e.Matrix4.inverse(I,N),y=f,A=b;A[0].longitude=a.west,A[0].latitude=a.south,A[1].longitude=a.west,A[1].latitude=a.north,A[2].longitude=a.east,A[2].latitude=a.south;let C=m;for(s=0;s<3;s++)r.Cartographic.toCartesian(A[s],i,C),C=e.Matrix4.multiplyByPointAsVector(L,C,C),y[s].x=C.x,y[s].y=C.y;const P=o.Quaternion.fromAxisAngle(r.Cartesian3.UNIT_Z,-n,E),w=r.Matrix3.fromQuaternion(P,d),x=t.length;let S=Number.POSITIVE_INFINITY,G=Number.POSITIVE_INFINITY,R=Number.NEGATIVE_INFINITY,O=Number.NEGATIVE_INFINITY;for(s=0;s<x;s++)C=e.Matrix4.multiplyByPointAsVector(L,t[s],C),C=r.Matrix3.multiplyByVector(w,C,C),S=Math.min(S,C.x),G=Math.min(G,C.y),R=Math.max(R,C.x),O=Math.max(O,C.y);const _=e.Matrix2.fromRotation(n,h),g=T;g[0].x=S,g[0].y=G,g[1].x=S,g[1].y=O,g[2].x=R,g[2].y=G;const v=y[0],V=y[2].x-v.x,M=y[1].y-v.y;for(s=0;s<3;s++){const t=g[s];e.Matrix2.multiplyByVector(_,t,t),t.x=(t.x-v.x)/V,t.y=(t.y-v.y)/M}const F=g[0],D=g[1],W=g[2],Y=new Array(6);return e.Cartesian2.pack(F,Y),e.Cartesian2.pack(D,Y,2),e.Cartesian2.pack(W,Y,4),Y},t.Geometry=I,t.GeometryAttribute=function(t){if(t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT),!i.defined(t.componentDatatype))throw new n.DeveloperError("options.componentDatatype is required.");if(!i.defined(t.componentsPerAttribute))throw new n.DeveloperError("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new n.DeveloperError("options.componentsPerAttribute must be between 1 and 4.");if(!i.defined(t.values))throw new n.DeveloperError("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=i.defaultValue(t.normalize,!1),this.values=t.values},t.GeometryType=s,t.PrimitiveType=c}));