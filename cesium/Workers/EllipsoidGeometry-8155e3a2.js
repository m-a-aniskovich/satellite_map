define(["exports","./Transforms-e2d4a55a","./Matrix2-e1298525","./Matrix3-41c58dde","./ComponentDatatype-cf1fa08e","./defaultValue-fe22d8c0","./Check-6ede7e26","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./GeometryOffsetAttribute-9ad0019c","./IndexDatatype-2643aa47","./Math-0a2ac845","./VertexFormat-030f11ff"],(function(t,e,a,n,i,r,o,s,m,u,l,c,f){"use strict";const d=new n.Cartesian3,p=new n.Cartesian3,C=new n.Cartesian3,y=new n.Cartesian3,h=new n.Cartesian3,_=new n.Cartesian3(1,1,1),x=Math.cos,A=Math.sin;function w(t){t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT);const e=r.defaultValue(t.radii,_),a=r.defaultValue(t.innerRadii,e),i=r.defaultValue(t.minimumClock,0),s=r.defaultValue(t.maximumClock,c.CesiumMath.TWO_PI),m=r.defaultValue(t.minimumCone,0),u=r.defaultValue(t.maximumCone,c.CesiumMath.PI),l=Math.round(r.defaultValue(t.stackPartitions,64)),d=Math.round(r.defaultValue(t.slicePartitions,64)),p=r.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT);if(d<3)throw new o.DeveloperError("options.slicePartitions cannot be less than three.");if(l<3)throw new o.DeveloperError("options.stackPartitions cannot be less than three.");this._radii=n.Cartesian3.clone(e),this._innerRadii=n.Cartesian3.clone(a),this._minimumClock=i,this._maximumClock=s,this._minimumCone=m,this._maximumCone=u,this._stackPartitions=l,this._slicePartitions=d,this._vertexFormat=f.VertexFormat.clone(p),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}w.packedLength=2*n.Cartesian3.packedLength+f.VertexFormat.packedLength+7,w.pack=function(t,e,a){if(!r.defined(t))throw new o.DeveloperError("value is required");if(!r.defined(e))throw new o.DeveloperError("array is required");return a=r.defaultValue(a,0),n.Cartesian3.pack(t._radii,e,a),a+=n.Cartesian3.packedLength,n.Cartesian3.pack(t._innerRadii,e,a),a+=n.Cartesian3.packedLength,f.VertexFormat.pack(t._vertexFormat,e,a),a+=f.VertexFormat.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=r.defaultValue(t._offsetAttribute,-1),e};const k=new n.Cartesian3,b=new n.Cartesian3,v=new f.VertexFormat,P={radii:k,innerRadii:b,vertexFormat:v,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let g;w.unpack=function(t,e,a){if(!r.defined(t))throw new o.DeveloperError("array is required");e=r.defaultValue(e,0);const i=n.Cartesian3.unpack(t,e,k);e+=n.Cartesian3.packedLength;const s=n.Cartesian3.unpack(t,e,b);e+=n.Cartesian3.packedLength;const m=f.VertexFormat.unpack(t,e,v);e+=f.VertexFormat.packedLength;const u=t[e++],l=t[e++],c=t[e++],d=t[e++],p=t[e++],C=t[e++],y=t[e];return r.defined(a)?(a._radii=n.Cartesian3.clone(i,a._radii),a._innerRadii=n.Cartesian3.clone(s,a._innerRadii),a._vertexFormat=f.VertexFormat.clone(m,a._vertexFormat),a._minimumClock=u,a._maximumClock=l,a._minimumCone=c,a._maximumCone=d,a._stackPartitions=p,a._slicePartitions=C,a._offsetAttribute=-1===y?void 0:y,a):(P.minimumClock=u,P.maximumClock=l,P.minimumCone=c,P.maximumCone=d,P.stackPartitions=p,P.slicePartitions=C,P.offsetAttribute=-1===y?void 0:y,new w(P))},w.createGeometry=function(t){const o=t._radii;if(o.x<=0||o.y<=0||o.z<=0)return;const f=t._innerRadii;if(f.x<=0||f.y<=0||f.z<=0)return;const _=t._minimumClock,w=t._maximumClock,k=t._minimumCone,b=t._maximumCone,v=t._vertexFormat;let P,g,F=t._slicePartitions+1,V=t._stackPartitions+1;F=Math.round(F*Math.abs(w-_)/c.CesiumMath.TWO_PI),V=Math.round(V*Math.abs(b-k)/c.CesiumMath.PI),F<2&&(F=2),V<2&&(V=2);let D=0;const M=[k],T=[_];for(P=0;P<V;P++)M.push(k+P*(b-k)/(V-1));for(M.push(b),g=0;g<F;g++)T.push(_+g*(w-_)/(F-1));T.push(w);const E=M.length,G=T.length;let L=0,O=1;const I=f.x!==o.x||f.y!==o.y||f.z!==o.z;let z=!1,N=!1,R=!1;I&&(O=2,k>0&&(z=!0,L+=F-1),b<Math.PI&&(N=!0,L+=F-1),(w-_)%c.CesiumMath.TWO_PI?(R=!0,L+=2*(V-1)+1):L+=1);const U=G*E*O,S=new Float64Array(3*U),B=new Array(U).fill(!1),W=new Array(U).fill(!1),q=F*V*O,Y=6*(q+L+1-(F+V)*O),J=l.IndexDatatype.createTypedArray(q,Y),X=v.normal?new Float32Array(3*U):void 0,Z=v.tangent?new Float32Array(3*U):void 0,j=v.bitangent?new Float32Array(3*U):void 0,H=v.st?new Float32Array(2*U):void 0,K=new Array(E),Q=new Array(E);for(P=0;P<E;P++)K[P]=A(M[P]),Q[P]=x(M[P]);const $=new Array(G),tt=new Array(G);for(g=0;g<G;g++)tt[g]=x(T[g]),$[g]=A(T[g]);for(P=0;P<E;P++)for(g=0;g<G;g++)S[D++]=o.x*K[P]*tt[g],S[D++]=o.y*K[P]*$[g],S[D++]=o.z*Q[P];let et,at,nt,it,rt=U/2;if(I)for(P=0;P<E;P++)for(g=0;g<G;g++)S[D++]=f.x*K[P]*tt[g],S[D++]=f.y*K[P]*$[g],S[D++]=f.z*Q[P],B[rt]=!0,P>0&&P!==E-1&&0!==g&&g!==G-1&&(W[rt]=!0),rt++;for(D=0,P=1;P<E-2;P++)for(et=P*G,at=(P+1)*G,g=1;g<G-2;g++)J[D++]=at+g,J[D++]=at+g+1,J[D++]=et+g+1,J[D++]=at+g,J[D++]=et+g+1,J[D++]=et+g;if(I){const t=E*G;for(P=1;P<E-2;P++)for(et=t+P*G,at=t+(P+1)*G,g=1;g<G-2;g++)J[D++]=at+g,J[D++]=et+g,J[D++]=et+g+1,J[D++]=at+g,J[D++]=et+g+1,J[D++]=at+g+1}if(I){if(z)for(it=E*G,P=1;P<G-2;P++)J[D++]=P,J[D++]=P+1,J[D++]=it+P+1,J[D++]=P,J[D++]=it+P+1,J[D++]=it+P;if(N)for(nt=E*G-G,it=E*G*O-G,P=1;P<G-2;P++)J[D++]=nt+P+1,J[D++]=nt+P,J[D++]=it+P,J[D++]=nt+P+1,J[D++]=it+P,J[D++]=it+P+1}if(R){for(P=1;P<E-2;P++)it=G*E+G*P,nt=G*P,J[D++]=it,J[D++]=nt+G,J[D++]=nt,J[D++]=it,J[D++]=it+G,J[D++]=nt+G;for(P=1;P<E-2;P++)it=G*E+G*(P+1)-1,nt=G*(P+1)-1,J[D++]=nt+G,J[D++]=it,J[D++]=nt,J[D++]=nt+G,J[D++]=it+G,J[D++]=it}const ot=new m.GeometryAttributes;v.position&&(ot.position=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:S}));let st=0,mt=0,ut=0,lt=0;const ct=U/2;let ft;const dt=n.Ellipsoid.fromCartesian3(o),pt=n.Ellipsoid.fromCartesian3(f);if(v.st||v.normal||v.tangent||v.bitangent){for(P=0;P<U;P++){ft=B[P]?pt:dt;const t=n.Cartesian3.fromArray(S,3*P,d),e=ft.geodeticSurfaceNormal(t,p);if(W[P]&&n.Cartesian3.negate(e,e),v.st){const t=a.Cartesian2.negate(e,h);H[st++]=Math.atan2(t.y,t.x)/c.CesiumMath.TWO_PI+.5,H[st++]=Math.asin(e.z)/Math.PI+.5}if(v.normal&&(X[mt++]=e.x,X[mt++]=e.y,X[mt++]=e.z),v.tangent||v.bitangent){const t=C;let a,i=0;if(B[P]&&(i=ct),a=!z&&P>=i&&P<i+2*G?n.Cartesian3.UNIT_X:n.Cartesian3.UNIT_Z,n.Cartesian3.cross(a,e,t),n.Cartesian3.normalize(t,t),v.tangent&&(Z[ut++]=t.x,Z[ut++]=t.y,Z[ut++]=t.z),v.bitangent){const a=n.Cartesian3.cross(e,t,y);n.Cartesian3.normalize(a,a),j[lt++]=a.x,j[lt++]=a.y,j[lt++]=a.z}}}v.st&&(ot.st=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:H})),v.normal&&(ot.normal=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:X})),v.tangent&&(ot.tangent=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Z})),v.bitangent&&(ot.bitangent=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j}))}if(r.defined(t._offsetAttribute)){const e=S.length,a=t._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(e/3).fill(a);ot.applyOffset=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new s.Geometry({attributes:ot,indices:J,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:e.BoundingSphere.fromEllipsoid(dt),offsetAttribute:t._offsetAttribute})},w.getUnitEllipsoid=function(){return r.defined(g)||(g=w.createGeometry(new w({radii:new n.Cartesian3(1,1,1),vertexFormat:f.VertexFormat.POSITION_ONLY}))),g},t.EllipsoidGeometry=w}));