/*! For license information please see createGroundPolylineGeometry.js.LICENSE.txt */
import{WebMercatorProjection_default}from"./chunk-K6Q5IRBK.js";import{ArcType_default}from"./chunk-235MRXLH.js";import{EncodedCartesian3_default}from"./chunk-VOAZN4IP.js";import{EllipsoidGeodesic_default}from"./chunk-LSGUCCKJ.js";import{arrayRemoveDuplicates_default}from"./chunk-DTNN3ODA.js";import{EllipsoidRhumbLine_default}from"./chunk-6PWSSCRA.js";import{IntersectionTests_default}from"./chunk-HEROVJML.js";import{Plane_default}from"./chunk-4EYB62WJ.js";import{GeometryAttribute_default,Geometry_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default,GeographicProjection_default,Quaternion_default,Resource_default,buildModuleUrl_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Cartesian2_default,Rectangle_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";function GeographicTilingScheme(e){e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT),this._ellipsoid=defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84),this._rectangle=defaultValue_default(e.rectangle,Rectangle_default.MAX_VALUE),this._projection=new GeographicProjection_default(this._ellipsoid),this._numberOfLevelZeroTilesX=defaultValue_default(e.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=defaultValue_default(e.numberOfLevelZeroTilesY,1)}Object.defineProperties(GeographicTilingScheme.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},GeographicTilingScheme.prototype.rectangleToNativeRectangle=function(e,t){Check_default.defined("rectangle",e);const a=Math_default.toDegrees(e.west),r=Math_default.toDegrees(e.south),n=Math_default.toDegrees(e.east),i=Math_default.toDegrees(e.north);return defined_default(t)?(t.west=a,t.south=r,t.east=n,t.north=i,t):new Rectangle_default(a,r,n,i)},GeographicTilingScheme.prototype.tileXYToNativeRectangle=function(e,t,a,r){const n=this.tileXYToRectangle(e,t,a,r);return n.west=Math_default.toDegrees(n.west),n.south=Math_default.toDegrees(n.south),n.east=Math_default.toDegrees(n.east),n.north=Math_default.toDegrees(n.north),n},GeographicTilingScheme.prototype.tileXYToRectangle=function(e,t,a,r){const n=this._rectangle,i=this.getNumberOfXTilesAtLevel(a),o=this.getNumberOfYTilesAtLevel(a),l=n.width/i,c=e*l+n.west,s=(e+1)*l+n.west,u=n.height/o,d=n.north-t*u,f=n.north-(t+1)*u;return defined_default(r)||(r=new Rectangle_default(c,f,s,d)),r.west=c,r.south=f,r.east=s,r.north=d,r},GeographicTilingScheme.prototype.positionToTileXY=function(e,t,a){const r=this._rectangle;if(!Rectangle_default.contains(r,e))return;const n=this.getNumberOfXTilesAtLevel(t),i=this.getNumberOfYTilesAtLevel(t),o=r.width/n,l=r.height/i;let c=e.longitude;r.east<r.west&&(c+=Math_default.TWO_PI);let s=(c-r.west)/o|0;s>=n&&(s=n-1);let u=(r.north-e.latitude)/l|0;return u>=i&&(u=i-1),defined_default(a)?(a.x=s,a.y=u,a):new Cartesian2_default(s,u)};var GeographicTilingScheme_default=GeographicTilingScheme,scratchDiagonalCartesianNE=new Cartesian3_default,scratchDiagonalCartesianSW=new Cartesian3_default,scratchDiagonalCartographic=new Cartographic_default,scratchCenterCartesian=new Cartesian3_default,scratchSurfaceCartesian=new Cartesian3_default,scratchBoundingSphere=new BoundingSphere_default,tilingScheme=new GeographicTilingScheme_default,scratchCorners=[new Cartographic_default,new Cartographic_default,new Cartographic_default,new Cartographic_default],scratchTileXY=new Cartesian2_default,ApproximateTerrainHeights={};function getTileXYLevel(e){Cartographic_default.fromRadians(e.east,e.north,0,scratchCorners[0]),Cartographic_default.fromRadians(e.west,e.north,0,scratchCorners[1]),Cartographic_default.fromRadians(e.east,e.south,0,scratchCorners[2]),Cartographic_default.fromRadians(e.west,e.south,0,scratchCorners[3]);let t=0,a=0,r=0,n=0;const i=ApproximateTerrainHeights._terrainHeightsMaxLevel;let o;for(o=0;o<=i;++o){let e=!1;for(let t=0;t<4;++t){const a=scratchCorners[t];if(tilingScheme.positionToTileXY(a,o,scratchTileXY),0===t)r=scratchTileXY.x,n=scratchTileXY.y;else if(r!==scratchTileXY.x||n!==scratchTileXY.y){e=!0;break}}if(e)break;t=r,a=n}if(0!==o)return{x:t,y:a,level:o>i?i:o-1}}ApproximateTerrainHeights.initialize=function(){let e=ApproximateTerrainHeights._initPromise;return defined_default(e)||(e=Resource_default.fetchJson(buildModuleUrl_default("Assets/approximateTerrainHeights.json")).then((function(e){ApproximateTerrainHeights._terrainHeights=e})),ApproximateTerrainHeights._initPromise=e),e},ApproximateTerrainHeights.getMinimumMaximumHeights=function(e,t){if(Check_default.defined("rectangle",e),!defined_default(ApproximateTerrainHeights._terrainHeights))throw new DeveloperError_default("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");t=defaultValue_default(t,Ellipsoid_default.WGS84);const a=getTileXYLevel(e);let r=ApproximateTerrainHeights._defaultMinTerrainHeight,n=ApproximateTerrainHeights._defaultMaxTerrainHeight;if(defined_default(a)){const i=`${a.level}-${a.x}-${a.y}`,o=ApproximateTerrainHeights._terrainHeights[i];defined_default(o)&&(r=o[0],n=o[1]),t.cartographicToCartesian(Rectangle_default.northeast(e,scratchDiagonalCartographic),scratchDiagonalCartesianNE),t.cartographicToCartesian(Rectangle_default.southwest(e,scratchDiagonalCartographic),scratchDiagonalCartesianSW),Cartesian3_default.midpoint(scratchDiagonalCartesianSW,scratchDiagonalCartesianNE,scratchCenterCartesian);const l=t.scaleToGeodeticSurface(scratchCenterCartesian,scratchSurfaceCartesian);if(defined_default(l)){const e=Cartesian3_default.distance(scratchCenterCartesian,l);r=Math.min(r,-e)}else r=ApproximateTerrainHeights._defaultMinTerrainHeight}return r=Math.max(ApproximateTerrainHeights._defaultMinTerrainHeight,r),{minimumTerrainHeight:r,maximumTerrainHeight:n}},ApproximateTerrainHeights.getBoundingSphere=function(e,t){if(Check_default.defined("rectangle",e),!defined_default(ApproximateTerrainHeights._terrainHeights))throw new DeveloperError_default("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");t=defaultValue_default(t,Ellipsoid_default.WGS84);const a=getTileXYLevel(e);let r=ApproximateTerrainHeights._defaultMaxTerrainHeight;if(defined_default(a)){const e=`${a.level}-${a.x}-${a.y}`,t=ApproximateTerrainHeights._terrainHeights[e];defined_default(t)&&(r=t[1])}const n=BoundingSphere_default.fromRectangle3D(e,t,0);return BoundingSphere_default.fromRectangle3D(e,t,r,scratchBoundingSphere),BoundingSphere_default.union(n,scratchBoundingSphere,n)},ApproximateTerrainHeights._terrainHeightsMaxLevel=6,ApproximateTerrainHeights._defaultMaxTerrainHeight=9e3,ApproximateTerrainHeights._defaultMinTerrainHeight=-1e5,ApproximateTerrainHeights._terrainHeights=void 0,ApproximateTerrainHeights._initPromise=void 0,Object.defineProperties(ApproximateTerrainHeights,{initialized:{get:function(){return defined_default(ApproximateTerrainHeights._terrainHeights)}}});var ApproximateTerrainHeights_default=ApproximateTerrainHeights,PROJECTIONS=[GeographicProjection_default,WebMercatorProjection_default],PROJECTION_COUNT=PROJECTIONS.length,MITER_BREAK_SMALL=Math.cos(Math_default.toRadians(30)),MITER_BREAK_LARGE=Math.cos(Math_default.toRadians(150)),WALL_INITIAL_MIN_HEIGHT=0,WALL_INITIAL_MAX_HEIGHT=1e3;function GroundPolylineGeometry(e){const t=(e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT)).positions;if(!defined_default(t)||t.length<2)throw new DeveloperError_default("At least two positions are required.");if(defined_default(e.arcType)&&e.arcType!==ArcType_default.GEODESIC&&e.arcType!==ArcType_default.RHUMB)throw new DeveloperError_default("Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.");this.width=defaultValue_default(e.width,1),this._positions=t,this.granularity=defaultValue_default(e.granularity,9999),this.loop=defaultValue_default(e.loop,!1),this.arcType=defaultValue_default(e.arcType,ArcType_default.GEODESIC),this._ellipsoid=Ellipsoid_default.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(GroundPolylineGeometry.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+Ellipsoid_default.packedLength+1+1}}}),GroundPolylineGeometry.setProjectionAndEllipsoid=function(e,t){let a=0;for(let e=0;e<PROJECTION_COUNT;e++)if(t instanceof PROJECTIONS[e]){a=e;break}e._projectionIndex=a,e._ellipsoid=t.ellipsoid};var cart3Scratch1=new Cartesian3_default,cart3Scratch2=new Cartesian3_default,cart3Scratch3=new Cartesian3_default;function computeRightNormal(e,t,a,r,n){const i=getPosition(r,e,0,cart3Scratch1),o=getPosition(r,e,a,cart3Scratch2),l=getPosition(r,t,0,cart3Scratch3),c=direction(o,i,cart3Scratch2),s=direction(l,i,cart3Scratch3);return Cartesian3_default.cross(s,c,n),Cartesian3_default.normalize(n,n)}var interpolatedCartographicScratch=new Cartographic_default,interpolatedBottomScratch=new Cartesian3_default,interpolatedTopScratch=new Cartesian3_default,interpolatedNormalScratch=new Cartesian3_default;function interpolateSegment(e,t,a,r,n,i,o,l,c,s,u){if(0===n)return;let d;i===ArcType_default.GEODESIC?d=new EllipsoidGeodesic_default(e,t,o):i===ArcType_default.RHUMB&&(d=new EllipsoidRhumbLine_default(e,t,o));const f=d.surfaceDistance;if(f<n)return;const h=computeRightNormal(e,t,r,o,interpolatedNormalScratch),_=Math.ceil(f/n),p=f/_;let g=p;const m=_-1;let C=l.length;for(let e=0;e<m;e++){const e=d.interpolateUsingSurfaceDistance(g,interpolatedCartographicScratch),t=getPosition(o,e,a,interpolatedBottomScratch),n=getPosition(o,e,r,interpolatedTopScratch);Cartesian3_default.pack(h,l,C),Cartesian3_default.pack(t,c,C),Cartesian3_default.pack(n,s,C),u.push(e.latitude),u.push(e.longitude),C+=3,g+=p}}var heightlessCartographicScratch=new Cartographic_default;function getPosition(e,t,a,r){return Cartographic_default.clone(t,heightlessCartographicScratch),heightlessCartographicScratch.height=a,Cartographic_default.toCartesian(heightlessCartographicScratch,e,r)}function direction(e,t,a){return Cartesian3_default.subtract(e,t,a),Cartesian3_default.normalize(a,a),a}function tangentDirection(e,t,a,r){return r=direction(e,t,r),r=Cartesian3_default.cross(r,a,r),r=Cartesian3_default.normalize(r,r),Cartesian3_default.cross(a,r,r)}GroundPolylineGeometry.pack=function(e,t,a){Check_default.typeOf.object("value",e),Check_default.defined("array",t);let r=defaultValue_default(a,0);const n=e._positions,i=n.length;t[r++]=i;for(let e=0;e<i;++e){const a=n[e];Cartesian3_default.pack(a,t,r),r+=3}return t[r++]=e.granularity,t[r++]=e.loop?1:0,t[r++]=e.arcType,Ellipsoid_default.pack(e._ellipsoid,t,r),r+=Ellipsoid_default.packedLength,t[r++]=e._projectionIndex,t[r++]=e._scene3DOnly?1:0,t},GroundPolylineGeometry.unpack=function(e,t,a){Check_default.defined("array",e);let r=defaultValue_default(t,0);const n=e[r++],i=new Array(n);for(let t=0;t<n;t++)i[t]=Cartesian3_default.unpack(e,r),r+=3;const o=e[r++],l=1===e[r++],c=e[r++],s=Ellipsoid_default.unpack(e,r);r+=Ellipsoid_default.packedLength;const u=e[r++],d=1===e[r++];return defined_default(a)||(a=new GroundPolylineGeometry({positions:i})),a._positions=i,a.granularity=o,a.loop=l,a.arcType=c,a._ellipsoid=s,a._projectionIndex=u,a._scene3DOnly=d,a};var toPreviousScratch=new Cartesian3_default,toNextScratch=new Cartesian3_default,forwardScratch=new Cartesian3_default,vertexUpScratch=new Cartesian3_default,cosine90=0,cosine180=-1;function computeVertexMiterNormal(e,t,a,r,n){const i=direction(a,t,vertexUpScratch),o=tangentDirection(e,t,i,toPreviousScratch),l=tangentDirection(r,t,i,toNextScratch);if(Math_default.equalsEpsilon(Cartesian3_default.dot(o,l),cosine180,Math_default.EPSILON5))return n=Cartesian3_default.cross(i,o,n),Cartesian3_default.normalize(n,n);n=Cartesian3_default.add(l,o,n),n=Cartesian3_default.normalize(n,n);const c=Cartesian3_default.cross(i,n,forwardScratch);return Cartesian3_default.dot(l,c)<cosine90&&(n=Cartesian3_default.negate(n,n)),n}var XZ_PLANE=Plane_default.fromPointNormal(Cartesian3_default.ZERO,Cartesian3_default.UNIT_Y),previousBottomScratch=new Cartesian3_default,vertexBottomScratch=new Cartesian3_default,vertexTopScratch=new Cartesian3_default,nextBottomScratch=new Cartesian3_default,vertexNormalScratch=new Cartesian3_default,intersectionScratch=new Cartesian3_default,cartographicScratch0=new Cartographic_default,cartographicScratch1=new Cartographic_default,cartographicIntersectionScratch=new Cartographic_default;GroundPolylineGeometry.createGeometry=function(e){const t=!e._scene3DOnly;let a=e.loop;const r=e._ellipsoid,n=e.granularity,i=e.arcType,o=new PROJECTIONS[e._projectionIndex](r),l=WALL_INITIAL_MIN_HEIGHT,c=WALL_INITIAL_MAX_HEIGHT;let s,u;const d=e._positions,f=d.length;let h,_,p,g;2===f&&(a=!1);const m=new EllipsoidRhumbLine_default(void 0,void 0,r);let C,S,T;const E=[d[0]];for(u=0;u<f-1;u++)h=d[u],_=d[u+1],C=IntersectionTests_default.lineSegmentPlane(h,_,XZ_PLANE,intersectionScratch),!defined_default(C)||Cartesian3_default.equalsEpsilon(C,h,Math_default.EPSILON7)||Cartesian3_default.equalsEpsilon(C,_,Math_default.EPSILON7)||(e.arcType===ArcType_default.GEODESIC?E.push(Cartesian3_default.clone(C)):e.arcType===ArcType_default.RHUMB&&(T=r.cartesianToCartographic(C,cartographicScratch0).longitude,p=r.cartesianToCartographic(h,cartographicScratch0),g=r.cartesianToCartographic(_,cartographicScratch1),m.setEndPoints(p,g),S=m.findIntersectionWithLongitude(T,cartographicIntersectionScratch),C=r.cartographicToCartesian(S,intersectionScratch),!defined_default(C)||Cartesian3_default.equalsEpsilon(C,h,Math_default.EPSILON7)||Cartesian3_default.equalsEpsilon(C,_,Math_default.EPSILON7)||E.push(Cartesian3_default.clone(C)))),E.push(_);a&&(h=d[f-1],_=d[0],C=IntersectionTests_default.lineSegmentPlane(h,_,XZ_PLANE,intersectionScratch),!defined_default(C)||Cartesian3_default.equalsEpsilon(C,h,Math_default.EPSILON7)||Cartesian3_default.equalsEpsilon(C,_,Math_default.EPSILON7)||(e.arcType===ArcType_default.GEODESIC?E.push(Cartesian3_default.clone(C)):e.arcType===ArcType_default.RHUMB&&(T=r.cartesianToCartographic(C,cartographicScratch0).longitude,p=r.cartesianToCartographic(h,cartographicScratch0),g=r.cartesianToCartographic(_,cartographicScratch1),m.setEndPoints(p,g),S=m.findIntersectionWithLongitude(T,cartographicIntersectionScratch),C=r.cartographicToCartesian(S,intersectionScratch),!defined_default(C)||Cartesian3_default.equalsEpsilon(C,h,Math_default.EPSILON7)||Cartesian3_default.equalsEpsilon(C,_,Math_default.EPSILON7)||E.push(Cartesian3_default.clone(C)))));let y=E.length,w=new Array(y);for(u=0;u<y;u++){const e=Cartographic_default.fromCartesian(E[u],r);e.height=0,w[u]=e}if(w=arrayRemoveDuplicates_default(w,Cartographic_default.equalsEpsilon),y=w.length,y<2)return;const A=[],N=[],P=[],M=[];let I=previousBottomScratch,H=vertexBottomScratch,G=vertexTopScratch,D=nextBottomScratch,x=vertexNormalScratch;const L=w[0],O=w[1];for(I=getPosition(r,w[y-1],l,I),D=getPosition(r,O,l,D),H=getPosition(r,L,l,H),G=getPosition(r,L,c,G),x=a?computeVertexMiterNormal(I,H,G,D,x):computeRightNormal(L,O,c,r,x),Cartesian3_default.pack(x,N,0),Cartesian3_default.pack(H,P,0),Cartesian3_default.pack(G,M,0),A.push(L.latitude),A.push(L.longitude),interpolateSegment(L,O,l,c,n,i,r,N,P,M,A),u=1;u<y-1;++u){I=Cartesian3_default.clone(H,I),H=Cartesian3_default.clone(D,H);const e=w[u];getPosition(r,e,c,G),getPosition(r,w[u+1],l,D),computeVertexMiterNormal(I,H,G,D,x),s=N.length,Cartesian3_default.pack(x,N,s),Cartesian3_default.pack(H,P,s),Cartesian3_default.pack(G,M,s),A.push(e.latitude),A.push(e.longitude),interpolateSegment(w[u],w[u+1],l,c,n,i,r,N,P,M,A)}const R=w[y-1],k=w[y-2];if(H=getPosition(r,R,l,H),G=getPosition(r,R,c,G),a){const e=w[0];I=getPosition(r,k,l,I),D=getPosition(r,e,l,D),x=computeVertexMiterNormal(I,H,G,D,x)}else x=computeRightNormal(k,R,c,r,x);if(s=N.length,Cartesian3_default.pack(x,N,s),Cartesian3_default.pack(H,P,s),Cartesian3_default.pack(G,M,s),A.push(R.latitude),A.push(R.longitude),a){for(interpolateSegment(R,L,l,c,n,i,r,N,P,M,A),s=N.length,u=0;u<3;++u)N[s+u]=N[u],P[s+u]=P[u],M[s+u]=M[u];A.push(L.latitude),A.push(L.longitude)}return generateGeometryAttributes(a,o,P,M,N,A,t)};var lineDirectionScratch=new Cartesian3_default,matrix3Scratch=new Matrix3_default,quaternionScratch=new Quaternion_default;function breakMiter(e,t,a,r){const n=direction(a,t,lineDirectionScratch),i=Cartesian3_default.dot(n,e);if(i>MITER_BREAK_SMALL||i<MITER_BREAK_LARGE){const t=direction(r,a,vertexUpScratch),n=i<MITER_BREAK_LARGE?Math_default.PI_OVER_TWO:-Math_default.PI_OVER_TWO,o=Quaternion_default.fromAxisAngle(t,n,quaternionScratch),l=Matrix3_default.fromQuaternion(o,matrix3Scratch);return Matrix3_default.multiplyByVector(l,e,e),!0}return!1}var endPosCartographicScratch=new Cartographic_default,normalStartpointScratch=new Cartesian3_default,normalEndpointScratch=new Cartesian3_default;function projectNormal(e,t,a,r,n){const i=Cartographic_default.toCartesian(t,e._ellipsoid,normalStartpointScratch);let o=Cartesian3_default.add(i,a,normalEndpointScratch),l=!1;const c=e._ellipsoid;let s=c.cartesianToCartographic(o,endPosCartographicScratch);Math.abs(t.longitude-s.longitude)>Math_default.PI_OVER_TWO&&(l=!0,o=Cartesian3_default.subtract(i,a,normalEndpointScratch),s=c.cartesianToCartographic(o,endPosCartographicScratch)),s.height=0;const u=e.project(s,n);return(n=Cartesian3_default.subtract(u,r,n)).z=0,n=Cartesian3_default.normalize(n,n),l&&Cartesian3_default.negate(n,n),n}var adjustHeightNormalScratch=new Cartesian3_default,adjustHeightOffsetScratch=new Cartesian3_default;function adjustHeights(e,t,a,r,n,i){const o=Cartesian3_default.subtract(t,e,adjustHeightNormalScratch);Cartesian3_default.normalize(o,o);const l=a-WALL_INITIAL_MIN_HEIGHT;let c=Cartesian3_default.multiplyByScalar(o,l,adjustHeightOffsetScratch);Cartesian3_default.add(e,c,n);const s=r-WALL_INITIAL_MAX_HEIGHT;c=Cartesian3_default.multiplyByScalar(o,s,adjustHeightOffsetScratch),Cartesian3_default.add(t,c,i)}var nudgeDirectionScratch=new Cartesian3_default;function nudgeXZ(e,t){const a=Plane_default.getPointDistance(XZ_PLANE,e),r=Plane_default.getPointDistance(XZ_PLANE,t);let n=nudgeDirectionScratch;Math_default.equalsEpsilon(a,0,Math_default.EPSILON2)?(n=direction(t,e,n),Cartesian3_default.multiplyByScalar(n,Math_default.EPSILON2,n),Cartesian3_default.add(e,n,e)):Math_default.equalsEpsilon(r,0,Math_default.EPSILON2)&&(n=direction(e,t,n),Cartesian3_default.multiplyByScalar(n,Math_default.EPSILON2,n),Cartesian3_default.add(t,n,t))}function nudgeCartographic(e,t){const a=Math.abs(e.longitude),r=Math.abs(t.longitude);if(Math_default.equalsEpsilon(a,Math_default.PI,Math_default.EPSILON11)){const r=Math_default.sign(t.longitude);return e.longitude=r*(a-Math_default.EPSILON11),1}if(Math_default.equalsEpsilon(r,Math_default.PI,Math_default.EPSILON11)){const a=Math_default.sign(e.longitude);return t.longitude=a*(r-Math_default.EPSILON11),2}return 0}var startCartographicScratch=new Cartographic_default,endCartographicScratch=new Cartographic_default,segmentStartTopScratch=new Cartesian3_default,segmentEndTopScratch=new Cartesian3_default,segmentStartBottomScratch=new Cartesian3_default,segmentEndBottomScratch=new Cartesian3_default,segmentStartNormalScratch=new Cartesian3_default,segmentEndNormalScratch=new Cartesian3_default,getHeightCartographics=[startCartographicScratch,endCartographicScratch],getHeightRectangleScratch=new Rectangle_default,adjustHeightStartTopScratch=new Cartesian3_default,adjustHeightEndTopScratch=new Cartesian3_default,adjustHeightStartBottomScratch=new Cartesian3_default,adjustHeightEndBottomScratch=new Cartesian3_default,segmentStart2DScratch=new Cartesian3_default,segmentEnd2DScratch=new Cartesian3_default,segmentStartNormal2DScratch=new Cartesian3_default,segmentEndNormal2DScratch=new Cartesian3_default,offsetScratch=new Cartesian3_default,startUpScratch=new Cartesian3_default,endUpScratch=new Cartesian3_default,rightScratch=new Cartesian3_default,startPlaneNormalScratch=new Cartesian3_default,endPlaneNormalScratch=new Cartesian3_default,encodeScratch=new EncodedCartesian3_default,encodeScratch2D=new EncodedCartesian3_default,forwardOffset2DScratch=new Cartesian3_default,right2DScratch=new Cartesian3_default,normalNudgeScratch=new Cartesian3_default,scratchBoundingSpheres=[new BoundingSphere_default,new BoundingSphere_default],REFERENCE_INDICES=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],REFERENCE_INDICES_LENGTH=REFERENCE_INDICES.length;function generateGeometryAttributes(e,t,a,r,n,i,o){let l,c;const s=t._ellipsoid,u=a.length/3-1,d=8*u,f=4*d,h=36*u,_=d>65535?new Uint32Array(h):new Uint16Array(h),p=new Float64Array(3*d),g=new Float32Array(f),m=new Float32Array(f),C=new Float32Array(f),S=new Float32Array(f),T=new Float32Array(f);let E,y,w,A;o&&(E=new Float32Array(f),y=new Float32Array(f),w=new Float32Array(f),A=new Float32Array(2*d));const N=i.length/2;let P=0;const M=startCartographicScratch;M.height=0;const I=endCartographicScratch;I.height=0;let H=segmentStartTopScratch,G=segmentEndTopScratch;if(o)for(c=0,l=1;l<N;l++)M.latitude=i[c],M.longitude=i[c+1],I.latitude=i[c+2],I.longitude=i[c+3],H=t.project(M,H),G=t.project(I,G),P+=Cartesian3_default.distance(H,G),c+=2;const D=r.length/3;G=Cartesian3_default.unpack(r,0,G);let x,L=0;for(c=3,l=1;l<D;l++)H=Cartesian3_default.clone(G,H),G=Cartesian3_default.unpack(r,c,G),L+=Cartesian3_default.distance(H,G),c+=3;c=3;let O=0,R=0,k=0,j=0,b=!1,v=Cartesian3_default.unpack(a,0,segmentEndBottomScratch),B=Cartesian3_default.unpack(r,0,segmentEndTopScratch),V=Cartesian3_default.unpack(n,0,segmentEndNormalScratch);e&&breakMiter(V,Cartesian3_default.unpack(a,a.length-6,segmentStartBottomScratch),v,B)&&(V=Cartesian3_default.negate(V,V));let X=0,Y=0,z=0;for(l=0;l<u;l++){const e=Cartesian3_default.clone(v,segmentStartBottomScratch),l=Cartesian3_default.clone(B,segmentStartTopScratch);let u,d,f,h,_=Cartesian3_default.clone(V,segmentStartNormalScratch);if(b&&(_=Cartesian3_default.negate(_,_)),v=Cartesian3_default.unpack(a,c,segmentEndBottomScratch),B=Cartesian3_default.unpack(r,c,segmentEndTopScratch),V=Cartesian3_default.unpack(n,c,segmentEndNormalScratch),b=breakMiter(V,e,v,B),M.latitude=i[O],M.longitude=i[O+1],I.latitude=i[O+2],I.longitude=i[O+3],o){const e=nudgeCartographic(M,I);u=t.project(M,segmentStart2DScratch),d=t.project(I,segmentEnd2DScratch);const a=direction(d,u,forwardOffset2DScratch);a.y=Math.abs(a.y),f=segmentStartNormal2DScratch,h=segmentEndNormal2DScratch,0===e||Cartesian3_default.dot(a,Cartesian3_default.UNIT_Y)>MITER_BREAK_SMALL?(f=projectNormal(t,M,_,u,segmentStartNormal2DScratch),h=projectNormal(t,I,V,d,segmentEndNormal2DScratch)):1===e?(h=projectNormal(t,I,V,d,segmentEndNormal2DScratch),f.x=0,f.y=Math_default.sign(M.longitude-Math.abs(I.longitude)),f.z=0):(f=projectNormal(t,M,_,u,segmentStartNormal2DScratch),h.x=0,h.y=Math_default.sign(M.longitude-I.longitude),h.z=0)}const N=Cartesian3_default.distance(l,B),H=EncodedCartesian3_default.fromCartesian(e,encodeScratch),G=Cartesian3_default.subtract(v,e,offsetScratch),D=Cartesian3_default.normalize(G,rightScratch);let U=Cartesian3_default.subtract(l,e,startUpScratch);U=Cartesian3_default.normalize(U,U);let W=Cartesian3_default.cross(D,U,rightScratch);W=Cartesian3_default.normalize(W,W);let Z=Cartesian3_default.cross(U,_,startPlaneNormalScratch);Z=Cartesian3_default.normalize(Z,Z);let F=Cartesian3_default.subtract(B,v,endUpScratch);F=Cartesian3_default.normalize(F,F);let q=Cartesian3_default.cross(V,F,endPlaneNormalScratch);q=Cartesian3_default.normalize(q,q);const J=N/L,K=X/L;let Q,$,ee,te=0,ae=0,re=0;if(o){te=Cartesian3_default.distance(u,d),Q=EncodedCartesian3_default.fromCartesian(u,encodeScratch2D),$=Cartesian3_default.subtract(d,u,forwardOffset2DScratch),ee=Cartesian3_default.normalize($,right2DScratch);const e=ee.x;ee.x=ee.y,ee.y=-e,ae=te/P,re=Y/P}for(x=0;x<8;x++){const e=j+4*x,t=R+2*x,a=e+3,r=x<4?1:-1,n=2===x||3===x||6===x||7===x?1:-1;Cartesian3_default.pack(H.high,g,e),g[a]=G.x,Cartesian3_default.pack(H.low,m,e),m[a]=G.y,Cartesian3_default.pack(Z,C,e),C[a]=G.z,Cartesian3_default.pack(q,S,e),S[a]=J*r,Cartesian3_default.pack(W,T,e);let i=K*n;0===i&&n<0&&(i=9),T[a]=i,o&&(E[e]=Q.high.x,E[e+1]=Q.high.y,E[e+2]=Q.low.x,E[e+3]=Q.low.y,w[e]=-f.y,w[e+1]=f.x,w[e+2]=h.y,w[e+3]=-h.x,y[e]=$.x,y[e+1]=$.y,y[e+2]=ee.x,y[e+3]=ee.y,A[t]=ae*r,i=re*n,0===i&&n<0&&(i=9),A[t+1]=i)}const ne=adjustHeightStartBottomScratch,ie=adjustHeightEndBottomScratch,oe=adjustHeightStartTopScratch,le=adjustHeightEndTopScratch,ce=Rectangle_default.fromCartographicArray(getHeightCartographics,getHeightRectangleScratch),se=ApproximateTerrainHeights_default.getMinimumMaximumHeights(ce,s),ue=se.minimumTerrainHeight,de=se.maximumTerrainHeight;z+=Math.abs(ue),z+=Math.abs(de),adjustHeights(e,l,ue,de,ne,oe),adjustHeights(v,B,ue,de,ie,le);let fe=Cartesian3_default.multiplyByScalar(W,Math_default.EPSILON5,normalNudgeScratch);Cartesian3_default.add(ne,fe,ne),Cartesian3_default.add(ie,fe,ie),Cartesian3_default.add(oe,fe,oe),Cartesian3_default.add(le,fe,le),nudgeXZ(ne,ie),nudgeXZ(oe,le),Cartesian3_default.pack(ne,p,k),Cartesian3_default.pack(ie,p,k+3),Cartesian3_default.pack(le,p,k+6),Cartesian3_default.pack(oe,p,k+9),fe=Cartesian3_default.multiplyByScalar(W,-2*Math_default.EPSILON5,normalNudgeScratch),Cartesian3_default.add(ne,fe,ne),Cartesian3_default.add(ie,fe,ie),Cartesian3_default.add(oe,fe,oe),Cartesian3_default.add(le,fe,le),nudgeXZ(ne,ie),nudgeXZ(oe,le),Cartesian3_default.pack(ne,p,k+12),Cartesian3_default.pack(ie,p,k+15),Cartesian3_default.pack(le,p,k+18),Cartesian3_default.pack(oe,p,k+21),O+=2,c+=3,R+=16,k+=24,j+=32,X+=N,Y+=te}c=0;let U=0;for(l=0;l<u;l++){for(x=0;x<REFERENCE_INDICES_LENGTH;x++)_[c+x]=REFERENCE_INDICES[x]+U;U+=8,c+=REFERENCE_INDICES_LENGTH}const W=scratchBoundingSpheres;BoundingSphere_default.fromVertices(a,Cartesian3_default.ZERO,3,W[0]),BoundingSphere_default.fromVertices(r,Cartesian3_default.ZERO,3,W[1]);const Z=BoundingSphere_default.fromBoundingSpheres(W);Z.radius+=z/(2*u);const F={position:new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,normalize:!1,values:p}),startHiAndForwardOffsetX:getVec4GeometryAttribute(g),startLoAndForwardOffsetY:getVec4GeometryAttribute(m),startNormalAndForwardOffsetZ:getVec4GeometryAttribute(C),endNormalAndTextureCoordinateNormalizationX:getVec4GeometryAttribute(S),rightNormalAndTextureCoordinateNormalizationY:getVec4GeometryAttribute(T)};return o&&(F.startHiLo2D=getVec4GeometryAttribute(E),F.offsetAndRight2D=getVec4GeometryAttribute(y),F.startEndNormals2D=getVec4GeometryAttribute(w),F.texcoordNormalization2D=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,normalize:!1,values:A})),new Geometry_default({attributes:F,indices:_,boundingSphere:Z})}function getVec4GeometryAttribute(e){return new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}GroundPolylineGeometry._projectNormal=projectNormal;var GroundPolylineGeometry_default=GroundPolylineGeometry;function createGroundPolylineGeometry(e,t){return ApproximateTerrainHeights_default.initialize().then((function(){return defined_default(t)&&(e=GroundPolylineGeometry_default.unpack(e,t)),GroundPolylineGeometry_default.createGeometry(e)}))}var createGroundPolylineGeometry_default=createGroundPolylineGeometry;export{createGroundPolylineGeometry_default as default};