define(["./Transforms-e2d4a55a","./Matrix2-e1298525","./Matrix3-41c58dde","./Check-6ede7e26","./defaultValue-fe22d8c0","./Math-0a2ac845","./ArcType-2d9abbbc","./arrayRemoveDuplicates-d2061e85","./ComponentDatatype-cf1fa08e","./EllipsoidGeodesic-5b3623dc","./EllipsoidRhumbLine-ef872433","./EncodedCartesian3-57415c8a","./GeometryAttribute-13da9466","./IntersectionTests-85350792","./Plane-4c3d403b","./WebMercatorProjection-13ed1a6e","./combine-d9581036","./RuntimeError-ef395448","./WebGLConstants-0b1ce7ba"],(function(e,t,a,n,i,r,s,o,l,c,u,C,d,p,h,g,f,m,w){"use strict";function y(n){n=i.defaultValue(n,i.defaultValue.EMPTY_OBJECT),this._ellipsoid=i.defaultValue(n.ellipsoid,a.Ellipsoid.WGS84),this._rectangle=i.defaultValue(n.rectangle,t.Rectangle.MAX_VALUE),this._projection=new e.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=i.defaultValue(n.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=i.defaultValue(n.numberOfLevelZeroTilesY,1)}Object.defineProperties(y.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),y.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},y.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},y.prototype.rectangleToNativeRectangle=function(e,a){n.Check.defined("rectangle",e);const s=r.CesiumMath.toDegrees(e.west),o=r.CesiumMath.toDegrees(e.south),l=r.CesiumMath.toDegrees(e.east),c=r.CesiumMath.toDegrees(e.north);return i.defined(a)?(a.west=s,a.south=o,a.east=l,a.north=c,a):new t.Rectangle(s,o,l,c)},y.prototype.tileXYToNativeRectangle=function(e,t,a,n){const i=this.tileXYToRectangle(e,t,a,n);return i.west=r.CesiumMath.toDegrees(i.west),i.south=r.CesiumMath.toDegrees(i.south),i.east=r.CesiumMath.toDegrees(i.east),i.north=r.CesiumMath.toDegrees(i.north),i},y.prototype.tileXYToRectangle=function(e,a,n,r){const s=this._rectangle,o=this.getNumberOfXTilesAtLevel(n),l=this.getNumberOfYTilesAtLevel(n),c=s.width/o,u=e*c+s.west,C=(e+1)*c+s.west,d=s.height/l,p=s.north-a*d,h=s.north-(a+1)*d;return i.defined(r)||(r=new t.Rectangle(u,h,C,p)),r.west=u,r.south=h,r.east=C,r.north=p,r},y.prototype.positionToTileXY=function(e,a,n){const s=this._rectangle;if(!t.Rectangle.contains(s,e))return;const o=this.getNumberOfXTilesAtLevel(a),l=this.getNumberOfYTilesAtLevel(a),c=s.width/o,u=s.height/l;let C=e.longitude;s.east<s.west&&(C+=r.CesiumMath.TWO_PI);let d=(C-s.west)/c|0;d>=o&&(d=o-1);let p=(s.north-e.latitude)/u|0;return p>=l&&(p=l-1),i.defined(n)?(n.x=d,n.y=p,n):new t.Cartesian2(d,p)};const T=new a.Cartesian3,E=new a.Cartesian3,M=new a.Cartographic,_=new a.Cartesian3,O=new a.Cartesian3,b=new e.BoundingSphere,A=new y,k=[new a.Cartographic,new a.Cartographic,new a.Cartographic,new a.Cartographic],P=new t.Cartesian2,S={};function L(e){a.Cartographic.fromRadians(e.east,e.north,0,k[0]),a.Cartographic.fromRadians(e.west,e.north,0,k[1]),a.Cartographic.fromRadians(e.east,e.south,0,k[2]),a.Cartographic.fromRadians(e.west,e.south,0,k[3]);let t=0,n=0,i=0,r=0;const s=S._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let t=0;t<4;++t){const a=k[t];if(A.positionToTileXY(a,o,P),0===t)i=P.x,r=P.y;else if(i!==P.x||r!==P.y){e=!0;break}}if(e)break;t=i,n=r}if(0!==o)return{x:t,y:n,level:o>s?s:o-1}}S.initialize=function(){let t=S._initPromise;return i.defined(t)||(t=e.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){S._terrainHeights=e})),S._initPromise=t),t},S.getMinimumMaximumHeights=function(e,r){if(n.Check.defined("rectangle",e),!i.defined(S._terrainHeights))throw new n.DeveloperError("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");r=i.defaultValue(r,a.Ellipsoid.WGS84);const s=L(e);let o=S._defaultMinTerrainHeight,l=S._defaultMaxTerrainHeight;if(i.defined(s)){const n=`${s.level}-${s.x}-${s.y}`,c=S._terrainHeights[n];i.defined(c)&&(o=c[0],l=c[1]),r.cartographicToCartesian(t.Rectangle.northeast(e,M),T),r.cartographicToCartesian(t.Rectangle.southwest(e,M),E),a.Cartesian3.midpoint(E,T,_);const u=r.scaleToGeodeticSurface(_,O);if(i.defined(u)){const e=a.Cartesian3.distance(_,u);o=Math.min(o,-e)}else o=S._defaultMinTerrainHeight}return o=Math.max(S._defaultMinTerrainHeight,o),{minimumTerrainHeight:o,maximumTerrainHeight:l}},S.getBoundingSphere=function(t,r){if(n.Check.defined("rectangle",t),!i.defined(S._terrainHeights))throw new n.DeveloperError("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");r=i.defaultValue(r,a.Ellipsoid.WGS84);const s=L(t);let o=S._defaultMaxTerrainHeight;if(i.defined(s)){const e=`${s.level}-${s.x}-${s.y}`,t=S._terrainHeights[e];i.defined(t)&&(o=t[1])}const l=e.BoundingSphere.fromRectangle3D(t,r,0);return e.BoundingSphere.fromRectangle3D(t,r,o,b),e.BoundingSphere.union(l,b,l)},S._terrainHeightsMaxLevel=6,S._defaultMaxTerrainHeight=9e3,S._defaultMinTerrainHeight=-1e5,S._terrainHeights=void 0,S._initPromise=void 0,Object.defineProperties(S,{initialized:{get:function(){return i.defined(S._terrainHeights)}}});var x=S;const I=[e.GeographicProjection,g.WebMercatorProjection],D=I.length,N=Math.cos(r.CesiumMath.toRadians(30)),R=Math.cos(r.CesiumMath.toRadians(150));function v(e){const t=(e=i.defaultValue(e,i.defaultValue.EMPTY_OBJECT)).positions;if(!i.defined(t)||t.length<2)throw new n.DeveloperError("At least two positions are required.");if(i.defined(e.arcType)&&e.arcType!==s.ArcType.GEODESIC&&e.arcType!==s.ArcType.RHUMB)throw new n.DeveloperError("Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.");this.width=i.defaultValue(e.width,1),this._positions=t,this.granularity=i.defaultValue(e.granularity,9999),this.loop=i.defaultValue(e.loop,!1),this.arcType=i.defaultValue(e.arcType,s.ArcType.GEODESIC),this._ellipsoid=a.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(v.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+a.Ellipsoid.packedLength+1+1}}}),v.setProjectionAndEllipsoid=function(e,t){let a=0;for(let e=0;e<D;e++)if(t instanceof I[e]){a=e;break}e._projectionIndex=a,e._ellipsoid=t.ellipsoid};const H=new a.Cartesian3,z=new a.Cartesian3,B=new a.Cartesian3;function G(e,t,n,i,r){const s=U(i,e,0,H),o=U(i,e,n,z),l=U(i,t,0,B),c=W(o,s,z),u=W(l,s,B);return a.Cartesian3.cross(u,c,r),a.Cartesian3.normalize(r,r)}const V=new a.Cartographic,j=new a.Cartesian3,Y=new a.Cartesian3,q=new a.Cartesian3;function F(e,t,n,i,r,o,l,C,d,p,h){if(0===r)return;let g;o===s.ArcType.GEODESIC?g=new c.EllipsoidGeodesic(e,t,l):o===s.ArcType.RHUMB&&(g=new u.EllipsoidRhumbLine(e,t,l));const f=g.surfaceDistance;if(f<r)return;const m=G(e,t,i,l,q),w=Math.ceil(f/r),y=f/w;let T=y;const E=w-1;let M=C.length;for(let e=0;e<E;e++){const e=g.interpolateUsingSurfaceDistance(T,V),t=U(l,e,n,j),r=U(l,e,i,Y);a.Cartesian3.pack(m,C,M),a.Cartesian3.pack(t,d,M),a.Cartesian3.pack(r,p,M),h.push(e.latitude),h.push(e.longitude),M+=3,T+=y}}const X=new a.Cartographic;function U(e,t,n,i){return a.Cartographic.clone(t,X),X.height=n,a.Cartographic.toCartesian(X,e,i)}function W(e,t,n){return a.Cartesian3.subtract(e,t,n),a.Cartesian3.normalize(n,n),n}function Z(e,t,n,i){return i=W(e,t,i),i=a.Cartesian3.cross(i,n,i),i=a.Cartesian3.normalize(i,i),a.Cartesian3.cross(n,i,i)}v.pack=function(e,t,r){n.Check.typeOf.object("value",e),n.Check.defined("array",t);let s=i.defaultValue(r,0);const o=e._positions,l=o.length;t[s++]=l;for(let e=0;e<l;++e){const n=o[e];a.Cartesian3.pack(n,t,s),s+=3}return t[s++]=e.granularity,t[s++]=e.loop?1:0,t[s++]=e.arcType,a.Ellipsoid.pack(e._ellipsoid,t,s),s+=a.Ellipsoid.packedLength,t[s++]=e._projectionIndex,t[s++]=e._scene3DOnly?1:0,t},v.unpack=function(e,t,r){n.Check.defined("array",e);let s=i.defaultValue(t,0);const o=e[s++],l=new Array(o);for(let t=0;t<o;t++)l[t]=a.Cartesian3.unpack(e,s),s+=3;const c=e[s++],u=1===e[s++],C=e[s++],d=a.Ellipsoid.unpack(e,s);s+=a.Ellipsoid.packedLength;const p=e[s++],h=1===e[s++];return i.defined(r)||(r=new v({positions:l})),r._positions=l,r.granularity=c,r.loop=u,r.arcType=C,r._ellipsoid=d,r._projectionIndex=p,r._scene3DOnly=h,r};const $=new a.Cartesian3,J=new a.Cartesian3,Q=new a.Cartesian3,K=new a.Cartesian3;function ee(e,t,n,i,s){const o=W(n,t,K),l=Z(e,t,o,$),c=Z(i,t,o,J);if(r.CesiumMath.equalsEpsilon(a.Cartesian3.dot(l,c),-1,r.CesiumMath.EPSILON5))return s=a.Cartesian3.cross(o,l,s),a.Cartesian3.normalize(s,s);s=a.Cartesian3.add(c,l,s),s=a.Cartesian3.normalize(s,s);const u=a.Cartesian3.cross(o,s,Q);return a.Cartesian3.dot(c,u)<0&&(s=a.Cartesian3.negate(s,s)),s}const te=h.Plane.fromPointNormal(a.Cartesian3.ZERO,a.Cartesian3.UNIT_Y),ae=new a.Cartesian3,ne=new a.Cartesian3,ie=new a.Cartesian3,re=new a.Cartesian3,se=new a.Cartesian3,oe=new a.Cartesian3,le=new a.Cartographic,ce=new a.Cartographic,ue=new a.Cartographic;v.createGeometry=function(n){const c=!n._scene3DOnly;let h=n.loop;const g=n._ellipsoid,f=n.granularity,m=n.arcType,w=new I[n._projectionIndex](g),y=1e3;let T,E;const M=n._positions,_=M.length;let O,b,A,k;2===_&&(h=!1);const P=new u.EllipsoidRhumbLine(void 0,void 0,g);let S,L,D;const R=[M[0]];for(E=0;E<_-1;E++)O=M[E],b=M[E+1],S=p.IntersectionTests.lineSegmentPlane(O,b,te,oe),!i.defined(S)||a.Cartesian3.equalsEpsilon(S,O,r.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(S,b,r.CesiumMath.EPSILON7)||(n.arcType===s.ArcType.GEODESIC?R.push(a.Cartesian3.clone(S)):n.arcType===s.ArcType.RHUMB&&(D=g.cartesianToCartographic(S,le).longitude,A=g.cartesianToCartographic(O,le),k=g.cartesianToCartographic(b,ce),P.setEndPoints(A,k),L=P.findIntersectionWithLongitude(D,ue),S=g.cartographicToCartesian(L,oe),!i.defined(S)||a.Cartesian3.equalsEpsilon(S,O,r.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(S,b,r.CesiumMath.EPSILON7)||R.push(a.Cartesian3.clone(S)))),R.push(b);h&&(O=M[_-1],b=M[0],S=p.IntersectionTests.lineSegmentPlane(O,b,te,oe),!i.defined(S)||a.Cartesian3.equalsEpsilon(S,O,r.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(S,b,r.CesiumMath.EPSILON7)||(n.arcType===s.ArcType.GEODESIC?R.push(a.Cartesian3.clone(S)):n.arcType===s.ArcType.RHUMB&&(D=g.cartesianToCartographic(S,le).longitude,A=g.cartesianToCartographic(O,le),k=g.cartesianToCartographic(b,ce),P.setEndPoints(A,k),L=P.findIntersectionWithLongitude(D,ue),S=g.cartographicToCartesian(L,oe),!i.defined(S)||a.Cartesian3.equalsEpsilon(S,O,r.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(S,b,r.CesiumMath.EPSILON7)||R.push(a.Cartesian3.clone(S)))));let v=R.length,H=new Array(v);for(E=0;E<v;E++){const e=a.Cartographic.fromCartesian(R[E],g);e.height=0,H[E]=e}if(H=o.arrayRemoveDuplicates(H,a.Cartographic.equalsEpsilon),v=H.length,v<2)return;const z=[],B=[],V=[],j=[];let Y=ae,q=ne,X=ie,Z=re,$=se;const J=H[0],Q=H[1];for(Y=U(g,H[v-1],0,Y),Z=U(g,Q,0,Z),q=U(g,J,0,q),X=U(g,J,y,X),$=h?ee(Y,q,X,Z,$):G(J,Q,y,g,$),a.Cartesian3.pack($,B,0),a.Cartesian3.pack(q,V,0),a.Cartesian3.pack(X,j,0),z.push(J.latitude),z.push(J.longitude),F(J,Q,0,y,f,m,g,B,V,j,z),E=1;E<v-1;++E){Y=a.Cartesian3.clone(q,Y),q=a.Cartesian3.clone(Z,q);const e=H[E];U(g,e,y,X),U(g,H[E+1],0,Z),ee(Y,q,X,Z,$),T=B.length,a.Cartesian3.pack($,B,T),a.Cartesian3.pack(q,V,T),a.Cartesian3.pack(X,j,T),z.push(e.latitude),z.push(e.longitude),F(H[E],H[E+1],0,y,f,m,g,B,V,j,z)}const K=H[v-1],Ce=H[v-2];if(q=U(g,K,0,q),X=U(g,K,y,X),h){const e=H[0];Y=U(g,Ce,0,Y),Z=U(g,e,0,Z),$=ee(Y,q,X,Z,$)}else $=G(Ce,K,y,g,$);if(T=B.length,a.Cartesian3.pack($,B,T),a.Cartesian3.pack(q,V,T),a.Cartesian3.pack(X,j,T),z.push(K.latitude),z.push(K.longitude),h){for(F(K,J,0,y,f,m,g,B,V,j,z),T=B.length,E=0;E<3;++E)B[T+E]=B[E],V[T+E]=V[E],j[T+E]=j[E];z.push(J.latitude),z.push(J.longitude)}return function(n,i,s,o,c,u,p){let h,g;const f=i._ellipsoid,m=s.length/3-1,w=8*m,y=4*w,T=36*m,E=w>65535?new Uint32Array(T):new Uint16Array(T),M=new Float64Array(3*w),_=new Float32Array(y),O=new Float32Array(y),b=new Float32Array(y),A=new Float32Array(y),k=new Float32Array(y);let P,S,L,I;p&&(P=new Float32Array(y),S=new Float32Array(y),L=new Float32Array(y),I=new Float32Array(2*w));const D=u.length/2;let R=0;const v=be;v.height=0;const H=Ae;H.height=0;let z=ke,B=Pe;if(p)for(g=0,h=1;h<D;h++)v.latitude=u[g],v.longitude=u[g+1],H.latitude=u[g+2],H.longitude=u[g+3],z=i.project(v,z),B=i.project(H,B),R+=a.Cartesian3.distance(z,B),g+=2;const G=o.length/3;B=a.Cartesian3.unpack(o,0,B);let V,j=0;for(g=3,h=1;h<G;h++)z=a.Cartesian3.clone(B,z),B=a.Cartesian3.unpack(o,g,B),j+=a.Cartesian3.distance(z,B),g+=3;g=3;let Y=0,q=0,F=0,X=0,U=!1,Z=a.Cartesian3.unpack(s,0,Le),$=a.Cartesian3.unpack(o,0,Pe),J=a.Cartesian3.unpack(c,0,Ie);n&&he(J,a.Cartesian3.unpack(s,s.length-6,Se),Z,$)&&(J=a.Cartesian3.negate(J,J));let Q=0,K=0,ee=0;for(h=0;h<m;h++){const e=a.Cartesian3.clone(Z,Se),n=a.Cartesian3.clone($,ke);let l,d,h,m,w=a.Cartesian3.clone(J,xe);if(U&&(w=a.Cartesian3.negate(w,w)),Z=a.Cartesian3.unpack(s,g,Le),$=a.Cartesian3.unpack(o,g,Pe),J=a.Cartesian3.unpack(c,g,Ie),U=he(J,e,Z,$),v.latitude=u[Y],v.longitude=u[Y+1],H.latitude=u[Y+2],H.longitude=u[Y+3],p){const e=Oe(v,H);l=i.project(v,Be),d=i.project(H,Ge);const t=W(d,l,Je);t.y=Math.abs(t.y),h=Ve,m=je,0===e||a.Cartesian3.dot(t,a.Cartesian3.UNIT_Y)>N?(h=we(i,v,w,l,Ve),m=we(i,H,J,d,je)):1===e?(m=we(i,H,J,d,je),h.x=0,h.y=r.CesiumMath.sign(v.longitude-Math.abs(H.longitude)),h.z=0):(h=we(i,v,w,l,Ve),m.x=0,m.y=r.CesiumMath.sign(v.longitude-H.longitude),m.z=0)}const y=a.Cartesian3.distance(n,$),T=C.EncodedCartesian3.fromCartesian(e,Ze),E=a.Cartesian3.subtract(Z,e,Ye),D=a.Cartesian3.normalize(E,Xe);let z=a.Cartesian3.subtract(n,e,qe);z=a.Cartesian3.normalize(z,z);let B=a.Cartesian3.cross(D,z,Xe);B=a.Cartesian3.normalize(B,B);let G=a.Cartesian3.cross(z,w,Ue);G=a.Cartesian3.normalize(G,G);let te=a.Cartesian3.subtract($,Z,Fe);te=a.Cartesian3.normalize(te,te);let ae=a.Cartesian3.cross(J,te,We);ae=a.Cartesian3.normalize(ae,ae);const ne=y/j,ie=Q/j;let re,se,oe,le=0,ce=0,ue=0;if(p){le=a.Cartesian3.distance(l,d),re=C.EncodedCartesian3.fromCartesian(l,$e),se=a.Cartesian3.subtract(d,l,Je),oe=a.Cartesian3.normalize(se,Qe);const e=oe.x;oe.x=oe.y,oe.y=-e,ce=le/R,ue=K/R}for(V=0;V<8;V++){const e=X+4*V,t=q+2*V,n=e+3,i=V<4?1:-1,r=2===V||3===V||6===V||7===V?1:-1;a.Cartesian3.pack(T.high,_,e),_[n]=E.x,a.Cartesian3.pack(T.low,O,e),O[n]=E.y,a.Cartesian3.pack(G,b,e),b[n]=E.z,a.Cartesian3.pack(ae,A,e),A[n]=ne*i,a.Cartesian3.pack(B,k,e);let s=ie*r;0===s&&r<0&&(s=9),k[n]=s,p&&(P[e]=re.high.x,P[e+1]=re.high.y,P[e+2]=re.low.x,P[e+3]=re.low.y,L[e]=-h.y,L[e+1]=h.x,L[e+2]=m.y,L[e+3]=-m.x,S[e]=se.x,S[e+1]=se.y,S[e+2]=oe.x,S[e+3]=oe.y,I[t]=ce*i,s=ue*r,0===s&&r<0&&(s=9),I[t+1]=s)}const Ce=He,de=ze,pe=Re,ge=ve,fe=t.Rectangle.fromCartographicArray(De,Ne),me=x.getMinimumMaximumHeights(fe,f),ye=me.minimumTerrainHeight,Te=me.maximumTerrainHeight;ee+=ye,ee+=Te,Ee(e,n,ye,Te,Ce,pe),Ee(Z,$,ye,Te,de,ge);let Me=a.Cartesian3.multiplyByScalar(B,r.CesiumMath.EPSILON5,Ke);a.Cartesian3.add(Ce,Me,Ce),a.Cartesian3.add(de,Me,de),a.Cartesian3.add(pe,Me,pe),a.Cartesian3.add(ge,Me,ge),_e(Ce,de),_e(pe,ge),a.Cartesian3.pack(Ce,M,F),a.Cartesian3.pack(de,M,F+3),a.Cartesian3.pack(ge,M,F+6),a.Cartesian3.pack(pe,M,F+9),Me=a.Cartesian3.multiplyByScalar(B,-2*r.CesiumMath.EPSILON5,Ke),a.Cartesian3.add(Ce,Me,Ce),a.Cartesian3.add(de,Me,de),a.Cartesian3.add(pe,Me,pe),a.Cartesian3.add(ge,Me,ge),_e(Ce,de),_e(pe,ge),a.Cartesian3.pack(Ce,M,F+12),a.Cartesian3.pack(de,M,F+15),a.Cartesian3.pack(ge,M,F+18),a.Cartesian3.pack(pe,M,F+21),Y+=2,g+=3,q+=16,F+=24,X+=32,Q+=y,K+=le}g=0;let te=0;for(h=0;h<m;h++){for(V=0;V<at;V++)E[g+V]=tt[V]+te;te+=8,g+=at}const ae=et;e.BoundingSphere.fromVertices(s,a.Cartesian3.ZERO,3,ae[0]),e.BoundingSphere.fromVertices(o,a.Cartesian3.ZERO,3,ae[1]);const ne=e.BoundingSphere.fromBoundingSpheres(ae);ne.radius+=ee/(2*m);const ie={position:new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:M}),startHiAndForwardOffsetX:nt(_),startLoAndForwardOffsetY:nt(O),startNormalAndForwardOffsetZ:nt(b),endNormalAndTextureCoordinateNormalizationX:nt(A),rightNormalAndTextureCoordinateNormalizationY:nt(k)};return p&&(ie.startHiLo2D=nt(P),ie.offsetAndRight2D=nt(S),ie.startEndNormals2D=nt(L),ie.texcoordNormalization2D=new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:I})),new d.Geometry({attributes:ie,indices:E,boundingSphere:ne})}(h,w,V,j,B,z,c)};const Ce=new a.Cartesian3,de=new a.Matrix3,pe=new e.Quaternion;function he(t,n,i,s){const o=W(i,n,Ce),l=a.Cartesian3.dot(o,t);if(l>N||l<R){const n=W(s,i,K),o=l<R?r.CesiumMath.PI_OVER_TWO:-r.CesiumMath.PI_OVER_TWO,c=e.Quaternion.fromAxisAngle(n,o,pe),u=a.Matrix3.fromQuaternion(c,de);return a.Matrix3.multiplyByVector(u,t,t),!0}return!1}const ge=new a.Cartographic,fe=new a.Cartesian3,me=new a.Cartesian3;function we(e,t,n,i,s){const o=a.Cartographic.toCartesian(t,e._ellipsoid,fe);let l=a.Cartesian3.add(o,n,me),c=!1;const u=e._ellipsoid;let C=u.cartesianToCartographic(l,ge);Math.abs(t.longitude-C.longitude)>r.CesiumMath.PI_OVER_TWO&&(c=!0,l=a.Cartesian3.subtract(o,n,me),C=u.cartesianToCartographic(l,ge)),C.height=0;const d=e.project(C,s);return(s=a.Cartesian3.subtract(d,i,s)).z=0,s=a.Cartesian3.normalize(s,s),c&&a.Cartesian3.negate(s,s),s}const ye=new a.Cartesian3,Te=new a.Cartesian3;function Ee(e,t,n,i,r,s){const o=a.Cartesian3.subtract(t,e,ye);a.Cartesian3.normalize(o,o);const l=n-0;let c=a.Cartesian3.multiplyByScalar(o,l,Te);a.Cartesian3.add(e,c,r);const u=i-1e3;c=a.Cartesian3.multiplyByScalar(o,u,Te),a.Cartesian3.add(t,c,s)}const Me=new a.Cartesian3;function _e(e,t){const n=h.Plane.getPointDistance(te,e),i=h.Plane.getPointDistance(te,t);let s=Me;r.CesiumMath.equalsEpsilon(n,0,r.CesiumMath.EPSILON2)?(s=W(t,e,s),a.Cartesian3.multiplyByScalar(s,r.CesiumMath.EPSILON2,s),a.Cartesian3.add(e,s,e)):r.CesiumMath.equalsEpsilon(i,0,r.CesiumMath.EPSILON2)&&(s=W(e,t,s),a.Cartesian3.multiplyByScalar(s,r.CesiumMath.EPSILON2,s),a.Cartesian3.add(t,s,t))}function Oe(e,t){const a=Math.abs(e.longitude),n=Math.abs(t.longitude);if(r.CesiumMath.equalsEpsilon(a,r.CesiumMath.PI,r.CesiumMath.EPSILON11)){const n=r.CesiumMath.sign(t.longitude);return e.longitude=n*(a-r.CesiumMath.EPSILON11),1}if(r.CesiumMath.equalsEpsilon(n,r.CesiumMath.PI,r.CesiumMath.EPSILON11)){const a=r.CesiumMath.sign(e.longitude);return t.longitude=a*(n-r.CesiumMath.EPSILON11),2}return 0}const be=new a.Cartographic,Ae=new a.Cartographic,ke=new a.Cartesian3,Pe=new a.Cartesian3,Se=new a.Cartesian3,Le=new a.Cartesian3,xe=new a.Cartesian3,Ie=new a.Cartesian3,De=[be,Ae],Ne=new t.Rectangle,Re=new a.Cartesian3,ve=new a.Cartesian3,He=new a.Cartesian3,ze=new a.Cartesian3,Be=new a.Cartesian3,Ge=new a.Cartesian3,Ve=new a.Cartesian3,je=new a.Cartesian3,Ye=new a.Cartesian3,qe=new a.Cartesian3,Fe=new a.Cartesian3,Xe=new a.Cartesian3,Ue=new a.Cartesian3,We=new a.Cartesian3,Ze=new C.EncodedCartesian3,$e=new C.EncodedCartesian3,Je=new a.Cartesian3,Qe=new a.Cartesian3,Ke=new a.Cartesian3,et=[new e.BoundingSphere,new e.BoundingSphere],tt=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],at=tt.length;function nt(e){return new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}return v._projectNormal=we,function(e,t){return x.initialize().then((function(){return i.defined(t)&&(e=v.unpack(e,t)),v.createGeometry(e)}))}}));