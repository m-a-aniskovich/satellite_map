define(["exports","./Transforms-e2d4a55a","./Matrix3-41c58dde","./ComponentDatatype-cf1fa08e","./defaultValue-fe22d8c0","./Check-6ede7e26","./EllipseGeometryLibrary-21262a28","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./GeometryOffsetAttribute-9ad0019c","./IndexDatatype-2643aa47","./Math-0a2ac845"],(function(e,t,i,r,n,o,a,s,l,u,d,c){"use strict";const f=new i.Cartesian3;let p=new i.Cartesian3;const m=new t.BoundingSphere,h=new t.BoundingSphere;function y(e){const t=(e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT)).center,r=n.defaultValue(e.ellipsoid,i.Ellipsoid.WGS84),a=e.semiMajorAxis,s=e.semiMinorAxis,l=n.defaultValue(e.granularity,c.CesiumMath.RADIANS_PER_DEGREE);if(!n.defined(t))throw new o.DeveloperError("center is required.");if(!n.defined(a))throw new o.DeveloperError("semiMajorAxis is required.");if(!n.defined(s))throw new o.DeveloperError("semiMinorAxis is required.");if(a<s)throw new o.DeveloperError("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(l<=0)throw new o.DeveloperError("granularity must be greater than zero.");const u=n.defaultValue(e.height,0),d=n.defaultValue(e.extrudedHeight,u);this._center=i.Cartesian3.clone(t),this._semiMajorAxis=a,this._semiMinorAxis=s,this._ellipsoid=i.Ellipsoid.clone(r),this._rotation=n.defaultValue(e.rotation,0),this._height=Math.max(d,u),this._granularity=l,this._extrudedHeight=Math.min(d,u),this._numberOfVerticalLines=Math.max(n.defaultValue(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}y.packedLength=i.Cartesian3.packedLength+i.Ellipsoid.packedLength+8,y.pack=function(e,t,r){if(!n.defined(e))throw new o.DeveloperError("value is required");if(!n.defined(t))throw new o.DeveloperError("array is required");return r=n.defaultValue(r,0),i.Cartesian3.pack(e._center,t,r),r+=i.Cartesian3.packedLength,i.Ellipsoid.pack(e._ellipsoid,t,r),r+=i.Ellipsoid.packedLength,t[r++]=e._semiMajorAxis,t[r++]=e._semiMinorAxis,t[r++]=e._rotation,t[r++]=e._height,t[r++]=e._granularity,t[r++]=e._extrudedHeight,t[r++]=e._numberOfVerticalLines,t[r]=n.defaultValue(e._offsetAttribute,-1),t};const A=new i.Cartesian3,b=new i.Ellipsoid,_={center:A,ellipsoid:b,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};y.unpack=function(e,t,r){if(!n.defined(e))throw new o.DeveloperError("array is required");t=n.defaultValue(t,0);const a=i.Cartesian3.unpack(e,t,A);t+=i.Cartesian3.packedLength;const s=i.Ellipsoid.unpack(e,t,b);t+=i.Ellipsoid.packedLength;const l=e[t++],u=e[t++],d=e[t++],c=e[t++],f=e[t++],p=e[t++],m=e[t++],h=e[t];return n.defined(r)?(r._center=i.Cartesian3.clone(a,r._center),r._ellipsoid=i.Ellipsoid.clone(s,r._ellipsoid),r._semiMajorAxis=l,r._semiMinorAxis=u,r._rotation=d,r._height=c,r._granularity=f,r._extrudedHeight=p,r._numberOfVerticalLines=m,r._offsetAttribute=-1===h?void 0:h,r):(_.height=c,_.extrudedHeight=p,_.granularity=f,_.rotation=d,_.semiMajorAxis=l,_.semiMinorAxis=u,_.numberOfVerticalLines=m,_.offsetAttribute=-1===h?void 0:h,new y(_))},y.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const o=e._height,y=e._extrudedHeight,A=!c.CesiumMath.equalsEpsilon(o,y,0,c.CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const b={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:o,granularity:e._granularity,numberOfVerticalLines:e._numberOfVerticalLines};let _;if(A)b.extrudedHeight=y,b.offsetAttribute=e._offsetAttribute,_=function(e){const o=e.center,p=e.ellipsoid,y=e.semiMajorAxis;let A=i.Cartesian3.multiplyByScalar(p.geodeticSurfaceNormal(o,f),e.height,f);m.center=i.Cartesian3.add(o,A,m.center),m.radius=y,A=i.Cartesian3.multiplyByScalar(p.geodeticSurfaceNormal(o,A),e.extrudedHeight,A),h.center=i.Cartesian3.add(o,A,h.center),h.radius=y;let b=a.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions;const _=new l.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a.EllipseGeometryLibrary.raisePositionsToHeight(b,e,!0)})});b=_.position.values;const g=t.BoundingSphere.union(m,h);let E=b.length/3;if(n.defined(e.offsetAttribute)){let t=new Uint8Array(E);if(e.offsetAttribute===u.GeometryOffsetAttribute.TOP)t=t.fill(1,0,E/2);else{const i=e.offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}_.applyOffset=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let x=n.defaultValue(e.numberOfVerticalLines,16);x=c.CesiumMath.clamp(x,0,E/2);const M=d.IndexDatatype.createTypedArray(E,2*E+2*x);E/=2;let w,v,C=0;for(w=0;w<E;++w)M[C++]=w,M[C++]=(w+1)%E,M[C++]=w+E,M[C++]=(w+1)%E+E;if(x>0){const e=Math.min(x,E);v=Math.round(E/e);const t=Math.min(v*x,E);for(w=0;w<t;w+=v)M[C++]=w,M[C++]=w+E}return{boundingSphere:g,attributes:_,indices:M}}(b);else if(_=function(e){const n=e.center;p=i.Cartesian3.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(n,p),e.height,p),p=i.Cartesian3.add(n,p,p);const o=new t.BoundingSphere(p,e.semiMajorAxis),u=a.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions,c=new l.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a.EllipseGeometryLibrary.raisePositionsToHeight(u,e,!1)})}),f=u.length/3,m=d.IndexDatatype.createTypedArray(f,2*f);let h=0;for(let e=0;e<f;++e)m[h++]=e,m[h++]=(e+1)%f;return{boundingSphere:o,attributes:c,indices:m}}(b),n.defined(e._offsetAttribute)){const t=_.attributes.position.values.length,i=e._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(t/3).fill(i);_.attributes.applyOffset=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new s.Geometry({attributes:_.attributes,indices:_.indices,primitiveType:s.PrimitiveType.LINES,boundingSphere:_.boundingSphere,offsetAttribute:e._offsetAttribute})},e.EllipseOutlineGeometry=y}));