/*! For license information please see chunk-6PWSSCRA.js.LICENSE.txt */
import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";function calculateM(t,e,a){if(0===t)return e*a;const i=t*t,n=i*i,l=n*i,u=l*i,d=u*i,s=d*i,h=a;return e*((1-i/4-3*n/64-5*l/256-175*u/16384-441*d/65536-4851*s/1048576)*h-(3*i/8+3*n/32+45*l/1024+105*u/4096+2205*d/131072+6237*s/524288)*Math.sin(2*h)+(15*n/256+45*l/1024+525*u/16384+1575*d/65536+155925*s/8388608)*Math.sin(4*h)-(35*l/3072+175*u/12288+3675*d/262144+13475*s/1048576)*Math.sin(6*h)+(315*u/131072+2205*d/524288+43659*s/8388608)*Math.sin(8*h)-(693*d/1310720+6237*s/5242880)*Math.sin(10*h)+1001*s/8388608*Math.sin(12*h))}function calculateInverseM(t,e,a){const i=t/a;if(0===e)return i;const n=i*i,l=n*i,u=l*i,d=e*e,s=d*d,h=s*d,r=h*d,o=r*d,c=o*d,f=Math.sin(2*i),_=Math.cos(2*i),M=Math.sin(4*i),p=Math.cos(4*i),g=Math.sin(6*i),m=Math.cos(6*i),E=Math.sin(8*i),P=Math.cos(8*i),O=Math.sin(10*i);return i+i*d/4+7*i*s/64+15*i*h/256+579*i*r/16384+1515*i*o/65536+16837*i*c/1048576+(3*i*s/16+45*i*h/256-i*(32*n-561)*r/4096-i*(232*n-1677)*o/16384+i*(399985-90560*n+512*u)*c/5242880)*_+(21*i*h/256+483*i*r/4096-i*(224*n-1969)*o/16384-i*(33152*n-112599)*c/1048576)*p+(151*i*r/4096+4681*i*o/65536+1479*i*c/16384-453*l*c/32768)*m+(1097*i*o/65536+42783*i*c/1048576)*P+8011*i*c/1048576*Math.cos(10*i)+(3*d/8+3*s/16+213*h/2048-3*n*h/64+255*r/4096-33*n*r/512+20861*o/524288-33*n*o/512+u*o/1024+28273*c/1048576-471*n*c/8192+9*u*c/4096)*f+(21*s/256+21*h/256+533*r/8192-21*n*r/512+197*o/4096-315*n*o/4096+584039*c/16777216-12517*n*c/131072+7*u*c/2048)*M+(151*h/6144+151*r/4096+5019*o/131072-453*n*o/16384+26965*c/786432-8607*n*c/131072)*g+(1097*r/131072+1097*o/65536+225797*c/10485760-1097*n*c/65536)*E+(8011*o/2621440+8011*c/1048576)*O+293393*c/251658240*Math.sin(12*i)}function calculateSigma(t,e){if(0===t)return Math.log(Math.tan(.5*(Math_default.PI_OVER_TWO+e)));const a=t*Math.sin(e);return Math.log(Math.tan(.5*(Math_default.PI_OVER_TWO+e)))-t/2*Math.log((1+a)/(1-a))}function calculateHeading(t,e,a,i,n){const l=calculateSigma(t._ellipticity,a),u=calculateSigma(t._ellipticity,n);return Math.atan2(Math_default.negativePiToPi(i-e),u-l)}function calculateArcLength(t,e,a,i,n,l,u){const d=t._heading,s=l-i;let h=0;if(Math_default.equalsEpsilon(Math.abs(d),Math_default.PI_OVER_TWO,Math_default.EPSILON8))if(e===a)h=e*Math.cos(n)*Math_default.negativePiToPi(s);else{const a=Math.sin(n);h=e*Math.cos(n)*Math_default.negativePiToPi(s)/Math.sqrt(1-t._ellipticitySquared*a*a)}else{const a=calculateM(t._ellipticity,e,n);h=(calculateM(t._ellipticity,e,u)-a)/Math.cos(d)}return Math.abs(h)}var scratchCart1=new Cartesian3_default,scratchCart2=new Cartesian3_default;function computeProperties(t,e,a,i){const n=Cartesian3_default.normalize(i.cartographicToCartesian(e,scratchCart2),scratchCart1),l=Cartesian3_default.normalize(i.cartographicToCartesian(a,scratchCart2),scratchCart2);Check_default.typeOf.number.greaterThanOrEquals("value",Math.abs(Math.abs(Cartesian3_default.angleBetween(n,l))-Math.PI),.0125);const u=i.maximumRadius,d=i.minimumRadius,s=u*u,h=d*d;t._ellipticitySquared=(s-h)/s,t._ellipticity=Math.sqrt(t._ellipticitySquared),t._start=Cartographic_default.clone(e,t._start),t._start.height=0,t._end=Cartographic_default.clone(a,t._end),t._end.height=0,t._heading=calculateHeading(t,e.longitude,e.latitude,a.longitude,a.latitude),t._distance=calculateArcLength(t,i.maximumRadius,i.minimumRadius,e.longitude,e.latitude,a.longitude,a.latitude)}function interpolateUsingSurfaceDistance(t,e,a,i,n,l){if(0===a)return Cartographic_default.clone(t,l);const u=n*n;let d,s,h;if(Math.abs(Math_default.PI_OVER_TWO-Math.abs(e))>Math_default.EPSILON8)if(s=calculateInverseM(calculateM(n,i,t.latitude)+a*Math.cos(e),n,i),Math.abs(e)<Math_default.EPSILON10)d=Math_default.negativePiToPi(t.longitude);else{const a=calculateSigma(n,t.latitude),i=calculateSigma(n,s);h=Math.tan(e)*(i-a),d=Math_default.negativePiToPi(t.longitude+h)}else{let l;if(s=t.latitude,0===n)l=i*Math.cos(t.latitude);else{const e=Math.sin(t.latitude);l=i*Math.cos(t.latitude)/Math.sqrt(1-u*e*e)}h=a/l,d=e>0?Math_default.negativePiToPi(t.longitude+h):Math_default.negativePiToPi(t.longitude-h)}return defined_default(l)?(l.longitude=d,l.latitude=s,l.height=0,l):new Cartographic_default(d,s,0)}function EllipsoidRhumbLine(t,e,a){const i=defaultValue_default(a,Ellipsoid_default.WGS84);this._ellipsoid=i,this._start=new Cartographic_default,this._end=new Cartographic_default,this._heading=void 0,this._distance=void 0,this._ellipticity=void 0,this._ellipticitySquared=void 0,defined_default(t)&&defined_default(e)&&computeProperties(this,t,e,i)}Object.defineProperties(EllipsoidRhumbLine.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return Check_default.defined("distance",this._distance),this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},heading:{get:function(){return Check_default.defined("distance",this._distance),this._heading}}}),EllipsoidRhumbLine.fromStartHeadingDistance=function(t,e,a,i,n){Check_default.defined("start",t),Check_default.defined("heading",e),Check_default.defined("distance",a),Check_default.typeOf.number.greaterThan("distance",a,0);const l=defaultValue_default(i,Ellipsoid_default.WGS84),u=l.maximumRadius,d=l.minimumRadius,s=u*u,h=d*d,r=Math.sqrt((s-h)/s),o=interpolateUsingSurfaceDistance(t,e=Math_default.negativePiToPi(e),a,l.maximumRadius,r);return!defined_default(n)||defined_default(i)&&!i.equals(n.ellipsoid)?new EllipsoidRhumbLine(t,o,l):(n.setEndPoints(t,o),n)},EllipsoidRhumbLine.prototype.setEndPoints=function(t,e){Check_default.defined("start",t),Check_default.defined("end",e),computeProperties(this,t,e,this._ellipsoid)},EllipsoidRhumbLine.prototype.interpolateUsingFraction=function(t,e){return this.interpolateUsingSurfaceDistance(t*this._distance,e)},EllipsoidRhumbLine.prototype.interpolateUsingSurfaceDistance=function(t,e){if(Check_default.typeOf.number("distance",t),!defined_default(this._distance)||0===this._distance)throw new DeveloperError_default("EllipsoidRhumbLine must have distinct start and end set.");return interpolateUsingSurfaceDistance(this._start,this._heading,t,this._ellipsoid.maximumRadius,this._ellipticity,e)},EllipsoidRhumbLine.prototype.findIntersectionWithLongitude=function(t,e){if(Check_default.typeOf.number("intersectionLongitude",t),!defined_default(this._distance)||0===this._distance)throw new DeveloperError_default("EllipsoidRhumbLine must have distinct start and end set.");const a=this._ellipticity,i=this._heading,n=Math.abs(i),l=this._start;if(t=Math_default.negativePiToPi(t),Math_default.equalsEpsilon(Math.abs(t),Math.PI,Math_default.EPSILON14)&&(t=Math_default.sign(l.longitude)*Math.PI),defined_default(e)||(e=new Cartographic_default),Math.abs(Math_default.PI_OVER_TWO-n)<=Math_default.EPSILON8)return e.longitude=t,e.latitude=l.latitude,e.height=0,e;if(Math_default.equalsEpsilon(Math.abs(Math_default.PI_OVER_TWO-n),Math_default.PI_OVER_TWO,Math_default.EPSILON8)){if(Math_default.equalsEpsilon(t,l.longitude,Math_default.EPSILON12))return;return e.longitude=t,e.latitude=Math_default.PI_OVER_TWO*Math_default.sign(Math_default.PI_OVER_TWO-i),e.height=0,e}const u=l.latitude,d=a*Math.sin(u),s=Math.tan(.5*(Math_default.PI_OVER_TWO+u))*Math.exp((t-l.longitude)/Math.tan(i)),h=(1+d)/(1-d);let r,o=l.latitude;do{r=o;const t=a*Math.sin(r),e=(1+t)/(1-t);o=2*Math.atan(s*Math.pow(e/h,a/2))-Math_default.PI_OVER_TWO}while(!Math_default.equalsEpsilon(o,r,Math_default.EPSILON12));return e.longitude=t,e.latitude=o,e.height=0,e},EllipsoidRhumbLine.prototype.findIntersectionWithLatitude=function(t,e){if(Check_default.typeOf.number("intersectionLatitude",t),!defined_default(this._distance)||0===this._distance)throw new DeveloperError_default("EllipsoidRhumbLine must have distinct start and end set.");const a=this._ellipticity,i=this._heading,n=this._start;if(Math_default.equalsEpsilon(Math.abs(i),Math_default.PI_OVER_TWO,Math_default.EPSILON8))return;const l=calculateSigma(a,n.latitude),u=calculateSigma(a,t),d=Math.tan(i)*(u-l),s=Math_default.negativePiToPi(n.longitude+d);return defined_default(e)?(e.longitude=s,e.latitude=t,e.height=0,e):new Cartographic_default(s,t,0)};var EllipsoidRhumbLine_default=EllipsoidRhumbLine;export{EllipsoidRhumbLine_default};