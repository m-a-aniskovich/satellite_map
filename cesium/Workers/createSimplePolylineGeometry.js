/*! For license information please see createSimplePolylineGeometry.js.LICENSE.txt */
import{Color_default}from"./chunk-QUXSQQEF.js";import{ArcType_default}from"./chunk-235MRXLH.js";import{PolylinePipeline_default}from"./chunk-3FCUUN6M.js";import"./chunk-LSGUCCKJ.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";function interpolateColors(e,t,l,o,r,a,i){const n=PolylinePipeline_default.numberOfPoints(e,t,r);let u;const d=l.red,f=l.green,s=l.blue,_=l.alpha,p=o.red,c=o.green,y=o.blue,h=o.alpha;if(Color_default.equals(l,o)){for(u=0;u<n;u++)a[i++]=Color_default.floatToByte(d),a[i++]=Color_default.floatToByte(f),a[i++]=Color_default.floatToByte(s),a[i++]=Color_default.floatToByte(_);return i}const m=(p-d)/n,C=(c-f)/n,g=(y-s)/n,P=(h-_)/n;let T=i;for(u=0;u<n;u++)a[T++]=Color_default.floatToByte(d+u*m),a[T++]=Color_default.floatToByte(f+u*C),a[T++]=Color_default.floatToByte(s+u*g),a[T++]=Color_default.floatToByte(_+u*P);return T}function SimplePolylineGeometry(e){const t=(e=defaultValue_default(e,defaultValue_default.EMPTY_OBJECT)).positions,l=e.colors,o=defaultValue_default(e.colorsPerVertex,!1);if(!defined_default(t)||t.length<2)throw new DeveloperError_default("At least two positions are required.");if(defined_default(l)&&(o&&l.length<t.length||!o&&l.length<t.length-1))throw new DeveloperError_default("colors has an invalid length.");this._positions=t,this._colors=l,this._colorsPerVertex=o,this._arcType=defaultValue_default(e.arcType,ArcType_default.GEODESIC),this._granularity=defaultValue_default(e.granularity,Math_default.RADIANS_PER_DEGREE),this._ellipsoid=defaultValue_default(e.ellipsoid,Ellipsoid_default.WGS84),this._workerName="createSimplePolylineGeometry";let r=1+t.length*Cartesian3_default.packedLength;r+=defined_default(l)?1+l.length*Color_default.packedLength:1,this.packedLength=r+Ellipsoid_default.packedLength+3}SimplePolylineGeometry.pack=function(e,t,l){if(!defined_default(e))throw new DeveloperError_default("value is required");if(!defined_default(t))throw new DeveloperError_default("array is required");let o;l=defaultValue_default(l,0);const r=e._positions;let a=r.length;for(t[l++]=a,o=0;o<a;++o,l+=Cartesian3_default.packedLength)Cartesian3_default.pack(r[o],t,l);const i=e._colors;for(a=defined_default(i)?i.length:0,t[l++]=a,o=0;o<a;++o,l+=Color_default.packedLength)Color_default.pack(i[o],t,l);return Ellipsoid_default.pack(e._ellipsoid,t,l),l+=Ellipsoid_default.packedLength,t[l++]=e._colorsPerVertex?1:0,t[l++]=e._arcType,t[l]=e._granularity,t},SimplePolylineGeometry.unpack=function(e,t,l){if(!defined_default(e))throw new DeveloperError_default("array is required");let o;t=defaultValue_default(t,0);let r=e[t++];const a=new Array(r);for(o=0;o<r;++o,t+=Cartesian3_default.packedLength)a[o]=Cartesian3_default.unpack(e,t);r=e[t++];const i=r>0?new Array(r):void 0;for(o=0;o<r;++o,t+=Color_default.packedLength)i[o]=Color_default.unpack(e,t);const n=Ellipsoid_default.unpack(e,t);t+=Ellipsoid_default.packedLength;const u=1===e[t++],d=e[t++],f=e[t];return defined_default(l)?(l._positions=a,l._colors=i,l._ellipsoid=n,l._colorsPerVertex=u,l._arcType=d,l._granularity=f,l):new SimplePolylineGeometry({positions:a,colors:i,ellipsoid:n,colorsPerVertex:u,arcType:d,granularity:f})};var scratchArray1=new Array(2),scratchArray2=new Array(2),generateArcOptionsScratch={positions:scratchArray1,height:scratchArray2,ellipsoid:void 0,minDistance:void 0,granularity:void 0};SimplePolylineGeometry.createGeometry=function(e){const t=e._positions,l=e._colors,o=e._colorsPerVertex,r=e._arcType,a=e._granularity,i=e._ellipsoid,n=Math_default.chordLength(a,i.maximumRadius),u=defined_default(l)&&!o;let d;const f=t.length;let s,_,p,c,y=0;if(r===ArcType_default.GEODESIC||r===ArcType_default.RHUMB){let e,o,_;r===ArcType_default.GEODESIC?(e=Math_default.chordLength(a,i.maximumRadius),o=PolylinePipeline_default.numberOfPoints,_=PolylinePipeline_default.generateArc):(e=a,o=PolylinePipeline_default.numberOfPointsRhumbLine,_=PolylinePipeline_default.generateRhumbArc);const h=PolylinePipeline_default.extractHeights(t,i),m=generateArcOptionsScratch;if(r===ArcType_default.GEODESIC?m.minDistance=n:m.granularity=a,m.ellipsoid=i,u){let r=0;for(d=0;d<f-1;d++)r+=o(t[d],t[d+1],e)+1;s=new Float64Array(3*r),p=new Uint8Array(4*r),m.positions=scratchArray1,m.height=scratchArray2;let a=0;for(d=0;d<f-1;++d){scratchArray1[0]=t[d],scratchArray1[1]=t[d+1],scratchArray2[0]=h[d],scratchArray2[1]=h[d+1];const e=_(m);if(defined_default(l)){const t=e.length/3;c=l[d];for(let e=0;e<t;++e)p[a++]=Color_default.floatToByte(c.red),p[a++]=Color_default.floatToByte(c.green),p[a++]=Color_default.floatToByte(c.blue),p[a++]=Color_default.floatToByte(c.alpha)}s.set(e,y),y+=e.length}}else if(m.positions=t,m.height=h,s=new Float64Array(_(m)),defined_default(l)){for(p=new Uint8Array(s.length/3*4),d=0;d<f-1;++d)y=interpolateColors(t[d],t[d+1],l[d],l[d+1],n,p,y);const e=l[f-1];p[y++]=Color_default.floatToByte(e.red),p[y++]=Color_default.floatToByte(e.green),p[y++]=Color_default.floatToByte(e.blue),p[y++]=Color_default.floatToByte(e.alpha)}}else{_=u?2*f-2:f,s=new Float64Array(3*_),p=defined_default(l)?new Uint8Array(4*_):void 0;let e=0,o=0;for(d=0;d<f;++d){const r=t[d];if(u&&d>0&&(Cartesian3_default.pack(r,s,e),e+=3,c=l[d-1],p[o++]=Color_default.floatToByte(c.red),p[o++]=Color_default.floatToByte(c.green),p[o++]=Color_default.floatToByte(c.blue),p[o++]=Color_default.floatToByte(c.alpha)),u&&d===f-1)break;Cartesian3_default.pack(r,s,e),e+=3,defined_default(l)&&(c=l[d],p[o++]=Color_default.floatToByte(c.red),p[o++]=Color_default.floatToByte(c.green),p[o++]=Color_default.floatToByte(c.blue),p[o++]=Color_default.floatToByte(c.alpha))}}const h=new GeometryAttributes_default;h.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:s}),defined_default(l)&&(h.color=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:4,values:p,normalize:!0})),_=s.length/3;const m=2*(_-1),C=IndexDatatype_default.createTypedArray(_,m);let g=0;for(d=0;d<_-1;++d)C[g++]=d,C[g++]=d+1;return new Geometry_default({attributes:h,indices:C,primitiveType:PrimitiveType_default.LINES,boundingSphere:BoundingSphere_default.fromPoints(t)})};var SimplePolylineGeometry_default=SimplePolylineGeometry;function createSimplePolylineGeometry(e,t){return defined_default(t)&&(e=SimplePolylineGeometry_default.unpack(e,t)),e._ellipsoid=Ellipsoid_default.clone(e._ellipsoid),SimplePolylineGeometry_default.createGeometry(e)}var createSimplePolylineGeometry_default=createSimplePolylineGeometry;export{createSimplePolylineGeometry_default as default};