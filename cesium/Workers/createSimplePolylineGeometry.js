define(["./defaultValue-fe22d8c0","./Matrix3-41c58dde","./ArcType-2d9abbbc","./Transforms-e2d4a55a","./Color-8e135f71","./ComponentDatatype-cf1fa08e","./Check-6ede7e26","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./IndexDatatype-2643aa47","./Math-0a2ac845","./PolylinePipeline-7119eb3f","./Matrix2-e1298525","./RuntimeError-ef395448","./combine-d9581036","./WebGLConstants-0b1ce7ba","./EllipsoidGeodesic-5b3623dc","./EllipsoidRhumbLine-ef872433","./IntersectionTests-85350792","./Plane-4c3d403b"],(function(e,o,t,r,l,n,i,a,s,d,c,p,f,u,y,h,C,g,T,m){"use strict";function E(e,o,t,r,n,i,a){const s=p.PolylinePipeline.numberOfPoints(e,o,n);let d;const c=t.red,f=t.green,u=t.blue,y=t.alpha,h=r.red,C=r.green,g=r.blue,T=r.alpha;if(l.Color.equals(t,r)){for(d=0;d<s;d++)i[a++]=l.Color.floatToByte(c),i[a++]=l.Color.floatToByte(f),i[a++]=l.Color.floatToByte(u),i[a++]=l.Color.floatToByte(y);return a}const m=(h-c)/s,E=(C-f)/s,b=(g-u)/s,P=(T-y)/s;let _=a;for(d=0;d<s;d++)i[_++]=l.Color.floatToByte(c+d*m),i[_++]=l.Color.floatToByte(f+d*E),i[_++]=l.Color.floatToByte(u+d*b),i[_++]=l.Color.floatToByte(y+d*P);return _}function b(r){const n=(r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT)).positions,a=r.colors,s=e.defaultValue(r.colorsPerVertex,!1);if(!e.defined(n)||n.length<2)throw new i.DeveloperError("At least two positions are required.");if(e.defined(a)&&(s&&a.length<n.length||!s&&a.length<n.length-1))throw new i.DeveloperError("colors has an invalid length.");this._positions=n,this._colors=a,this._colorsPerVertex=s,this._arcType=e.defaultValue(r.arcType,t.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,c.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.defaultValue(r.ellipsoid,o.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let d=1+n.length*o.Cartesian3.packedLength;d+=e.defined(a)?1+a.length*l.Color.packedLength:1,this.packedLength=d+o.Ellipsoid.packedLength+3}b.pack=function(t,r,n){if(!e.defined(t))throw new i.DeveloperError("value is required");if(!e.defined(r))throw new i.DeveloperError("array is required");let a;n=e.defaultValue(n,0);const s=t._positions;let d=s.length;for(r[n++]=d,a=0;a<d;++a,n+=o.Cartesian3.packedLength)o.Cartesian3.pack(s[a],r,n);const c=t._colors;for(d=e.defined(c)?c.length:0,r[n++]=d,a=0;a<d;++a,n+=l.Color.packedLength)l.Color.pack(c[a],r,n);return o.Ellipsoid.pack(t._ellipsoid,r,n),n+=o.Ellipsoid.packedLength,r[n++]=t._colorsPerVertex?1:0,r[n++]=t._arcType,r[n]=t._granularity,r},b.unpack=function(t,r,n){if(!e.defined(t))throw new i.DeveloperError("array is required");let a;r=e.defaultValue(r,0);let s=t[r++];const d=new Array(s);for(a=0;a<s;++a,r+=o.Cartesian3.packedLength)d[a]=o.Cartesian3.unpack(t,r);s=t[r++];const c=s>0?new Array(s):void 0;for(a=0;a<s;++a,r+=l.Color.packedLength)c[a]=l.Color.unpack(t,r);const p=o.Ellipsoid.unpack(t,r);r+=o.Ellipsoid.packedLength;const f=1===t[r++],u=t[r++],y=t[r];return e.defined(n)?(n._positions=d,n._colors=c,n._ellipsoid=p,n._colorsPerVertex=f,n._arcType=u,n._granularity=y,n):new b({positions:d,colors:c,ellipsoid:p,colorsPerVertex:f,arcType:u,granularity:y})};const P=new Array(2),_=new Array(2),A={positions:P,height:_,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return b.createGeometry=function(i){const f=i._positions,u=i._colors,y=i._colorsPerVertex,h=i._arcType,C=i._granularity,g=i._ellipsoid,T=c.CesiumMath.chordLength(C,g.maximumRadius),m=e.defined(u)&&!y;let b;const B=f.length;let w,k,D,G,L=0;if(h===t.ArcType.GEODESIC||h===t.ArcType.RHUMB){let o,r,n;h===t.ArcType.GEODESIC?(o=c.CesiumMath.chordLength(C,g.maximumRadius),r=p.PolylinePipeline.numberOfPoints,n=p.PolylinePipeline.generateArc):(o=C,r=p.PolylinePipeline.numberOfPointsRhumbLine,n=p.PolylinePipeline.generateRhumbArc);const i=p.PolylinePipeline.extractHeights(f,g),a=A;if(h===t.ArcType.GEODESIC?a.minDistance=T:a.granularity=C,a.ellipsoid=g,m){let t=0;for(b=0;b<B-1;b++)t+=r(f[b],f[b+1],o)+1;w=new Float64Array(3*t),D=new Uint8Array(4*t),a.positions=P,a.height=_;let s=0;for(b=0;b<B-1;++b){P[0]=f[b],P[1]=f[b+1],_[0]=i[b],_[1]=i[b+1];const o=n(a);if(e.defined(u)){const e=o.length/3;G=u[b];for(let o=0;o<e;++o)D[s++]=l.Color.floatToByte(G.red),D[s++]=l.Color.floatToByte(G.green),D[s++]=l.Color.floatToByte(G.blue),D[s++]=l.Color.floatToByte(G.alpha)}w.set(o,L),L+=o.length}}else if(a.positions=f,a.height=i,w=new Float64Array(n(a)),e.defined(u)){for(D=new Uint8Array(w.length/3*4),b=0;b<B-1;++b)L=E(f[b],f[b+1],u[b],u[b+1],T,D,L);const e=u[B-1];D[L++]=l.Color.floatToByte(e.red),D[L++]=l.Color.floatToByte(e.green),D[L++]=l.Color.floatToByte(e.blue),D[L++]=l.Color.floatToByte(e.alpha)}}else{k=m?2*B-2:B,w=new Float64Array(3*k),D=e.defined(u)?new Uint8Array(4*k):void 0;let t=0,r=0;for(b=0;b<B;++b){const n=f[b];if(m&&b>0&&(o.Cartesian3.pack(n,w,t),t+=3,G=u[b-1],D[r++]=l.Color.floatToByte(G.red),D[r++]=l.Color.floatToByte(G.green),D[r++]=l.Color.floatToByte(G.blue),D[r++]=l.Color.floatToByte(G.alpha)),m&&b===B-1)break;o.Cartesian3.pack(n,w,t),t+=3,e.defined(u)&&(G=u[b],D[r++]=l.Color.floatToByte(G.red),D[r++]=l.Color.floatToByte(G.green),D[r++]=l.Color.floatToByte(G.blue),D[r++]=l.Color.floatToByte(G.alpha))}}const v=new s.GeometryAttributes;v.position=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:w}),e.defined(u)&&(v.color=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:D,normalize:!0})),k=w.length/3;const V=2*(k-1),x=d.IndexDatatype.createTypedArray(k,V);let S=0;for(b=0;b<k-1;++b)x[S++]=b,x[S++]=b+1;return new a.Geometry({attributes:v,indices:x,primitiveType:a.PrimitiveType.LINES,boundingSphere:r.BoundingSphere.fromPoints(f)})},function(t,r){return e.defined(r)&&(t=b.unpack(t,r)),t._ellipsoid=o.Ellipsoid.clone(t._ellipsoid),b.createGeometry(t)}}));