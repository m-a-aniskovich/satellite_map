/*! For license information please see upsampleQuantizedTerrainMesh.js.LICENSE.txt */
import{EllipsoidalOccluder_default,TerrainEncoding_default}from"./chunk-SEFDWMCW.js";import{createTaskProcessorWorker_default}from"./chunk-AI3KSNM6.js";import{OrientedBoundingBox_default}from"./chunk-QY2WY5XJ.js";import{AttributeCompression_default}from"./chunk-I6TVJ6T7.js";import"./chunk-MOLGJDJV.js";import"./chunk-FGUP2QEP.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Cartesian2_default,Rectangle_default}from"./chunk-RSWBNJPT.js";import"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var Intersections2D={clipTriangleAtAxisAlignedThreshold:function(e,t,r,i,n,o){if(!defined_default(e))throw new DeveloperError_default("threshold is required.");if(!defined_default(t))throw new DeveloperError_default("keepAbove is required.");if(!defined_default(r))throw new DeveloperError_default("u0 is required.");if(!defined_default(i))throw new DeveloperError_default("u1 is required.");if(!defined_default(n))throw new DeveloperError_default("u2 is required.");let a,h,s;defined_default(o)?o.length=0:o=[],t?(a=r<e,h=i<e,s=n<e):(a=r>e,h=i>e,s=n>e);const u=a+h+s;let d,c,l,f,p,x;return 1===u?a?(d=(e-r)/(i-r),c=(e-r)/(n-r),o.push(1),o.push(2),1!==c&&(o.push(-1),o.push(0),o.push(2),o.push(c)),1!==d&&(o.push(-1),o.push(0),o.push(1),o.push(d))):h?(l=(e-i)/(n-i),f=(e-i)/(r-i),o.push(2),o.push(0),1!==f&&(o.push(-1),o.push(1),o.push(0),o.push(f)),1!==l&&(o.push(-1),o.push(1),o.push(2),o.push(l))):s&&(p=(e-n)/(r-n),x=(e-n)/(i-n),o.push(0),o.push(1),1!==x&&(o.push(-1),o.push(2),o.push(1),o.push(x)),1!==p&&(o.push(-1),o.push(2),o.push(0),o.push(p))):2===u?a||r===e?h||i===e?s||n===e||(c=(e-r)/(n-r),l=(e-i)/(n-i),o.push(2),o.push(-1),o.push(0),o.push(2),o.push(c),o.push(-1),o.push(1),o.push(2),o.push(l)):(x=(e-n)/(i-n),d=(e-r)/(i-r),o.push(1),o.push(-1),o.push(2),o.push(1),o.push(x),o.push(-1),o.push(0),o.push(1),o.push(d)):(f=(e-i)/(r-i),p=(e-n)/(r-n),o.push(0),o.push(-1),o.push(1),o.push(0),o.push(f),o.push(-1),o.push(2),o.push(0),o.push(p)):3!==u&&(o.push(0),o.push(1),o.push(2)),o},computeBarycentricCoordinates:function(e,t,r,i,n,o,a,h,s){if(!defined_default(e))throw new DeveloperError_default("x is required.");if(!defined_default(t))throw new DeveloperError_default("y is required.");if(!defined_default(r))throw new DeveloperError_default("x1 is required.");if(!defined_default(i))throw new DeveloperError_default("y1 is required.");if(!defined_default(n))throw new DeveloperError_default("x2 is required.");if(!defined_default(o))throw new DeveloperError_default("y2 is required.");if(!defined_default(a))throw new DeveloperError_default("x3 is required.");if(!defined_default(h))throw new DeveloperError_default("y3 is required.");const u=r-a,d=a-n,c=o-h,l=i-h,f=1/(c*u+d*l),p=t-h,x=e-a,g=(c*x+d*p)*f,m=(-l*x+u*p)*f,_=1-g-m;return defined_default(s)?(s.x=g,s.y=m,s.z=_,s):new Cartesian3_default(g,m,_)},computeLineSegmentLineSegmentIntersection:function(e,t,r,i,n,o,a,h,s){Check_default.typeOf.number("x00",e),Check_default.typeOf.number("y00",t),Check_default.typeOf.number("x01",r),Check_default.typeOf.number("y01",i),Check_default.typeOf.number("x10",n),Check_default.typeOf.number("y10",o),Check_default.typeOf.number("x11",a),Check_default.typeOf.number("y11",h);const u=(h-o)*(r-e)-(a-n)*(i-t);if(0===u)return;const d=((a-n)*(t-o)-(h-o)*(e-n))/u,c=((r-e)*(t-o)-(i-t)*(e-n))/u;return d>=0&&d<=1&&c>=0&&c<=1?(defined_default(s)||(s=new Cartesian2_default),s.x=e+d*(r-e),s.y=t+d*(i-t),s):void 0}},Intersections2D_default=Intersections2D,maxShort=32767,halfMaxShort=maxShort/2|0,clipScratch=[],clipScratch2=[],verticesScratch=[],cartographicScratch=new Cartographic_default,cartesian3Scratch=new Cartesian3_default,uScratch=[],vScratch=[],heightScratch=[],indicesScratch=[],normalsScratch=[],horizonOcclusionPointScratch=new Cartesian3_default,boundingSphereScratch=new BoundingSphere_default,orientedBoundingBoxScratch=new OrientedBoundingBox_default,decodeTexCoordsScratch=new Cartesian2_default,octEncodedNormalScratch=new Cartesian3_default;function upsampleQuantizedTerrainMesh(e,t){const r=e.isEastChild,i=e.isNorthChild,n=r?halfMaxShort:0,o=r?maxShort:halfMaxShort,a=i?halfMaxShort:0,h=i?maxShort:halfMaxShort,s=uScratch,u=vScratch,d=heightScratch,c=normalsScratch;s.length=0,u.length=0,d.length=0,c.length=0;const l=indicesScratch;l.length=0;const f={},p=e.vertices;let x=e.indices;x=x.subarray(0,e.indexCountWithoutSkirts);const g=TerrainEncoding_default.clone(e.encoding),m=g.hasVertexNormals;let _=0;const S=e.vertexCountWithoutSkirts,w=e.minimumHeight,y=e.maximumHeight,V=new Array(S),C=new Array(S),v=new Array(S),B=m?new Array(2*S):void 0;let I,E,k,M,D;for(E=0,k=0;E<S;++E,k+=2){const e=g.decodeTextureCoordinates(p,E,decodeTexCoordsScratch);if(I=g.decodeHeight(p,E),M=Math_default.clamp(e.x*maxShort|0,0,maxShort),D=Math_default.clamp(e.y*maxShort|0,0,maxShort),v[E]=Math_default.clamp((I-w)/(y-w)*maxShort|0,0,maxShort),M<20&&(M=0),D<20&&(D=0),maxShort-M<20&&(M=maxShort),maxShort-D<20&&(D=maxShort),V[E]=M,C[E]=D,m){const e=g.getOctEncodedNormal(p,E,octEncodedNormalScratch);B[k]=e.x,B[k+1]=e.y}(r&&M>=halfMaxShort||!r&&M<=halfMaxShort)&&(i&&D>=halfMaxShort||!i&&D<=halfMaxShort)&&(f[E]=_,s.push(M),u.push(D),d.push(v[E]),m&&(c.push(B[k]),c.push(B[k+1])),++_)}const O=[];O.push(new Vertex),O.push(new Vertex),O.push(new Vertex);const A=[];let b,N;for(A.push(new Vertex),A.push(new Vertex),A.push(new Vertex),E=0;E<x.length;E+=3){const e=x[E],t=x[E+1],n=x[E+2],o=V[e],a=V[t],h=V[n];O[0].initializeIndexed(V,C,v,B,e),O[1].initializeIndexed(V,C,v,B,t),O[2].initializeIndexed(V,C,v,B,n);const p=Intersections2D_default.clipTriangleAtAxisAlignedThreshold(halfMaxShort,r,o,a,h,clipScratch);b=0,b>=p.length||(b=A[0].initializeFromClipResult(p,b,O),b>=p.length||(b=A[1].initializeFromClipResult(p,b,O),b>=p.length||(b=A[2].initializeFromClipResult(p,b,O),N=Intersections2D_default.clipTriangleAtAxisAlignedThreshold(halfMaxShort,i,A[0].getV(),A[1].getV(),A[2].getV(),clipScratch2),addClippedPolygon(s,u,d,c,l,f,N,A,m),b<p.length&&(A[2].clone(A[1]),A[2].initializeFromClipResult(p,b,O),N=Intersections2D_default.clipTriangleAtAxisAlignedThreshold(halfMaxShort,i,A[0].getV(),A[1].getV(),A[2].getV(),clipScratch2),addClippedPolygon(s,u,d,c,l,f,N,A,m)))))}const T=r?-maxShort:0,z=i?-maxShort:0,j=[],P=[],H=[],R=[];let q=Number.MAX_VALUE,Y=-q;const F=verticesScratch;F.length=0;const J=Ellipsoid_default.clone(e.ellipsoid),U=Rectangle_default.clone(e.childRectangle),W=U.north,K=U.south;let X=U.east;const Q=U.west;for(X<Q&&(X+=Math_default.TWO_PI),E=0;E<s.length;++E)M=Math.round(s[E]),M<=n?(j.push(E),M=0):M>=o?(H.push(E),M=maxShort):M=2*M+T,s[E]=M,D=Math.round(u[E]),D<=a?(P.push(E),D=0):D>=h?(R.push(E),D=maxShort):D=2*D+z,u[E]=D,I=Math_default.lerp(w,y,d[E]/maxShort),I<q&&(q=I),I>Y&&(Y=I),d[E]=I,cartographicScratch.longitude=Math_default.lerp(Q,X,M/maxShort),cartographicScratch.latitude=Math_default.lerp(K,W,D/maxShort),cartographicScratch.height=I,J.cartographicToCartesian(cartographicScratch,cartesian3Scratch),F.push(cartesian3Scratch.x),F.push(cartesian3Scratch.y),F.push(cartesian3Scratch.z);const L=BoundingSphere_default.fromVertices(F,Cartesian3_default.ZERO,3,boundingSphereScratch),Z=OrientedBoundingBox_default.fromRectangle(U,q,Y,J,orientedBoundingBoxScratch),G=new EllipsoidalOccluder_default(J).computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(L.center,F,3,L.center,q,horizonOcclusionPointScratch),$=Y-q,ee=new Uint16Array(s.length+u.length+d.length);for(E=0;E<s.length;++E)ee[E]=s[E];let te=s.length;for(E=0;E<u.length;++E)ee[te+E]=u[E];for(te+=u.length,E=0;E<d.length;++E)ee[te+E]=maxShort*(d[E]-q)/$;const re=IndexDatatype_default.createTypedArray(s.length,l);let ie;if(m){const e=new Uint8Array(c);t.push(ee.buffer,re.buffer,e.buffer),ie=e.buffer}else t.push(ee.buffer,re.buffer);return{vertices:ee.buffer,encodedNormals:ie,indices:re.buffer,minimumHeight:q,maximumHeight:Y,westIndices:j,southIndices:P,eastIndices:H,northIndices:R,boundingSphere:L,orientedBoundingBox:Z,horizonOcclusionPoint:G}}function Vertex(){this.vertexBuffer=void 0,this.index=void 0,this.first=void 0,this.second=void 0,this.ratio=void 0}Vertex.prototype.clone=function(e){return defined_default(e)||(e=new Vertex),e.uBuffer=this.uBuffer,e.vBuffer=this.vBuffer,e.heightBuffer=this.heightBuffer,e.normalBuffer=this.normalBuffer,e.index=this.index,e.first=this.first,e.second=this.second,e.ratio=this.ratio,e},Vertex.prototype.initializeIndexed=function(e,t,r,i,n){this.uBuffer=e,this.vBuffer=t,this.heightBuffer=r,this.normalBuffer=i,this.index=n,this.first=void 0,this.second=void 0,this.ratio=void 0},Vertex.prototype.initializeFromClipResult=function(e,t,r){let i=t+1;return-1!==e[t]?r[e[t]].clone(this):(this.vertexBuffer=void 0,this.index=void 0,this.first=r[e[i]],++i,this.second=r[e[i]],++i,this.ratio=e[i],++i),i},Vertex.prototype.getKey=function(){return this.isIndexed()?this.index:JSON.stringify({first:this.first.getKey(),second:this.second.getKey(),ratio:this.ratio})},Vertex.prototype.isIndexed=function(){return defined_default(this.index)},Vertex.prototype.getH=function(){return defined_default(this.index)?this.heightBuffer[this.index]:Math_default.lerp(this.first.getH(),this.second.getH(),this.ratio)},Vertex.prototype.getU=function(){return defined_default(this.index)?this.uBuffer[this.index]:Math_default.lerp(this.first.getU(),this.second.getU(),this.ratio)},Vertex.prototype.getV=function(){return defined_default(this.index)?this.vBuffer[this.index]:Math_default.lerp(this.first.getV(),this.second.getV(),this.ratio)};var encodedScratch=new Cartesian2_default,depth=-1,cartesianScratch1=[new Cartesian3_default,new Cartesian3_default],cartesianScratch2=[new Cartesian3_default,new Cartesian3_default];function lerpOctEncodedNormal(e,t){++depth;let r=cartesianScratch1[depth],i=cartesianScratch2[depth];return r=AttributeCompression_default.octDecode(e.first.getNormalX(),e.first.getNormalY(),r),i=AttributeCompression_default.octDecode(e.second.getNormalX(),e.second.getNormalY(),i),cartesian3Scratch=Cartesian3_default.lerp(r,i,e.ratio,cartesian3Scratch),Cartesian3_default.normalize(cartesian3Scratch,cartesian3Scratch),AttributeCompression_default.octEncode(cartesian3Scratch,t),--depth,t}Vertex.prototype.getNormalX=function(){return defined_default(this.index)?this.normalBuffer[2*this.index]:(encodedScratch=lerpOctEncodedNormal(this,encodedScratch)).x},Vertex.prototype.getNormalY=function(){return defined_default(this.index)?this.normalBuffer[2*this.index+1]:(encodedScratch=lerpOctEncodedNormal(this,encodedScratch)).y};var polygonVertices=[];function addClippedPolygon(e,t,r,i,n,o,a,h,s){if(0===a.length)return;let u=0,d=0;for(;d<a.length;)d=polygonVertices[u++].initializeFromClipResult(a,d,h);for(let n=0;n<u;++n){const a=polygonVertices[n];if(a.isIndexed())a.newIndex=o[a.index],a.uBuffer=e,a.vBuffer=t,a.heightBuffer=r,s&&(a.normalBuffer=i);else{const n=a.getKey();if(defined_default(o[n]))a.newIndex=o[n];else{const h=e.length;e.push(a.getU()),t.push(a.getV()),r.push(a.getH()),s&&(i.push(a.getNormalX()),i.push(a.getNormalY())),a.newIndex=h,o[n]=h}}}3===u?(n.push(polygonVertices[0].newIndex),n.push(polygonVertices[1].newIndex),n.push(polygonVertices[2].newIndex)):4===u&&(n.push(polygonVertices[0].newIndex),n.push(polygonVertices[1].newIndex),n.push(polygonVertices[2].newIndex),n.push(polygonVertices[0].newIndex),n.push(polygonVertices[2].newIndex),n.push(polygonVertices[3].newIndex))}polygonVertices.push(new Vertex),polygonVertices.push(new Vertex),polygonVertices.push(new Vertex),polygonVertices.push(new Vertex);var upsampleQuantizedTerrainMesh_default=createTaskProcessorWorker_default(upsampleQuantizedTerrainMesh);export{upsampleQuantizedTerrainMesh_default as default};