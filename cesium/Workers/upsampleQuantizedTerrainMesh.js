define(["./AttributeCompression-f9f6c717","./Transforms-e2d4a55a","./Matrix2-e1298525","./Matrix3-41c58dde","./defaultValue-fe22d8c0","./TerrainEncoding-c8e029a2","./IndexDatatype-2643aa47","./Check-6ede7e26","./Math-0a2ac845","./OrientedBoundingBox-29fb0fcd","./createTaskProcessorWorker","./ComponentDatatype-cf1fa08e","./WebGLConstants-0b1ce7ba","./combine-d9581036","./RuntimeError-ef395448","./EllipsoidTangentPlane-546c0d5e","./AxisAlignedBoundingBox-4bfd84f3","./IntersectionTests-85350792","./Plane-4c3d403b"],(function(e,t,i,n,r,s,o,h,u,d,p,f,l,a,c,g,m,x,w){"use strict";var C={clipTriangleAtAxisAlignedThreshold:function(e,t,i,n,s,o){if(!r.defined(e))throw new h.DeveloperError("threshold is required.");if(!r.defined(t))throw new h.DeveloperError("keepAbove is required.");if(!r.defined(i))throw new h.DeveloperError("u0 is required.");if(!r.defined(n))throw new h.DeveloperError("u1 is required.");if(!r.defined(s))throw new h.DeveloperError("u2 is required.");let u,d,p;r.defined(o)?o.length=0:o=[],t?(u=i<e,d=n<e,p=s<e):(u=i>e,d=n>e,p=s>e);const f=u+d+p;let l,a,c,g,m,x;return 1===f?u?(l=(e-i)/(n-i),a=(e-i)/(s-i),o.push(1),o.push(2),1!==a&&(o.push(-1),o.push(0),o.push(2),o.push(a)),1!==l&&(o.push(-1),o.push(0),o.push(1),o.push(l))):d?(c=(e-n)/(s-n),g=(e-n)/(i-n),o.push(2),o.push(0),1!==g&&(o.push(-1),o.push(1),o.push(0),o.push(g)),1!==c&&(o.push(-1),o.push(1),o.push(2),o.push(c))):p&&(m=(e-s)/(i-s),x=(e-s)/(n-s),o.push(0),o.push(1),1!==x&&(o.push(-1),o.push(2),o.push(1),o.push(x)),1!==m&&(o.push(-1),o.push(2),o.push(0),o.push(m))):2===f?u||i===e?d||n===e?p||s===e||(a=(e-i)/(s-i),c=(e-n)/(s-n),o.push(2),o.push(-1),o.push(0),o.push(2),o.push(a),o.push(-1),o.push(1),o.push(2),o.push(c)):(x=(e-s)/(n-s),l=(e-i)/(n-i),o.push(1),o.push(-1),o.push(2),o.push(1),o.push(x),o.push(-1),o.push(0),o.push(1),o.push(l)):(g=(e-n)/(i-n),m=(e-s)/(i-s),o.push(0),o.push(-1),o.push(1),o.push(0),o.push(g),o.push(-1),o.push(2),o.push(0),o.push(m)):3!==f&&(o.push(0),o.push(1),o.push(2)),o},computeBarycentricCoordinates:function(e,t,i,s,o,u,d,p,f){if(!r.defined(e))throw new h.DeveloperError("x is required.");if(!r.defined(t))throw new h.DeveloperError("y is required.");if(!r.defined(i))throw new h.DeveloperError("x1 is required.");if(!r.defined(s))throw new h.DeveloperError("y1 is required.");if(!r.defined(o))throw new h.DeveloperError("x2 is required.");if(!r.defined(u))throw new h.DeveloperError("y2 is required.");if(!r.defined(d))throw new h.DeveloperError("x3 is required.");if(!r.defined(p))throw new h.DeveloperError("y3 is required.");const l=i-d,a=d-o,c=u-p,g=s-p,m=1/(c*l+a*g),x=t-p,w=e-d,C=(c*w+a*x)*m,y=(-g*w+l*x)*m,v=1-C-y;return r.defined(f)?(f.x=C,f.y=y,f.z=v,f):new n.Cartesian3(C,y,v)},computeLineSegmentLineSegmentIntersection:function(e,t,n,s,o,u,d,p,f){h.Check.typeOf.number("x00",e),h.Check.typeOf.number("y00",t),h.Check.typeOf.number("x01",n),h.Check.typeOf.number("y01",s),h.Check.typeOf.number("x10",o),h.Check.typeOf.number("y10",u),h.Check.typeOf.number("x11",d),h.Check.typeOf.number("y11",p);const l=(p-u)*(n-e)-(d-o)*(s-t);if(0===l)return;const a=((d-o)*(t-u)-(p-u)*(e-o))/l,c=((n-e)*(t-u)-(s-t)*(e-o))/l;return a>=0&&a<=1&&c>=0&&c<=1?(r.defined(f)||(f=new i.Cartesian2),f.x=e+a*(n-e),f.y=t+a*(s-t),f):void 0}};const y=32767,v=16383,B=[],b=[],A=[],I=new n.Cartographic;let E=new n.Cartesian3;const D=[],T=[],O=[],M=[],z=[],V=new n.Cartesian3,k=new t.BoundingSphere,N=new d.OrientedBoundingBox,q=new i.Cartesian2,R=new n.Cartesian3;function H(){this.vertexBuffer=void 0,this.index=void 0,this.first=void 0,this.second=void 0,this.ratio=void 0}H.prototype.clone=function(e){return r.defined(e)||(e=new H),e.uBuffer=this.uBuffer,e.vBuffer=this.vBuffer,e.heightBuffer=this.heightBuffer,e.normalBuffer=this.normalBuffer,e.index=this.index,e.first=this.first,e.second=this.second,e.ratio=this.ratio,e},H.prototype.initializeIndexed=function(e,t,i,n,r){this.uBuffer=e,this.vBuffer=t,this.heightBuffer=i,this.normalBuffer=n,this.index=r,this.first=void 0,this.second=void 0,this.ratio=void 0},H.prototype.initializeFromClipResult=function(e,t,i){let n=t+1;return-1!==e[t]?i[e[t]].clone(this):(this.vertexBuffer=void 0,this.index=void 0,this.first=i[e[n]],++n,this.second=i[e[n]],++n,this.ratio=e[n],++n),n},H.prototype.getKey=function(){return this.isIndexed()?this.index:JSON.stringify({first:this.first.getKey(),second:this.second.getKey(),ratio:this.ratio})},H.prototype.isIndexed=function(){return r.defined(this.index)},H.prototype.getH=function(){return r.defined(this.index)?this.heightBuffer[this.index]:u.CesiumMath.lerp(this.first.getH(),this.second.getH(),this.ratio)},H.prototype.getU=function(){return r.defined(this.index)?this.uBuffer[this.index]:u.CesiumMath.lerp(this.first.getU(),this.second.getU(),this.ratio)},H.prototype.getV=function(){return r.defined(this.index)?this.vBuffer[this.index]:u.CesiumMath.lerp(this.first.getV(),this.second.getV(),this.ratio)};let S=new i.Cartesian2,U=-1;const F=[new n.Cartesian3,new n.Cartesian3],P=[new n.Cartesian3,new n.Cartesian3];function W(t,i){++U;let r=F[U],s=P[U];return r=e.AttributeCompression.octDecode(t.first.getNormalX(),t.first.getNormalY(),r),s=e.AttributeCompression.octDecode(t.second.getNormalX(),t.second.getNormalY(),s),E=n.Cartesian3.lerp(r,s,t.ratio,E),n.Cartesian3.normalize(E,E),e.AttributeCompression.octEncode(E,i),--U,i}H.prototype.getNormalX=function(){return r.defined(this.index)?this.normalBuffer[2*this.index]:(S=W(this,S),S.x)},H.prototype.getNormalY=function(){return r.defined(this.index)?this.normalBuffer[2*this.index+1]:(S=W(this,S),S.y)};const X=[];function K(e,t,i,n,s,o,h,u,d){if(0===h.length)return;let p=0,f=0;for(;f<h.length;)f=X[p++].initializeFromClipResult(h,f,u);for(let s=0;s<p;++s){const h=X[s];if(h.isIndexed())h.newIndex=o[h.index],h.uBuffer=e,h.vBuffer=t,h.heightBuffer=i,d&&(h.normalBuffer=n);else{const s=h.getKey();if(r.defined(o[s]))h.newIndex=o[s];else{const r=e.length;e.push(h.getU()),t.push(h.getV()),i.push(h.getH()),d&&(n.push(h.getNormalX()),n.push(h.getNormalY())),h.newIndex=r,o[s]=r}}}3===p?(s.push(X[0].newIndex),s.push(X[1].newIndex),s.push(X[2].newIndex)):4===p&&(s.push(X[0].newIndex),s.push(X[1].newIndex),s.push(X[2].newIndex),s.push(X[0].newIndex),s.push(X[2].newIndex),s.push(X[3].newIndex))}return X.push(new H),X.push(new H),X.push(new H),X.push(new H),p((function(e,r){const h=e.isEastChild,p=e.isNorthChild,f=h?v:0,l=h?y:v,a=p?v:0,c=p?y:v,g=D,m=T,x=O,w=z;g.length=0,m.length=0,x.length=0,w.length=0;const S=M;S.length=0;const U={},F=e.vertices;let P=e.indices;P=P.subarray(0,e.indexCountWithoutSkirts);const W=s.TerrainEncoding.clone(e.encoding),X=W.hasVertexNormals;let L=0;const Y=e.vertexCountWithoutSkirts,_=e.minimumHeight,G=e.maximumHeight,J=new Array(Y),Z=new Array(Y),j=new Array(Y),Q=X?new Array(2*Y):void 0;let $,ee,te,ie,ne;for(ee=0,te=0;ee<Y;++ee,te+=2){const e=W.decodeTextureCoordinates(F,ee,q);if($=W.decodeHeight(F,ee),ie=u.CesiumMath.clamp(e.x*y|0,0,y),ne=u.CesiumMath.clamp(e.y*y|0,0,y),j[ee]=u.CesiumMath.clamp(($-_)/(G-_)*y|0,0,y),ie<20&&(ie=0),ne<20&&(ne=0),y-ie<20&&(ie=y),y-ne<20&&(ne=y),J[ee]=ie,Z[ee]=ne,X){const e=W.getOctEncodedNormal(F,ee,R);Q[te]=e.x,Q[te+1]=e.y}(h&&ie>=v||!h&&ie<=v)&&(p&&ne>=v||!p&&ne<=v)&&(U[ee]=L,g.push(ie),m.push(ne),x.push(j[ee]),X&&(w.push(Q[te]),w.push(Q[te+1])),++L)}const re=[];re.push(new H),re.push(new H),re.push(new H);const se=[];let oe,he;for(se.push(new H),se.push(new H),se.push(new H),ee=0;ee<P.length;ee+=3){const e=P[ee],t=P[ee+1],i=P[ee+2],n=J[e],r=J[t],s=J[i];re[0].initializeIndexed(J,Z,j,Q,e),re[1].initializeIndexed(J,Z,j,Q,t),re[2].initializeIndexed(J,Z,j,Q,i);const o=C.clipTriangleAtAxisAlignedThreshold(v,h,n,r,s,B);oe=0,oe>=o.length||(oe=se[0].initializeFromClipResult(o,oe,re),oe>=o.length||(oe=se[1].initializeFromClipResult(o,oe,re),oe>=o.length||(oe=se[2].initializeFromClipResult(o,oe,re),he=C.clipTriangleAtAxisAlignedThreshold(v,p,se[0].getV(),se[1].getV(),se[2].getV(),b),K(g,m,x,w,S,U,he,se,X),oe<o.length&&(se[2].clone(se[1]),se[2].initializeFromClipResult(o,oe,re),he=C.clipTriangleAtAxisAlignedThreshold(v,p,se[0].getV(),se[1].getV(),se[2].getV(),b),K(g,m,x,w,S,U,he,se,X)))))}const ue=h?-32767:0,de=p?-32767:0,pe=[],fe=[],le=[],ae=[];let ce=Number.MAX_VALUE,ge=-ce;const me=A;me.length=0;const xe=n.Ellipsoid.clone(e.ellipsoid),we=i.Rectangle.clone(e.childRectangle),Ce=we.north,ye=we.south;let ve=we.east;const Be=we.west;for(ve<Be&&(ve+=u.CesiumMath.TWO_PI),ee=0;ee<g.length;++ee)ie=Math.round(g[ee]),ie<=f?(pe.push(ee),ie=0):ie>=l?(le.push(ee),ie=y):ie=2*ie+ue,g[ee]=ie,ne=Math.round(m[ee]),ne<=a?(fe.push(ee),ne=0):ne>=c?(ae.push(ee),ne=y):ne=2*ne+de,m[ee]=ne,$=u.CesiumMath.lerp(_,G,x[ee]/y),$<ce&&(ce=$),$>ge&&(ge=$),x[ee]=$,I.longitude=u.CesiumMath.lerp(Be,ve,ie/y),I.latitude=u.CesiumMath.lerp(ye,Ce,ne/y),I.height=$,xe.cartographicToCartesian(I,E),me.push(E.x),me.push(E.y),me.push(E.z);const be=t.BoundingSphere.fromVertices(me,n.Cartesian3.ZERO,3,k),Ae=d.OrientedBoundingBox.fromRectangle(we,ce,ge,xe,N),Ie=new s.EllipsoidalOccluder(xe).computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(be.center,me,3,be.center,ce,V),Ee=ge-ce,De=new Uint16Array(g.length+m.length+x.length);for(ee=0;ee<g.length;++ee)De[ee]=g[ee];let Te=g.length;for(ee=0;ee<m.length;++ee)De[Te+ee]=m[ee];for(Te+=m.length,ee=0;ee<x.length;++ee)De[Te+ee]=y*(x[ee]-ce)/Ee;const Oe=o.IndexDatatype.createTypedArray(g.length,S);let Me;if(X){const e=new Uint8Array(w);r.push(De.buffer,Oe.buffer,e.buffer),Me=e.buffer}else r.push(De.buffer,Oe.buffer);return{vertices:De.buffer,encodedNormals:Me,indices:Oe.buffer,minimumHeight:ce,maximumHeight:ge,westIndices:pe,southIndices:fe,eastIndices:le,northIndices:ae,boundingSphere:be,orientedBoundingBox:Ae,horizonOcclusionPoint:Ie}}))}));