/*! For license information please see chunk-S7IBK36I.js.LICENSE.txt */
import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import{Cartesian2_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var scratchPosition=new Cartesian3_default,scratchNormal=new Cartesian3_default,scratchTangent=new Cartesian3_default,scratchBitangent=new Cartesian3_default,scratchNormalST=new Cartesian3_default,defaultRadii=new Cartesian3_default(1,1,1),cos=Math.cos,sin=Math.sin;function EllipsoidGeometry(t){t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT);const e=defaultValue_default(t.radii,defaultRadii),a=defaultValue_default(t.innerRadii,e),i=defaultValue_default(t.minimumClock,0),r=defaultValue_default(t.maximumClock,Math_default.TWO_PI),n=defaultValue_default(t.minimumCone,0),o=defaultValue_default(t.maximumCone,Math_default.PI),l=Math.round(defaultValue_default(t.stackPartitions,64)),u=Math.round(defaultValue_default(t.slicePartitions,64)),s=defaultValue_default(t.vertexFormat,VertexFormat_default.DEFAULT);if(u<3)throw new DeveloperError_default("options.slicePartitions cannot be less than three.");if(l<3)throw new DeveloperError_default("options.stackPartitions cannot be less than three.");this._radii=Cartesian3_default.clone(e),this._innerRadii=Cartesian3_default.clone(a),this._minimumClock=i,this._maximumClock=r,this._minimumCone=n,this._maximumCone=o,this._stackPartitions=l,this._slicePartitions=u,this._vertexFormat=VertexFormat_default.clone(s),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}EllipsoidGeometry.packedLength=2*Cartesian3_default.packedLength+VertexFormat_default.packedLength+7,EllipsoidGeometry.pack=function(t,e,a){if(!defined_default(t))throw new DeveloperError_default("value is required");if(!defined_default(e))throw new DeveloperError_default("array is required");return a=defaultValue_default(a,0),Cartesian3_default.pack(t._radii,e,a),a+=Cartesian3_default.packedLength,Cartesian3_default.pack(t._innerRadii,e,a),a+=Cartesian3_default.packedLength,VertexFormat_default.pack(t._vertexFormat,e,a),a+=VertexFormat_default.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=defaultValue_default(t._offsetAttribute,-1),e};var unitEllipsoidGeometry,scratchRadii=new Cartesian3_default,scratchInnerRadii=new Cartesian3_default,scratchVertexFormat=new VertexFormat_default,scratchOptions={radii:scratchRadii,innerRadii:scratchInnerRadii,vertexFormat:scratchVertexFormat,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};EllipsoidGeometry.unpack=function(t,e,a){if(!defined_default(t))throw new DeveloperError_default("array is required");e=defaultValue_default(e,0);const i=Cartesian3_default.unpack(t,e,scratchRadii);e+=Cartesian3_default.packedLength;const r=Cartesian3_default.unpack(t,e,scratchInnerRadii);e+=Cartesian3_default.packedLength;const n=VertexFormat_default.unpack(t,e,scratchVertexFormat);e+=VertexFormat_default.packedLength;const o=t[e++],l=t[e++],u=t[e++],s=t[e++],d=t[e++],f=t[e++],m=t[e];return defined_default(a)?(a._radii=Cartesian3_default.clone(i,a._radii),a._innerRadii=Cartesian3_default.clone(r,a._innerRadii),a._vertexFormat=VertexFormat_default.clone(n,a._vertexFormat),a._minimumClock=o,a._maximumClock=l,a._minimumCone=u,a._maximumCone=s,a._stackPartitions=d,a._slicePartitions=f,a._offsetAttribute=-1===m?void 0:m,a):(scratchOptions.minimumClock=o,scratchOptions.maximumClock=l,scratchOptions.minimumCone=u,scratchOptions.maximumCone=s,scratchOptions.stackPartitions=d,scratchOptions.slicePartitions=f,scratchOptions.offsetAttribute=-1===m?void 0:m,new EllipsoidGeometry(scratchOptions))},EllipsoidGeometry.createGeometry=function(t){const e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;const a=t._innerRadii;if(a.x<=0||a.y<=0||a.z<=0)return;const i=t._minimumClock,r=t._maximumClock,n=t._minimumCone,o=t._maximumCone,l=t._vertexFormat;let u,s,d=t._slicePartitions+1,f=t._stackPartitions+1;d=Math.round(d*Math.abs(r-i)/Math_default.TWO_PI),f=Math.round(f*Math.abs(o-n)/Math_default.PI),d<2&&(d=2),f<2&&(f=2);let m=0;const c=[n],_=[i];for(u=0;u<f;u++)c.push(n+u*(o-n)/(f-1));for(c.push(o),s=0;s<d;s++)_.push(i+s*(r-i)/(d-1));_.push(r);const p=c.length,h=_.length;let y=0,C=1;const k=a.x!==e.x||a.y!==e.y||a.z!==e.z;let x=!1,A=!1,w=!1;k&&(C=2,n>0&&(x=!0,y+=d-1),o<Math.PI&&(A=!0,y+=d-1),(r-i)%Math_default.TWO_PI?(w=!0,y+=2*(f-1)+1):y+=1);const P=h*p*C,v=new Float64Array(3*P),E=new Array(P).fill(!1),b=new Array(P).fill(!1),g=d*f*C,G=6*(g+y+1-(d+f)*C),F=IndexDatatype_default.createTypedArray(g,G),V=l.normal?new Float32Array(3*P):void 0,D=l.tangent?new Float32Array(3*P):void 0,O=l.bitangent?new Float32Array(3*P):void 0,T=l.st?new Float32Array(2*P):void 0,I=new Array(p),M=new Array(p);for(u=0;u<p;u++)I[u]=sin(c[u]),M[u]=cos(c[u]);const L=new Array(h),N=new Array(h);for(s=0;s<h;s++)N[s]=cos(_[s]),L[s]=sin(_[s]);for(u=0;u<p;u++)for(s=0;s<h;s++)v[m++]=e.x*I[u]*N[s],v[m++]=e.y*I[u]*L[s],v[m++]=e.z*M[u];let R,S,j,z,B=P/2;if(k)for(u=0;u<p;u++)for(s=0;s<h;s++)v[m++]=a.x*I[u]*N[s],v[m++]=a.y*I[u]*L[s],v[m++]=a.z*M[u],E[B]=!0,u>0&&u!==p-1&&0!==s&&s!==h-1&&(b[B]=!0),B++;for(m=0,u=1;u<p-2;u++)for(R=u*h,S=(u+1)*h,s=1;s<h-2;s++)F[m++]=S+s,F[m++]=S+s+1,F[m++]=R+s+1,F[m++]=S+s,F[m++]=R+s+1,F[m++]=R+s;if(k){const t=p*h;for(u=1;u<p-2;u++)for(R=t+u*h,S=t+(u+1)*h,s=1;s<h-2;s++)F[m++]=S+s,F[m++]=R+s,F[m++]=R+s+1,F[m++]=S+s,F[m++]=R+s+1,F[m++]=S+s+1}if(k){if(x)for(z=p*h,u=1;u<h-2;u++)F[m++]=u,F[m++]=u+1,F[m++]=z+u+1,F[m++]=u,F[m++]=z+u+1,F[m++]=z+u;if(A)for(j=p*h-h,z=p*h*C-h,u=1;u<h-2;u++)F[m++]=j+u+1,F[m++]=j+u,F[m++]=z+u,F[m++]=j+u+1,F[m++]=z+u,F[m++]=z+u+1}if(w){for(u=1;u<p-2;u++)z=h*p+h*u,j=h*u,F[m++]=z,F[m++]=j+h,F[m++]=j,F[m++]=z,F[m++]=z+h,F[m++]=j+h;for(u=1;u<p-2;u++)z=h*p+h*(u+1)-1,j=h*(u+1)-1,F[m++]=j+h,F[m++]=z,F[m++]=j,F[m++]=j+h,F[m++]=z+h,F[m++]=z}const Y=new GeometryAttributes_default;l.position&&(Y.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:v}));let U=0,Z=0,W=0,J=0;const H=P/2;let X;const q=Ellipsoid_default.fromCartesian3(e),Q=Ellipsoid_default.fromCartesian3(a);if(l.st||l.normal||l.tangent||l.bitangent){for(u=0;u<P;u++){X=E[u]?Q:q;const t=Cartesian3_default.fromArray(v,3*u,scratchPosition),e=X.geodeticSurfaceNormal(t,scratchNormal);if(b[u]&&Cartesian3_default.negate(e,e),l.st){const t=Cartesian2_default.negate(e,scratchNormalST);T[U++]=Math.atan2(t.y,t.x)/Math_default.TWO_PI+.5,T[U++]=Math.asin(e.z)/Math.PI+.5}if(l.normal&&(V[Z++]=e.x,V[Z++]=e.y,V[Z++]=e.z),l.tangent||l.bitangent){const t=scratchTangent;let a,i=0;if(E[u]&&(i=H),a=!x&&u>=i&&u<i+2*h?Cartesian3_default.UNIT_X:Cartesian3_default.UNIT_Z,Cartesian3_default.cross(a,e,t),Cartesian3_default.normalize(t,t),l.tangent&&(D[W++]=t.x,D[W++]=t.y,D[W++]=t.z),l.bitangent){const a=Cartesian3_default.cross(e,t,scratchBitangent);Cartesian3_default.normalize(a,a),O[J++]=a.x,O[J++]=a.y,O[J++]=a.z}}}l.st&&(Y.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:T})),l.normal&&(Y.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:V})),l.tangent&&(Y.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:D})),l.bitangent&&(Y.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:O}))}if(defined_default(t._offsetAttribute)){const e=v.length,a=t._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,i=new Uint8Array(e/3).fill(a);Y.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return new Geometry_default({attributes:Y,indices:F,primitiveType:PrimitiveType_default.TRIANGLES,boundingSphere:BoundingSphere_default.fromEllipsoid(q),offsetAttribute:t._offsetAttribute})},EllipsoidGeometry.getUnitEllipsoid=function(){return defined_default(unitEllipsoidGeometry)||(unitEllipsoidGeometry=EllipsoidGeometry.createGeometry(new EllipsoidGeometry({radii:new Cartesian3_default(1,1,1),vertexFormat:VertexFormat_default.POSITION_ONLY}))),unitEllipsoidGeometry};var EllipsoidGeometry_default=EllipsoidGeometry;export{EllipsoidGeometry_default};