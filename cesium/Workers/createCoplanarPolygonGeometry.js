/*! For license information please see createCoplanarPolygonGeometry.js.LICENSE.txt */
import{BoundingRectangle_default}from"./chunk-KUB2HQXR.js";import{CoplanarPolygonGeometryLibrary_default}from"./chunk-364TQORK.js";import"./chunk-QY2WY5XJ.js";import{PolygonGeometryLibrary_default}from"./chunk-VODWDCX6.js";import"./chunk-235MRXLH.js";import{GeometryInstance_default}from"./chunk-GTEXWEAP.js";import{GeometryPipeline_default}from"./chunk-36ESDRIZ.js";import"./chunk-I6TVJ6T7.js";import"./chunk-VOAZN4IP.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import"./chunk-MOLGJDJV.js";import"./chunk-FGUP2QEP.js";import{PolygonPipeline_default}from"./chunk-ZVUAJKAL.js";import{arrayRemoveDuplicates_default}from"./chunk-DTNN3ODA.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default,Quaternion_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Cartesian2_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Ellipsoid_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var scratchPosition=new Cartesian3_default,scratchBR=new BoundingRectangle_default,stScratch=new Cartesian2_default,textureCoordinatesOrigin=new Cartesian2_default,scratchNormal=new Cartesian3_default,scratchTangent=new Cartesian3_default,scratchBitangent=new Cartesian3_default,centerScratch=new Cartesian3_default,axis1Scratch=new Cartesian3_default,axis2Scratch=new Cartesian3_default,quaternionScratch=new Quaternion_default,textureMatrixScratch=new Matrix3_default,tangentRotationScratch=new Matrix3_default,surfaceNormalScratch=new Cartesian3_default;function createGeometryFromPolygon(t,e,a,o,r,n,i,l,u){const d=t.positions;let s=PolygonPipeline_default.triangulate(t.positions2D,t.holes);s.length<3&&(s=[0,1,2]);const c=IndexDatatype_default.createTypedArray(d.length,s.length);c.set(s);let f=textureMatrixScratch;if(0!==o){let t=Quaternion_default.fromAxisAngle(i,o,quaternionScratch);if(f=Matrix3_default.fromQuaternion(t,f),e.tangent||e.bitangent){t=Quaternion_default.fromAxisAngle(i,-o,quaternionScratch);const a=Matrix3_default.fromQuaternion(t,tangentRotationScratch);l=Cartesian3_default.normalize(Matrix3_default.multiplyByVector(a,l,l),l),e.bitangent&&(u=Cartesian3_default.normalize(Cartesian3_default.cross(i,l,u),u))}}else f=Matrix3_default.clone(Matrix3_default.IDENTITY,f);const p=textureCoordinatesOrigin;e.st&&(p.x=a.x,p.y=a.y);const y=d.length,m=3*y,_=new Float64Array(m),h=e.normal?new Float32Array(m):void 0,g=e.tangent?new Float32Array(m):void 0,C=e.bitangent?new Float32Array(m):void 0,P=e.st?new Float32Array(2*y):void 0;let x=0,k=0,G=0,b=0,F=0;for(let t=0;t<y;t++){const o=d[t];if(_[x++]=o.x,_[x++]=o.y,_[x++]=o.z,e.st)if(defined_default(r)&&r.positions.length===y)P[F++]=r.positions[t].x,P[F++]=r.positions[t].y;else{const t=n(Matrix3_default.multiplyByVector(f,o,scratchPosition),stScratch);Cartesian2_default.subtract(t,p,t);const e=Math_default.clamp(t.x/a.width,0,1),r=Math_default.clamp(t.y/a.height,0,1);P[F++]=e,P[F++]=r}e.normal&&(h[k++]=i.x,h[k++]=i.y,h[k++]=i.z),e.tangent&&(g[b++]=l.x,g[b++]=l.y,g[b++]=l.z),e.bitangent&&(C[G++]=u.x,C[G++]=u.y,C[G++]=u.z)}const A=new GeometryAttributes_default;return e.position&&(A.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:_})),e.normal&&(A.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:h})),e.tangent&&(A.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:g})),e.bitangent&&(A.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:C})),e.st&&(A.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:P})),new Geometry_default({attributes:A,indices:c,primitiveType:PrimitiveType_default.TRIANGLES})}function CoplanarPolygonGeometry(t){const e=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).polygonHierarchy,a=t.textureCoordinates;Check_default.defined("options.polygonHierarchy",e);const o=defaultValue_default(t.vertexFormat,VertexFormat_default.DEFAULT);this._vertexFormat=VertexFormat_default.clone(o),this._polygonHierarchy=e,this._stRotation=defaultValue_default(t.stRotation,0),this._ellipsoid=Ellipsoid_default.clone(defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84)),this._workerName="createCoplanarPolygonGeometry",this._textureCoordinates=a,this.packedLength=PolygonGeometryLibrary_default.computeHierarchyPackedLength(e,Cartesian3_default)+VertexFormat_default.packedLength+Ellipsoid_default.packedLength+(defined_default(a)?PolygonGeometryLibrary_default.computeHierarchyPackedLength(a,Cartesian2_default):1)+2}CoplanarPolygonGeometry.fromPositions=function(t){return t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT),Check_default.defined("options.positions",t.positions),new CoplanarPolygonGeometry({polygonHierarchy:{positions:t.positions},vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,textureCoordinates:t.textureCoordinates})},CoplanarPolygonGeometry.pack=function(t,e,a){return Check_default.typeOf.object("value",t),Check_default.defined("array",e),a=defaultValue_default(a,0),a=PolygonGeometryLibrary_default.packPolygonHierarchy(t._polygonHierarchy,e,a,Cartesian3_default),Ellipsoid_default.pack(t._ellipsoid,e,a),a+=Ellipsoid_default.packedLength,VertexFormat_default.pack(t._vertexFormat,e,a),a+=VertexFormat_default.packedLength,e[a++]=t._stRotation,defined_default(t._textureCoordinates)?a=PolygonGeometryLibrary_default.packPolygonHierarchy(t._textureCoordinates,e,a,Cartesian2_default):e[a++]=-1,e[a++]=t.packedLength,e};var scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchVertexFormat=new VertexFormat_default,scratchOptions={polygonHierarchy:{}};CoplanarPolygonGeometry.unpack=function(t,e,a){Check_default.defined("array",t),e=defaultValue_default(e,0);const o=PolygonGeometryLibrary_default.unpackPolygonHierarchy(t,e,Cartesian3_default);e=o.startingIndex,delete o.startingIndex;const r=Ellipsoid_default.unpack(t,e,scratchEllipsoid);e+=Ellipsoid_default.packedLength;const n=VertexFormat_default.unpack(t,e,scratchVertexFormat);e+=VertexFormat_default.packedLength;const i=t[e++],l=-1===t[e]?void 0:PolygonGeometryLibrary_default.unpackPolygonHierarchy(t,e,Cartesian2_default);defined_default(l)?(e=l.startingIndex,delete l.startingIndex):e++;const u=t[e++];return defined_default(a)||(a=new CoplanarPolygonGeometry(scratchOptions)),a._polygonHierarchy=o,a._ellipsoid=Ellipsoid_default.clone(r,a._ellipsoid),a._vertexFormat=VertexFormat_default.clone(n,a._vertexFormat),a._stRotation=i,a._textureCoordinates=l,a.packedLength=u,a},CoplanarPolygonGeometry.createGeometry=function(t){const e=t._vertexFormat,a=t._polygonHierarchy,o=t._stRotation,r=t._textureCoordinates,n=defined_default(r);let i=a.positions;if(i=arrayRemoveDuplicates_default(i,Cartesian3_default.equalsEpsilon,!0),i.length<3)return;let l=scratchNormal,u=scratchTangent,d=scratchBitangent,s=axis1Scratch;const c=axis2Scratch;if(!CoplanarPolygonGeometryLibrary_default.computeProjectTo2DArguments(i,centerScratch,s,c))return;if(l=Cartesian3_default.cross(s,c,l),l=Cartesian3_default.normalize(l,l),!Cartesian3_default.equalsEpsilon(centerScratch,Cartesian3_default.ZERO,Math_default.EPSILON6)){const e=t._ellipsoid.geodeticSurfaceNormal(centerScratch,surfaceNormalScratch);Cartesian3_default.dot(l,e)<0&&(l=Cartesian3_default.negate(l,l),s=Cartesian3_default.negate(s,s))}const f=CoplanarPolygonGeometryLibrary_default.createProjectPointsTo2DFunction(centerScratch,s,c),p=CoplanarPolygonGeometryLibrary_default.createProjectPointTo2DFunction(centerScratch,s,c);e.tangent&&(u=Cartesian3_default.clone(s,u)),e.bitangent&&(d=Cartesian3_default.clone(c,d));const y=PolygonGeometryLibrary_default.polygonsFromHierarchy(a,n,f,!1),m=y.hierarchy,_=y.polygons,h=n?PolygonGeometryLibrary_default.polygonsFromHierarchy(r,!0,(function(t){return t}),!1).polygons:void 0;if(0===m.length)return;i=m[0].outerRing;const g=BoundingSphere_default.fromPoints(i),C=PolygonGeometryLibrary_default.computeBoundingRectangle(l,p,i,o,scratchBR),P=[];for(let t=0;t<_.length;t++){const a=new GeometryInstance_default({geometry:createGeometryFromPolygon(_[t],e,C,o,n?h[t]:void 0,p,l,u,d)});P.push(a)}const x=GeometryPipeline_default.combineInstances(P)[0];x.attributes.position.values=new Float64Array(x.attributes.position.values),x.indices=IndexDatatype_default.createTypedArray(x.attributes.position.values.length/3,x.indices);const k=x.attributes;return e.position||delete k.position,new Geometry_default({attributes:k,indices:x.indices,primitiveType:x.primitiveType,boundingSphere:g})};var CoplanarPolygonGeometry_default=CoplanarPolygonGeometry;function createCoplanarPolygonGeometry(t,e){return defined_default(e)&&(t=CoplanarPolygonGeometry_default.unpack(t,e)),CoplanarPolygonGeometry_default.createGeometry(t)}var createCoplanarPolygonGeometry_default=createCoplanarPolygonGeometry;export{createCoplanarPolygonGeometry_default as default};