/*! For license information please see createCorridorGeometry.js.LICENSE.txt */
import{CorridorGeometryLibrary_default}from"./chunk-ZGMOBRTG.js";import{CornerType_default}from"./chunk-D325WRAY.js";import"./chunk-7ONRI7T4.js";import"./chunk-3FCUUN6M.js";import"./chunk-LSGUCCKJ.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import"./chunk-MOLGJDJV.js";import"./chunk-FGUP2QEP.js";import{PolygonPipeline_default}from"./chunk-ZVUAJKAL.js";import{arrayRemoveDuplicates_default}from"./chunk-DTNN3ODA.js";import"./chunk-6PWSSCRA.js";import"./chunk-HEROVJML.js";import"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import"./chunk-HSW63JN4.js";import{Rectangle_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import"./chunk-66CXKODF.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var cartesian1=new Cartesian3_default,cartesian2=new Cartesian3_default,cartesian3=new Cartesian3_default,cartesian4=new Cartesian3_default,cartesian5=new Cartesian3_default,cartesian6=new Cartesian3_default,scratch1=new Cartesian3_default,scratch2=new Cartesian3_default;function scaleToSurface(t,e){for(let a=0;a<t.length;a++)t[a]=e.scaleToGeodeticSurface(t[a],t[a]);return t}function addNormals(t,e,a,r,i,o){const n=t.normals,s=t.tangents,l=t.bitangents,d=Cartesian3_default.normalize(Cartesian3_default.cross(a,e,scratch1),scratch1);o.normal&&CorridorGeometryLibrary_default.addAttribute(n,e,r,i),o.tangent&&CorridorGeometryLibrary_default.addAttribute(s,d,r,i),o.bitangent&&CorridorGeometryLibrary_default.addAttribute(l,a,r,i)}function combine(t,e,a){const r=t.positions,i=t.corners,o=t.endPositions,n=t.lefts,s=t.normals,l=new GeometryAttributes_default;let d,u,c,f=0,h=0,_=0;for(u=0;u<r.length;u+=2)c=r[u].length-3,f+=c,_+=2*c,h+=r[u+1].length-3;for(f+=3,h+=3,u=0;u<i.length;u++){d=i[u];const t=i[u].leftPositions;defined_default(t)?(c=t.length,f+=c,_+=c):(c=i[u].rightPositions.length,h+=c,_+=c)}const m=defined_default(o);let p;m&&(p=o[0].length-3,f+=p,h+=p,p/=3,_+=6*p);const C=f+h,g=new Float64Array(C),y={normals:e.normal?new Float32Array(C):void 0,tangents:e.tangent?new Float32Array(C):void 0,bitangents:e.bitangent?new Float32Array(C):void 0};let b,A,v,G,w,M,O=0,E=C-1,T=cartesian1,x=cartesian2;const N=p/2,V=IndexDatatype_default.createTypedArray(C/3,_);let P=0;if(m){M=cartesian3,w=cartesian4;const t=o[0];for(T=Cartesian3_default.fromArray(s,0,T),x=Cartesian3_default.fromArray(n,0,x),u=0;u<N;u++)M=Cartesian3_default.fromArray(t,3*(N-1-u),M),w=Cartesian3_default.fromArray(t,3*(N+u),w),CorridorGeometryLibrary_default.addAttribute(g,w,O),CorridorGeometryLibrary_default.addAttribute(g,M,void 0,E),addNormals(y,T,x,O,E,e),A=O/3,G=A+1,b=(E-2)/3,v=b-1,V[P++]=b,V[P++]=A,V[P++]=v,V[P++]=v,V[P++]=A,V[P++]=G,O+=3,E-=3}let k,F,L=0,D=0,I=r[L++],S=r[L++];for(g.set(I,O),g.set(S,E-S.length+1),x=Cartesian3_default.fromArray(n,D,x),c=S.length-3,u=0;u<c;u+=3)k=a.geodeticSurfaceNormal(Cartesian3_default.fromArray(I,u,scratch1),scratch1),F=a.geodeticSurfaceNormal(Cartesian3_default.fromArray(S,c-u,scratch2),scratch2),T=Cartesian3_default.normalize(Cartesian3_default.add(k,F,T),T),addNormals(y,T,x,O,E,e),A=O/3,G=A+1,b=(E-2)/3,v=b-1,V[P++]=b,V[P++]=A,V[P++]=v,V[P++]=v,V[P++]=A,V[P++]=G,O+=3,E-=3;for(k=a.geodeticSurfaceNormal(Cartesian3_default.fromArray(I,c,scratch1),scratch1),F=a.geodeticSurfaceNormal(Cartesian3_default.fromArray(S,c,scratch2),scratch2),T=Cartesian3_default.normalize(Cartesian3_default.add(k,F,T),T),D+=3,u=0;u<i.length;u++){let t;d=i[u];const o=d.leftPositions,l=d.rightPositions;let f,h,_=cartesian6,m=cartesian3,p=cartesian4;if(T=Cartesian3_default.fromArray(s,D,T),defined_default(o)){for(addNormals(y,T,x,void 0,E,e),E-=3,f=G,h=v,t=0;t<o.length/3;t++)_=Cartesian3_default.fromArray(o,3*t,_),V[P++]=f,V[P++]=h-t-1,V[P++]=h-t,CorridorGeometryLibrary_default.addAttribute(g,_,void 0,E),m=Cartesian3_default.fromArray(g,3*(h-t-1),m),p=Cartesian3_default.fromArray(g,3*f,p),x=Cartesian3_default.normalize(Cartesian3_default.subtract(m,p,x),x),addNormals(y,T,x,void 0,E,e),E-=3;_=Cartesian3_default.fromArray(g,3*f,_),m=Cartesian3_default.subtract(Cartesian3_default.fromArray(g,3*h,m),_,m),p=Cartesian3_default.subtract(Cartesian3_default.fromArray(g,3*(h-t),p),_,p),x=Cartesian3_default.normalize(Cartesian3_default.add(m,p,x),x),addNormals(y,T,x,O,void 0,e),O+=3}else{for(addNormals(y,T,x,O,void 0,e),O+=3,f=v,h=G,t=0;t<l.length/3;t++)_=Cartesian3_default.fromArray(l,3*t,_),V[P++]=f,V[P++]=h+t,V[P++]=h+t+1,CorridorGeometryLibrary_default.addAttribute(g,_,O),m=Cartesian3_default.fromArray(g,3*f,m),p=Cartesian3_default.fromArray(g,3*(h+t),p),x=Cartesian3_default.normalize(Cartesian3_default.subtract(m,p,x),x),addNormals(y,T,x,O,void 0,e),O+=3;_=Cartesian3_default.fromArray(g,3*f,_),m=Cartesian3_default.subtract(Cartesian3_default.fromArray(g,3*(h+t),m),_,m),p=Cartesian3_default.subtract(Cartesian3_default.fromArray(g,3*h,p),_,p),x=Cartesian3_default.normalize(Cartesian3_default.negate(Cartesian3_default.add(p,m,x),x),x),addNormals(y,T,x,void 0,E,e),E-=3}for(I=r[L++],S=r[L++],I.splice(0,3),S.splice(S.length-3,3),g.set(I,O),g.set(S,E-S.length+1),c=S.length-3,D+=3,x=Cartesian3_default.fromArray(n,D,x),t=0;t<S.length;t+=3)k=a.geodeticSurfaceNormal(Cartesian3_default.fromArray(I,t,scratch1),scratch1),F=a.geodeticSurfaceNormal(Cartesian3_default.fromArray(S,c-t,scratch2),scratch2),T=Cartesian3_default.normalize(Cartesian3_default.add(k,F,T),T),addNormals(y,T,x,O,E,e),G=O/3,A=G-1,v=(E-2)/3,b=v+1,V[P++]=b,V[P++]=A,V[P++]=v,V[P++]=v,V[P++]=A,V[P++]=G,O+=3,E-=3;O-=3,E+=3}if(T=Cartesian3_default.fromArray(s,s.length-3,T),addNormals(y,T,x,O,E,e),m){O+=3,E-=3,M=cartesian3,w=cartesian4;const t=o[1];for(u=0;u<N;u++)M=Cartesian3_default.fromArray(t,3*(p-u-1),M),w=Cartesian3_default.fromArray(t,3*u,w),CorridorGeometryLibrary_default.addAttribute(g,M,void 0,E),CorridorGeometryLibrary_default.addAttribute(g,w,O),addNormals(y,T,x,O,E,e),G=O/3,A=G-1,v=(E-2)/3,b=v+1,V[P++]=b,V[P++]=A,V[P++]=v,V[P++]=v,V[P++]=A,V[P++]=G,O+=3,E-=3}if(l.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:g}),e.st){const t=new Float32Array(C/3*2);let e,a,r=0;if(m){f/=3,h/=3;const i=Math.PI/(p+1);let o;a=1/(f-p+1),e=1/(h-p+1);const n=p/2;for(u=n+1;u<p+1;u++)o=Math_default.PI_OVER_TWO+i*u,t[r++]=e*(1+Math.cos(o)),t[r++]=.5*(1+Math.sin(o));for(u=1;u<h-p+1;u++)t[r++]=u*e,t[r++]=0;for(u=p;u>n;u--)o=Math_default.PI_OVER_TWO-u*i,t[r++]=1-e*(1+Math.cos(o)),t[r++]=.5*(1+Math.sin(o));for(u=n;u>0;u--)o=Math_default.PI_OVER_TWO-i*u,t[r++]=1-a*(1+Math.cos(o)),t[r++]=.5*(1+Math.sin(o));for(u=f-p;u>0;u--)t[r++]=u*a,t[r++]=1;for(u=1;u<n+1;u++)o=Math_default.PI_OVER_TWO+i*u,t[r++]=a*(1+Math.cos(o)),t[r++]=.5*(1+Math.sin(o))}else{for(f/=3,h/=3,a=1/(f-1),e=1/(h-1),u=0;u<h;u++)t[r++]=u*e,t[r++]=0;for(u=f;u>0;u--)t[r++]=(u-1)*a,t[r++]=1}l.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(l.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:y.normals})),e.tangent&&(l.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:y.tangents})),e.bitangent&&(l.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:y.bitangents})),{attributes:l,indices:V}}function extrudedAttributes(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;const a=t.position.values;let r,i;(e.normal||e.bitangent)&&(r=t.normal.values,i=t.bitangent.values);const o=t.position.values.length/18,n=3*o,s=2*o,l=2*n;let d;if(e.normal||e.bitangent||e.tangent){const o=e.normal?new Float32Array(6*n):void 0,s=e.tangent?new Float32Array(6*n):void 0,u=e.bitangent?new Float32Array(6*n):void 0;let c=cartesian1,f=cartesian2,h=cartesian3,_=cartesian4,m=cartesian5,p=cartesian6,C=l;for(d=0;d<n;d+=3){const t=C+l;c=Cartesian3_default.fromArray(a,d,c),f=Cartesian3_default.fromArray(a,d+n,f),h=Cartesian3_default.fromArray(a,(d+3)%n,h),f=Cartesian3_default.subtract(f,c,f),h=Cartesian3_default.subtract(h,c,h),_=Cartesian3_default.normalize(Cartesian3_default.cross(f,h,_),_),e.normal&&(CorridorGeometryLibrary_default.addAttribute(o,_,t),CorridorGeometryLibrary_default.addAttribute(o,_,t+3),CorridorGeometryLibrary_default.addAttribute(o,_,C),CorridorGeometryLibrary_default.addAttribute(o,_,C+3)),(e.tangent||e.bitangent)&&(p=Cartesian3_default.fromArray(r,d,p),e.bitangent&&(CorridorGeometryLibrary_default.addAttribute(u,p,t),CorridorGeometryLibrary_default.addAttribute(u,p,t+3),CorridorGeometryLibrary_default.addAttribute(u,p,C),CorridorGeometryLibrary_default.addAttribute(u,p,C+3)),e.tangent&&(m=Cartesian3_default.normalize(Cartesian3_default.cross(p,_,m),m),CorridorGeometryLibrary_default.addAttribute(s,m,t),CorridorGeometryLibrary_default.addAttribute(s,m,t+3),CorridorGeometryLibrary_default.addAttribute(s,m,C),CorridorGeometryLibrary_default.addAttribute(s,m,C+3))),C+=6}if(e.normal){for(o.set(r),d=0;d<n;d+=3)o[d+n]=-r[d],o[d+n+1]=-r[d+1],o[d+n+2]=-r[d+2];t.normal.values=o}else t.normal=void 0;if(e.bitangent?(u.set(i),u.set(i,n),t.bitangent.values=u):t.bitangent=void 0,e.tangent){const e=t.tangent.values;s.set(e),s.set(e,n),t.tangent.values=s}}if(e.st){const e=t.st.values,a=new Float32Array(6*s);a.set(e),a.set(e,s);let r=2*s;for(let t=0;t<2;t++){for(a[r++]=e[0],a[r++]=e[1],d=2;d<s;d+=2){const t=e[d],i=e[d+1];a[r++]=t,a[r++]=i,a[r++]=t,a[r++]=i}a[r++]=e[0],a[r++]=e[1]}t.st.values=a}return t}function addWallPositions(t,e,a){a[e++]=t[0],a[e++]=t[1],a[e++]=t[2];for(let r=3;r<t.length;r+=3){const i=t[r],o=t[r+1],n=t[r+2];a[e++]=i,a[e++]=o,a[e++]=n,a[e++]=i,a[e++]=o,a[e++]=n}return a[e++]=t[0],a[e++]=t[1],a[e++]=t[2],a}function computePositionsExtruded(t,e){const a=new VertexFormat_default({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),r=t.ellipsoid,i=combine(CorridorGeometryLibrary_default.computePositions(t),a,r),o=t.height,n=t.extrudedHeight;let s=i.attributes;const l=i.indices;let d=s.position.values,u=d.length;const c=new Float64Array(6*u);let f=new Float64Array(u);f.set(d);let h,_=new Float64Array(4*u);d=PolygonPipeline_default.scaleToGeodeticHeight(d,o,r),_=addWallPositions(d,0,_),f=PolygonPipeline_default.scaleToGeodeticHeight(f,n,r),_=addWallPositions(f,2*u,_),c.set(d),c.set(f,u),c.set(_,2*u),s.position.values=c,s=extrudedAttributes(s,e);const m=u/3;if(t.shadowVolume){const t=s.normal.values;u=t.length;let a=new Float32Array(6*u);for(h=0;h<u;h++)t[h]=-t[h];a.set(t,u),a=addWallPositions(t,4*u,a),s.extrudeDirection=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:a}),e.normal||(s.normal=void 0)}if(defined_default(t.offsetAttribute)){let e=new Uint8Array(6*m);if(t.offsetAttribute===GeometryOffsetAttribute_default.TOP)e=e.fill(1,0,m).fill(1,2*m,4*m);else{const a=t.offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1;e=e.fill(a)}s.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}const p=l.length,C=m+m,g=IndexDatatype_default.createTypedArray(c.length/3,2*p+3*C);g.set(l);let y,b,A,v,G=p;for(h=0;h<p;h+=3){const t=l[h],e=l[h+1],a=l[h+2];g[G++]=a+m,g[G++]=e+m,g[G++]=t+m}for(h=0;h<C;h+=2)y=h+C,b=y+C,A=y+1,v=b+1,g[G++]=y,g[G++]=b,g[G++]=A,g[G++]=A,g[G++]=b,g[G++]=v;return{attributes:s,indices:g}}var scratchCartesian1=new Cartesian3_default,scratchCartesian2=new Cartesian3_default,scratchCartographic=new Cartographic_default;function computeOffsetPoints(t,e,a,r,i,o){const n=Cartesian3_default.subtract(e,t,scratchCartesian1);Cartesian3_default.normalize(n,n);const s=a.geodeticSurfaceNormal(t,scratchCartesian2),l=Cartesian3_default.cross(n,s,scratchCartesian1);Cartesian3_default.multiplyByScalar(l,r,l);let d=i.latitude,u=i.longitude,c=o.latitude,f=o.longitude;Cartesian3_default.add(t,l,scratchCartesian2),a.cartesianToCartographic(scratchCartesian2,scratchCartographic);let h=scratchCartographic.latitude,_=scratchCartographic.longitude;d=Math.min(d,h),u=Math.min(u,_),c=Math.max(c,h),f=Math.max(f,_),Cartesian3_default.subtract(t,l,scratchCartesian2),a.cartesianToCartographic(scratchCartesian2,scratchCartographic),h=scratchCartographic.latitude,_=scratchCartographic.longitude,d=Math.min(d,h),u=Math.min(u,_),c=Math.max(c,h),f=Math.max(f,_),i.latitude=d,i.longitude=u,o.latitude=c,o.longitude=f}var scratchCartesianOffset=new Cartesian3_default,scratchCartesianEnds=new Cartesian3_default,scratchCartographicMin=new Cartographic_default,scratchCartographicMax=new Cartographic_default;function computeRectangle(t,e,a,r,i){t=scaleToSurface(t,e);const o=arrayRemoveDuplicates_default(t,Cartesian3_default.equalsEpsilon),n=o.length;if(n<2||a<=0)return new Rectangle_default;const s=.5*a;let l,d;if(scratchCartographicMin.latitude=Number.POSITIVE_INFINITY,scratchCartographicMin.longitude=Number.POSITIVE_INFINITY,scratchCartographicMax.latitude=Number.NEGATIVE_INFINITY,scratchCartographicMax.longitude=Number.NEGATIVE_INFINITY,r===CornerType_default.ROUNDED){const t=o[0];Cartesian3_default.subtract(t,o[1],scratchCartesianOffset),Cartesian3_default.normalize(scratchCartesianOffset,scratchCartesianOffset),Cartesian3_default.multiplyByScalar(scratchCartesianOffset,s,scratchCartesianOffset),Cartesian3_default.add(t,scratchCartesianOffset,scratchCartesianEnds),e.cartesianToCartographic(scratchCartesianEnds,scratchCartographic),l=scratchCartographic.latitude,d=scratchCartographic.longitude,scratchCartographicMin.latitude=Math.min(scratchCartographicMin.latitude,l),scratchCartographicMin.longitude=Math.min(scratchCartographicMin.longitude,d),scratchCartographicMax.latitude=Math.max(scratchCartographicMax.latitude,l),scratchCartographicMax.longitude=Math.max(scratchCartographicMax.longitude,d)}for(let t=0;t<n-1;++t)computeOffsetPoints(o[t],o[t+1],e,s,scratchCartographicMin,scratchCartographicMax);const u=o[n-1];Cartesian3_default.subtract(u,o[n-2],scratchCartesianOffset),Cartesian3_default.normalize(scratchCartesianOffset,scratchCartesianOffset),Cartesian3_default.multiplyByScalar(scratchCartesianOffset,s,scratchCartesianOffset),Cartesian3_default.add(u,scratchCartesianOffset,scratchCartesianEnds),computeOffsetPoints(u,scratchCartesianEnds,e,s,scratchCartographicMin,scratchCartographicMax),r===CornerType_default.ROUNDED&&(e.cartesianToCartographic(scratchCartesianEnds,scratchCartographic),l=scratchCartographic.latitude,d=scratchCartographic.longitude,scratchCartographicMin.latitude=Math.min(scratchCartographicMin.latitude,l),scratchCartographicMin.longitude=Math.min(scratchCartographicMin.longitude,d),scratchCartographicMax.latitude=Math.max(scratchCartographicMax.latitude,l),scratchCartographicMax.longitude=Math.max(scratchCartographicMax.longitude,d));const c=defined_default(i)?i:new Rectangle_default;return c.north=scratchCartographicMax.latitude,c.south=scratchCartographicMin.latitude,c.east=scratchCartographicMax.longitude,c.west=scratchCartographicMin.longitude,c}function CorridorGeometry(t){const e=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).positions,a=t.width;Check_default.defined("options.positions",e),Check_default.defined("options.width",a);const r=defaultValue_default(t.height,0),i=defaultValue_default(t.extrudedHeight,r);this._positions=e,this._ellipsoid=Ellipsoid_default.clone(defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84)),this._vertexFormat=VertexFormat_default.clone(defaultValue_default(t.vertexFormat,VertexFormat_default.DEFAULT)),this._width=a,this._height=Math.max(r,i),this._extrudedHeight=Math.min(r,i),this._cornerType=defaultValue_default(t.cornerType,CornerType_default.ROUNDED),this._granularity=defaultValue_default(t.granularity,Math_default.RADIANS_PER_DEGREE),this._shadowVolume=defaultValue_default(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*Cartesian3_default.packedLength+Ellipsoid_default.packedLength+VertexFormat_default.packedLength+7}CorridorGeometry.pack=function(t,e,a){Check_default.defined("value",t),Check_default.defined("array",e),a=defaultValue_default(a,0);const r=t._positions,i=r.length;e[a++]=i;for(let t=0;t<i;++t,a+=Cartesian3_default.packedLength)Cartesian3_default.pack(r[t],e,a);return Ellipsoid_default.pack(t._ellipsoid,e,a),a+=Ellipsoid_default.packedLength,VertexFormat_default.pack(t._vertexFormat,e,a),a+=VertexFormat_default.packedLength,e[a++]=t._width,e[a++]=t._height,e[a++]=t._extrudedHeight,e[a++]=t._cornerType,e[a++]=t._granularity,e[a++]=t._shadowVolume?1:0,e[a]=defaultValue_default(t._offsetAttribute,-1),e};var scratchEllipsoid=Ellipsoid_default.clone(Ellipsoid_default.UNIT_SPHERE),scratchVertexFormat=new VertexFormat_default,scratchOptions={positions:void 0,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};CorridorGeometry.unpack=function(t,e,a){Check_default.defined("array",t),e=defaultValue_default(e,0);const r=t[e++],i=new Array(r);for(let a=0;a<r;++a,e+=Cartesian3_default.packedLength)i[a]=Cartesian3_default.unpack(t,e);const o=Ellipsoid_default.unpack(t,e,scratchEllipsoid);e+=Ellipsoid_default.packedLength;const n=VertexFormat_default.unpack(t,e,scratchVertexFormat);e+=VertexFormat_default.packedLength;const s=t[e++],l=t[e++],d=t[e++],u=t[e++],c=t[e++],f=1===t[e++],h=t[e];return defined_default(a)?(a._positions=i,a._ellipsoid=Ellipsoid_default.clone(o,a._ellipsoid),a._vertexFormat=VertexFormat_default.clone(n,a._vertexFormat),a._width=s,a._height=l,a._extrudedHeight=d,a._cornerType=u,a._granularity=c,a._shadowVolume=f,a._offsetAttribute=-1===h?void 0:h,a):(scratchOptions.positions=i,scratchOptions.width=s,scratchOptions.height=l,scratchOptions.extrudedHeight=d,scratchOptions.cornerType=u,scratchOptions.granularity=c,scratchOptions.shadowVolume=f,scratchOptions.offsetAttribute=-1===h?void 0:h,new CorridorGeometry(scratchOptions))},CorridorGeometry.computeRectangle=function(t,e){const a=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).positions,r=t.width;return Check_default.defined("options.positions",a),Check_default.defined("options.width",r),computeRectangle(a,defaultValue_default(t.ellipsoid,Ellipsoid_default.WGS84),r,defaultValue_default(t.cornerType,CornerType_default.ROUNDED),e)},CorridorGeometry.createGeometry=function(t){let e=t._positions;const a=t._width,r=t._ellipsoid;e=scaleToSurface(e,r);const i=arrayRemoveDuplicates_default(e,Cartesian3_default.equalsEpsilon);if(i.length<2||a<=0)return;const o=t._height,n=t._extrudedHeight,s=!Math_default.equalsEpsilon(o,n,0,Math_default.EPSILON2),l=t._vertexFormat,d={ellipsoid:r,positions:i,width:a,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0};let u;if(s)d.height=o,d.extrudedHeight=n,d.shadowVolume=t._shadowVolume,d.offsetAttribute=t._offsetAttribute,u=computePositionsExtruded(d,l);else if(u=combine(CorridorGeometryLibrary_default.computePositions(d),l,r),u.attributes.position.values=PolygonPipeline_default.scaleToGeodeticHeight(u.attributes.position.values,o,r),defined_default(t._offsetAttribute)){const e=t._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,a=u.attributes.position.values.length,r=new Uint8Array(a/3).fill(e);u.attributes.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}const c=u.attributes,f=BoundingSphere_default.fromVertices(c.position.values,void 0,3);return l.position||(u.attributes.position.values=void 0),new Geometry_default({attributes:c,indices:u.indices,primitiveType:PrimitiveType_default.TRIANGLES,boundingSphere:f,offsetAttribute:t._offsetAttribute})},CorridorGeometry.createShadowVolume=function(t,e,a){const r=t._granularity,i=t._ellipsoid,o=e(r,i),n=a(r,i);return new CorridorGeometry({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:r,extrudedHeight:o,height:n,vertexFormat:VertexFormat_default.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(CorridorGeometry.prototype,{rectangle:{get:function(){return defined_default(this._rectangle)||(this._rectangle=computeRectangle(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});var CorridorGeometry_default=CorridorGeometry;function createCorridorGeometry(t,e){return defined_default(e)&&(t=CorridorGeometry_default.unpack(t,e)),t._ellipsoid=Ellipsoid_default.clone(t._ellipsoid),CorridorGeometry_default.createGeometry(t)}var createCorridorGeometry_default=createCorridorGeometry;export{createCorridorGeometry_default as default};