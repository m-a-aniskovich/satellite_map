define(["./arrayRemoveDuplicates-d2061e85","./Transforms-e2d4a55a","./Matrix3-41c58dde","./Check-6ede7e26","./ComponentDatatype-cf1fa08e","./PolylineVolumeGeometryLibrary-d25f0050","./CorridorGeometryLibrary-63907365","./defaultValue-fe22d8c0","./GeometryAttribute-13da9466","./GeometryAttributes-ad136444","./GeometryOffsetAttribute-9ad0019c","./IndexDatatype-2643aa47","./Math-0a2ac845","./PolygonPipeline-460cce4e","./Matrix2-e1298525","./VertexFormat-030f11ff","./combine-d9581036","./RuntimeError-ef395448","./WebGLConstants-0b1ce7ba","./EllipsoidTangentPlane-546c0d5e","./AxisAlignedBoundingBox-4bfd84f3","./IntersectionTests-85350792","./Plane-4c3d403b","./PolylinePipeline-7119eb3f","./EllipsoidGeodesic-5b3623dc","./EllipsoidRhumbLine-ef872433"],(function(t,e,r,a,i,o,n,s,l,d,u,c,m,f,y,p,h,g,C,b,A,_,w,v,T,G){"use strict";const E=new r.Cartesian3,V=new r.Cartesian3,x=new r.Cartesian3,L=new r.Cartesian3,P=new r.Cartesian3,F=new r.Cartesian3,N=new r.Cartesian3,M=new r.Cartesian3;function D(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function O(t,e,a,i,o,s){const l=t.normals,d=t.tangents,u=t.bitangents,c=r.Cartesian3.normalize(r.Cartesian3.cross(a,e,N),N);s.normal&&n.CorridorGeometryLibrary.addAttribute(l,e,i,o),s.tangent&&n.CorridorGeometryLibrary.addAttribute(d,c,i,o),s.bitangent&&n.CorridorGeometryLibrary.addAttribute(u,a,i,o)}function I(t,e,a){const o=t.positions,u=t.corners,f=t.endPositions,y=t.lefts,p=t.normals,h=new d.GeometryAttributes;let g,C,b,A=0,_=0,w=0;for(C=0;C<o.length;C+=2)b=o[C].length-3,A+=b,w+=2*b,_+=o[C+1].length-3;for(A+=3,_+=3,C=0;C<u.length;C++){g=u[C];const t=u[C].leftPositions;s.defined(t)?(b=t.length,A+=b,w+=b):(b=u[C].rightPositions.length,_+=b,w+=b)}const v=s.defined(f);let T;v&&(T=f[0].length-3,A+=T,_+=T,T/=3,w+=6*T);const G=A+_,P=new Float64Array(G),D={normals:e.normal?new Float32Array(G):void 0,tangents:e.tangent?new Float32Array(G):void 0,bitangents:e.bitangent?new Float32Array(G):void 0};let I,k,S,R,H,z,B=0,U=G-1,Y=E,W=V;const q=T/2,J=c.IndexDatatype.createTypedArray(G/3,w);let j=0;if(v){z=x,H=L;const t=f[0];for(Y=r.Cartesian3.fromArray(p,0,Y),W=r.Cartesian3.fromArray(y,0,W),C=0;C<q;C++)z=r.Cartesian3.fromArray(t,3*(q-1-C),z),H=r.Cartesian3.fromArray(t,3*(q+C),H),n.CorridorGeometryLibrary.addAttribute(P,H,B),n.CorridorGeometryLibrary.addAttribute(P,z,void 0,U),O(D,Y,W,B,U,e),k=B/3,R=k+1,I=(U-2)/3,S=I-1,J[j++]=I,J[j++]=k,J[j++]=S,J[j++]=S,J[j++]=k,J[j++]=R,B+=3,U-=3}let K,Q,X=0,Z=0,$=o[X++],tt=o[X++];for(P.set($,B),P.set(tt,U-tt.length+1),W=r.Cartesian3.fromArray(y,Z,W),b=tt.length-3,C=0;C<b;C+=3)K=a.geodeticSurfaceNormal(r.Cartesian3.fromArray($,C,N),N),Q=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,b-C,M),M),Y=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,Y),Y),O(D,Y,W,B,U,e),k=B/3,R=k+1,I=(U-2)/3,S=I-1,J[j++]=I,J[j++]=k,J[j++]=S,J[j++]=S,J[j++]=k,J[j++]=R,B+=3,U-=3;for(K=a.geodeticSurfaceNormal(r.Cartesian3.fromArray($,b,N),N),Q=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,b,M),M),Y=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,Y),Y),Z+=3,C=0;C<u.length;C++){let t;g=u[C];const i=g.leftPositions,l=g.rightPositions;let d,c,m=F,f=x,h=L;if(Y=r.Cartesian3.fromArray(p,Z,Y),s.defined(i)){for(O(D,Y,W,void 0,U,e),U-=3,d=R,c=S,t=0;t<i.length/3;t++)m=r.Cartesian3.fromArray(i,3*t,m),J[j++]=d,J[j++]=c-t-1,J[j++]=c-t,n.CorridorGeometryLibrary.addAttribute(P,m,void 0,U),f=r.Cartesian3.fromArray(P,3*(c-t-1),f),h=r.Cartesian3.fromArray(P,3*d,h),W=r.Cartesian3.normalize(r.Cartesian3.subtract(f,h,W),W),O(D,Y,W,void 0,U,e),U-=3;m=r.Cartesian3.fromArray(P,3*d,m),f=r.Cartesian3.subtract(r.Cartesian3.fromArray(P,3*c,f),m,f),h=r.Cartesian3.subtract(r.Cartesian3.fromArray(P,3*(c-t),h),m,h),W=r.Cartesian3.normalize(r.Cartesian3.add(f,h,W),W),O(D,Y,W,B,void 0,e),B+=3}else{for(O(D,Y,W,B,void 0,e),B+=3,d=S,c=R,t=0;t<l.length/3;t++)m=r.Cartesian3.fromArray(l,3*t,m),J[j++]=d,J[j++]=c+t,J[j++]=c+t+1,n.CorridorGeometryLibrary.addAttribute(P,m,B),f=r.Cartesian3.fromArray(P,3*d,f),h=r.Cartesian3.fromArray(P,3*(c+t),h),W=r.Cartesian3.normalize(r.Cartesian3.subtract(f,h,W),W),O(D,Y,W,B,void 0,e),B+=3;m=r.Cartesian3.fromArray(P,3*d,m),f=r.Cartesian3.subtract(r.Cartesian3.fromArray(P,3*(c+t),f),m,f),h=r.Cartesian3.subtract(r.Cartesian3.fromArray(P,3*c,h),m,h),W=r.Cartesian3.normalize(r.Cartesian3.negate(r.Cartesian3.add(h,f,W),W),W),O(D,Y,W,void 0,U,e),U-=3}for($=o[X++],tt=o[X++],$.splice(0,3),tt.splice(tt.length-3,3),P.set($,B),P.set(tt,U-tt.length+1),b=tt.length-3,Z+=3,W=r.Cartesian3.fromArray(y,Z,W),t=0;t<tt.length;t+=3)K=a.geodeticSurfaceNormal(r.Cartesian3.fromArray($,t,N),N),Q=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,b-t,M),M),Y=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,Y),Y),O(D,Y,W,B,U,e),R=B/3,k=R-1,S=(U-2)/3,I=S+1,J[j++]=I,J[j++]=k,J[j++]=S,J[j++]=S,J[j++]=k,J[j++]=R,B+=3,U-=3;B-=3,U+=3}if(Y=r.Cartesian3.fromArray(p,p.length-3,Y),O(D,Y,W,B,U,e),v){B+=3,U-=3,z=x,H=L;const t=f[1];for(C=0;C<q;C++)z=r.Cartesian3.fromArray(t,3*(T-C-1),z),H=r.Cartesian3.fromArray(t,3*C,H),n.CorridorGeometryLibrary.addAttribute(P,z,void 0,U),n.CorridorGeometryLibrary.addAttribute(P,H,B),O(D,Y,W,B,U,e),R=B/3,k=R-1,S=(U-2)/3,I=S+1,J[j++]=I,J[j++]=k,J[j++]=S,J[j++]=S,J[j++]=k,J[j++]=R,B+=3,U-=3}if(h.position=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:P}),e.st){const t=new Float32Array(G/3*2);let e,r,a=0;if(v){A/=3,_/=3;const i=Math.PI/(T+1);let o;r=1/(A-T+1),e=1/(_-T+1);const n=T/2;for(C=n+1;C<T+1;C++)o=m.CesiumMath.PI_OVER_TWO+i*C,t[a++]=e*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(C=1;C<_-T+1;C++)t[a++]=C*e,t[a++]=0;for(C=T;C>n;C--)o=m.CesiumMath.PI_OVER_TWO-C*i,t[a++]=1-e*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(C=n;C>0;C--)o=m.CesiumMath.PI_OVER_TWO-i*C,t[a++]=1-r*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(C=A-T;C>0;C--)t[a++]=C*r,t[a++]=1;for(C=1;C<n+1;C++)o=m.CesiumMath.PI_OVER_TWO+i*C,t[a++]=r*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o))}else{for(A/=3,_/=3,r=1/(A-1),e=1/(_-1),C=0;C<_;C++)t[a++]=C*e,t[a++]=0;for(C=A;C>0;C--)t[a++]=(C-1)*r,t[a++]=1}h.st=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(h.normal=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D.normals})),e.tangent&&(h.tangent=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D.tangents})),e.bitangent&&(h.bitangent=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D.bitangents})),{attributes:h,indices:J}}function k(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let a=3;a<t.length;a+=3){const i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}const S=new r.Cartesian3,R=new r.Cartesian3,H=new r.Cartographic;function z(t,e,a,i,o,n){const s=r.Cartesian3.subtract(e,t,S);r.Cartesian3.normalize(s,s);const l=a.geodeticSurfaceNormal(t,R),d=r.Cartesian3.cross(s,l,S);r.Cartesian3.multiplyByScalar(d,i,d);let u=o.latitude,c=o.longitude,m=n.latitude,f=n.longitude;r.Cartesian3.add(t,d,R),a.cartesianToCartographic(R,H);let y=H.latitude,p=H.longitude;u=Math.min(u,y),c=Math.min(c,p),m=Math.max(m,y),f=Math.max(f,p),r.Cartesian3.subtract(t,d,R),a.cartesianToCartographic(R,H),y=H.latitude,p=H.longitude,u=Math.min(u,y),c=Math.min(c,p),m=Math.max(m,y),f=Math.max(f,p),o.latitude=u,o.longitude=c,n.latitude=m,n.longitude=f}const B=new r.Cartesian3,U=new r.Cartesian3,Y=new r.Cartographic,W=new r.Cartographic;function q(e,a,i,n,l){e=D(e,a);const d=t.arrayRemoveDuplicates(e,r.Cartesian3.equalsEpsilon),u=d.length;if(u<2||i<=0)return new y.Rectangle;const c=.5*i;let m,f;if(Y.latitude=Number.POSITIVE_INFINITY,Y.longitude=Number.POSITIVE_INFINITY,W.latitude=Number.NEGATIVE_INFINITY,W.longitude=Number.NEGATIVE_INFINITY,n===o.CornerType.ROUNDED){const t=d[0];r.Cartesian3.subtract(t,d[1],B),r.Cartesian3.normalize(B,B),r.Cartesian3.multiplyByScalar(B,c,B),r.Cartesian3.add(t,B,U),a.cartesianToCartographic(U,H),m=H.latitude,f=H.longitude,Y.latitude=Math.min(Y.latitude,m),Y.longitude=Math.min(Y.longitude,f),W.latitude=Math.max(W.latitude,m),W.longitude=Math.max(W.longitude,f)}for(let t=0;t<u-1;++t)z(d[t],d[t+1],a,c,Y,W);const p=d[u-1];r.Cartesian3.subtract(p,d[u-2],B),r.Cartesian3.normalize(B,B),r.Cartesian3.multiplyByScalar(B,c,B),r.Cartesian3.add(p,B,U),z(p,U,a,c,Y,W),n===o.CornerType.ROUNDED&&(a.cartesianToCartographic(U,H),m=H.latitude,f=H.longitude,Y.latitude=Math.min(Y.latitude,m),Y.longitude=Math.min(Y.longitude,f),W.latitude=Math.max(W.latitude,m),W.longitude=Math.max(W.longitude,f));const h=s.defined(l)?l:new y.Rectangle;return h.north=W.latitude,h.south=Y.latitude,h.east=W.longitude,h.west=Y.longitude,h}function J(t){const e=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).positions,i=t.width;a.Check.defined("options.positions",e),a.Check.defined("options.width",i);const n=s.defaultValue(t.height,0),l=s.defaultValue(t.extrudedHeight,n);this._positions=e,this._ellipsoid=r.Ellipsoid.clone(s.defaultValue(t.ellipsoid,r.Ellipsoid.WGS84)),this._vertexFormat=p.VertexFormat.clone(s.defaultValue(t.vertexFormat,p.VertexFormat.DEFAULT)),this._width=i,this._height=Math.max(n,l),this._extrudedHeight=Math.min(n,l),this._cornerType=s.defaultValue(t.cornerType,o.CornerType.ROUNDED),this._granularity=s.defaultValue(t.granularity,m.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=s.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*r.Cartesian3.packedLength+r.Ellipsoid.packedLength+p.VertexFormat.packedLength+7}J.pack=function(t,e,i){a.Check.defined("value",t),a.Check.defined("array",e),i=s.defaultValue(i,0);const o=t._positions,n=o.length;e[i++]=n;for(let t=0;t<n;++t,i+=r.Cartesian3.packedLength)r.Cartesian3.pack(o[t],e,i);return r.Ellipsoid.pack(t._ellipsoid,e,i),i+=r.Ellipsoid.packedLength,p.VertexFormat.pack(t._vertexFormat,e,i),i+=p.VertexFormat.packedLength,e[i++]=t._width,e[i++]=t._height,e[i++]=t._extrudedHeight,e[i++]=t._cornerType,e[i++]=t._granularity,e[i++]=t._shadowVolume?1:0,e[i]=s.defaultValue(t._offsetAttribute,-1),e};const j=r.Ellipsoid.clone(r.Ellipsoid.UNIT_SPHERE),K=new p.VertexFormat,Q={positions:void 0,ellipsoid:j,vertexFormat:K,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return J.unpack=function(t,e,i){a.Check.defined("array",t),e=s.defaultValue(e,0);const o=t[e++],n=new Array(o);for(let a=0;a<o;++a,e+=r.Cartesian3.packedLength)n[a]=r.Cartesian3.unpack(t,e);const l=r.Ellipsoid.unpack(t,e,j);e+=r.Ellipsoid.packedLength;const d=p.VertexFormat.unpack(t,e,K);e+=p.VertexFormat.packedLength;const u=t[e++],c=t[e++],m=t[e++],f=t[e++],y=t[e++],h=1===t[e++],g=t[e];return s.defined(i)?(i._positions=n,i._ellipsoid=r.Ellipsoid.clone(l,i._ellipsoid),i._vertexFormat=p.VertexFormat.clone(d,i._vertexFormat),i._width=u,i._height=c,i._extrudedHeight=m,i._cornerType=f,i._granularity=y,i._shadowVolume=h,i._offsetAttribute=-1===g?void 0:g,i):(Q.positions=n,Q.width=u,Q.height=c,Q.extrudedHeight=m,Q.cornerType=f,Q.granularity=y,Q.shadowVolume=h,Q.offsetAttribute=-1===g?void 0:g,new J(Q))},J.computeRectangle=function(t,e){const i=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).positions,n=t.width;return a.Check.defined("options.positions",i),a.Check.defined("options.width",n),q(i,s.defaultValue(t.ellipsoid,r.Ellipsoid.WGS84),n,s.defaultValue(t.cornerType,o.CornerType.ROUNDED),e)},J.createGeometry=function(a){let o=a._positions;const d=a._width,y=a._ellipsoid;o=D(o,y);const h=t.arrayRemoveDuplicates(o,r.Cartesian3.equalsEpsilon);if(h.length<2||d<=0)return;const g=a._height,C=a._extrudedHeight,b=!m.CesiumMath.equalsEpsilon(g,C,0,m.CesiumMath.EPSILON2),A=a._vertexFormat,_={ellipsoid:y,positions:h,width:d,cornerType:a._cornerType,granularity:a._granularity,saveAttributes:!0};let w;if(b)_.height=g,_.extrudedHeight=C,_.shadowVolume=a._shadowVolume,_.offsetAttribute=a._offsetAttribute,w=function(t,e){const a=new p.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),o=t.ellipsoid,d=I(n.CorridorGeometryLibrary.computePositions(t),a,o),m=t.height,y=t.extrudedHeight;let h=d.attributes;const g=d.indices;let C=h.position.values,b=C.length;const A=new Float64Array(6*b);let _=new Float64Array(b);_.set(C);let w,v=new Float64Array(4*b);C=f.PolygonPipeline.scaleToGeodeticHeight(C,m,o),v=k(C,0,v),_=f.PolygonPipeline.scaleToGeodeticHeight(_,y,o),v=k(_,2*b,v),A.set(C),A.set(_,b),A.set(v,2*b),h.position.values=A,h=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;const a=t.position.values;let i,o;(e.normal||e.bitangent)&&(i=t.normal.values,o=t.bitangent.values);const s=t.position.values.length/18,l=3*s,d=2*s,u=2*l;let c;if(e.normal||e.bitangent||e.tangent){const s=e.normal?new Float32Array(6*l):void 0,d=e.tangent?new Float32Array(6*l):void 0,m=e.bitangent?new Float32Array(6*l):void 0;let f=E,y=V,p=x,h=L,g=P,C=F,b=u;for(c=0;c<l;c+=3){const t=b+u;f=r.Cartesian3.fromArray(a,c,f),y=r.Cartesian3.fromArray(a,c+l,y),p=r.Cartesian3.fromArray(a,(c+3)%l,p),y=r.Cartesian3.subtract(y,f,y),p=r.Cartesian3.subtract(p,f,p),h=r.Cartesian3.normalize(r.Cartesian3.cross(y,p,h),h),e.normal&&(n.CorridorGeometryLibrary.addAttribute(s,h,t),n.CorridorGeometryLibrary.addAttribute(s,h,t+3),n.CorridorGeometryLibrary.addAttribute(s,h,b),n.CorridorGeometryLibrary.addAttribute(s,h,b+3)),(e.tangent||e.bitangent)&&(C=r.Cartesian3.fromArray(i,c,C),e.bitangent&&(n.CorridorGeometryLibrary.addAttribute(m,C,t),n.CorridorGeometryLibrary.addAttribute(m,C,t+3),n.CorridorGeometryLibrary.addAttribute(m,C,b),n.CorridorGeometryLibrary.addAttribute(m,C,b+3)),e.tangent&&(g=r.Cartesian3.normalize(r.Cartesian3.cross(C,h,g),g),n.CorridorGeometryLibrary.addAttribute(d,g,t),n.CorridorGeometryLibrary.addAttribute(d,g,t+3),n.CorridorGeometryLibrary.addAttribute(d,g,b),n.CorridorGeometryLibrary.addAttribute(d,g,b+3))),b+=6}if(e.normal){for(s.set(i),c=0;c<l;c+=3)s[c+l]=-i[c],s[c+l+1]=-i[c+1],s[c+l+2]=-i[c+2];t.normal.values=s}else t.normal=void 0;if(e.bitangent?(m.set(o),m.set(o,l),t.bitangent.values=m):t.bitangent=void 0,e.tangent){const e=t.tangent.values;d.set(e),d.set(e,l),t.tangent.values=d}}if(e.st){const e=t.st.values,r=new Float32Array(6*d);r.set(e),r.set(e,d);let a=2*d;for(let t=0;t<2;t++){for(r[a++]=e[0],r[a++]=e[1],c=2;c<d;c+=2){const t=e[c],i=e[c+1];r[a++]=t,r[a++]=i,r[a++]=t,r[a++]=i}r[a++]=e[0],r[a++]=e[1]}t.st.values=r}return t}(h,e);const T=b/3;if(t.shadowVolume){const t=h.normal.values;b=t.length;let r=new Float32Array(6*b);for(w=0;w<b;w++)t[w]=-t[w];r.set(t,b),r=k(t,4*b,r),h.extrudeDirection=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:r}),e.normal||(h.normal=void 0)}if(s.defined(t.offsetAttribute)){let e=new Uint8Array(6*T);if(t.offsetAttribute===u.GeometryOffsetAttribute.TOP)e=e.fill(1,0,T).fill(1,2*T,4*T);else{const r=t.offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1;e=e.fill(r)}h.applyOffset=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}const G=g.length,N=T+T,M=c.IndexDatatype.createTypedArray(A.length/3,2*G+3*N);M.set(g);let D,O,S,R,H=G;for(w=0;w<G;w+=3){const t=g[w],e=g[w+1],r=g[w+2];M[H++]=r+T,M[H++]=e+T,M[H++]=t+T}for(w=0;w<N;w+=2)D=w+N,O=D+N,S=D+1,R=O+1,M[H++]=D,M[H++]=O,M[H++]=S,M[H++]=S,M[H++]=O,M[H++]=R;return{attributes:h,indices:M}}(_,A);else if(w=I(n.CorridorGeometryLibrary.computePositions(_),A,y),w.attributes.position.values=f.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,g,y),s.defined(a._offsetAttribute)){const t=a._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,e=w.attributes.position.values.length,r=new Uint8Array(e/3).fill(t);w.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}const v=w.attributes,T=e.BoundingSphere.fromVertices(v.position.values,void 0,3);return A.position||(w.attributes.position.values=void 0),new l.Geometry({attributes:v,indices:w.indices,primitiveType:l.PrimitiveType.TRIANGLES,boundingSphere:T,offsetAttribute:a._offsetAttribute})},J.createShadowVolume=function(t,e,r){const a=t._granularity,i=t._ellipsoid,o=e(a,i),n=r(a,i);return new J({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:o,height:n,vertexFormat:p.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(J.prototype,{rectangle:{get:function(){return s.defined(this._rectangle)||(this._rectangle=q(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return s.defined(e)&&(t=J.unpack(t,e)),t._ellipsoid=r.Ellipsoid.clone(t._ellipsoid),J.createGeometry(t)}}));