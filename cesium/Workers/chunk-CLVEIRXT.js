/*! For license information please see chunk-CLVEIRXT.js.LICENSE.txt */
import{CylinderGeometryLibrary_default}from"./chunk-PB7BIXHI.js";import{GeometryOffsetAttribute_default}from"./chunk-W7F5VTH6.js";import{VertexFormat_default}from"./chunk-ZTYE74E2.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{BoundingSphere_default}from"./chunk-D4YHO4NZ.js";import{Cartesian2_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var radiusScratch=new Cartesian2_default,normalScratch=new Cartesian3_default,bitangentScratch=new Cartesian3_default,tangentScratch=new Cartesian3_default,positionScratch=new Cartesian3_default;function CylinderGeometry(t){const e=(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT)).length,r=t.topRadius,a=t.bottomRadius,o=defaultValue_default(t.vertexFormat,VertexFormat_default.DEFAULT),n=defaultValue_default(t.slices,128);if(!defined_default(e))throw new DeveloperError_default("options.length must be defined.");if(!defined_default(r))throw new DeveloperError_default("options.topRadius must be defined.");if(!defined_default(a))throw new DeveloperError_default("options.bottomRadius must be defined.");if(n<3)throw new DeveloperError_default("options.slices must be greater than or equal to 3.");if(defined_default(t.offsetAttribute)&&t.offsetAttribute===GeometryOffsetAttribute_default.TOP)throw new DeveloperError_default("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=e,this._topRadius=r,this._bottomRadius=a,this._vertexFormat=VertexFormat_default.clone(o),this._slices=n,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}CylinderGeometry.packedLength=VertexFormat_default.packedLength+5,CylinderGeometry.pack=function(t,e,r){if(!defined_default(t))throw new DeveloperError_default("value is required");if(!defined_default(e))throw new DeveloperError_default("array is required");return r=defaultValue_default(r,0),VertexFormat_default.pack(t._vertexFormat,e,r),r+=VertexFormat_default.packedLength,e[r++]=t._length,e[r++]=t._topRadius,e[r++]=t._bottomRadius,e[r++]=t._slices,e[r]=defaultValue_default(t._offsetAttribute,-1),e};var unitCylinderGeometry,scratchVertexFormat=new VertexFormat_default,scratchOptions={vertexFormat:scratchVertexFormat,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};CylinderGeometry.unpack=function(t,e,r){if(!defined_default(t))throw new DeveloperError_default("array is required");e=defaultValue_default(e,0);const a=VertexFormat_default.unpack(t,e,scratchVertexFormat);e+=VertexFormat_default.packedLength;const o=t[e++],n=t[e++],i=t[e++],u=t[e++],d=t[e];return defined_default(r)?(r._vertexFormat=VertexFormat_default.clone(a,r._vertexFormat),r._length=o,r._topRadius=n,r._bottomRadius=i,r._slices=u,r._offsetAttribute=-1===d?void 0:d,r):(scratchOptions.length=o,scratchOptions.topRadius=n,scratchOptions.bottomRadius=i,scratchOptions.slices=u,scratchOptions.offsetAttribute=-1===d?void 0:d,new CylinderGeometry(scratchOptions))},CylinderGeometry.createGeometry=function(t){let e=t._length;const r=t._topRadius,a=t._bottomRadius,o=t._vertexFormat,n=t._slices;if(e<=0||r<0||a<0||0===r&&0===a)return;const i=n+n,u=n+i,d=i+i,f=CylinderGeometryLibrary_default.computePositions(e,r,a,n,!0),l=o.st?new Float32Array(2*d):void 0,s=o.normal?new Float32Array(3*d):void 0,m=o.tangent?new Float32Array(3*d):void 0,_=o.bitangent?new Float32Array(3*d):void 0;let c;const p=o.normal||o.tangent||o.bitangent;if(p){const t=o.tangent||o.bitangent;let i=0,u=0,d=0;const f=Math.atan2(a-r,e),l=normalScratch;l.z=Math.sin(f);const y=Math.cos(f);let h=tangentScratch,b=bitangentScratch;for(c=0;c<n;c++){const e=c/n*Math_default.TWO_PI,r=y*Math.cos(e),a=y*Math.sin(e);p&&(l.x=r,l.y=a,t&&(h=Cartesian3_default.normalize(Cartesian3_default.cross(Cartesian3_default.UNIT_Z,l,h),h)),o.normal&&(s[i++]=l.x,s[i++]=l.y,s[i++]=l.z,s[i++]=l.x,s[i++]=l.y,s[i++]=l.z),o.tangent&&(m[u++]=h.x,m[u++]=h.y,m[u++]=h.z,m[u++]=h.x,m[u++]=h.y,m[u++]=h.z),o.bitangent&&(b=Cartesian3_default.normalize(Cartesian3_default.cross(l,h,b),b),_[d++]=b.x,_[d++]=b.y,_[d++]=b.z,_[d++]=b.x,_[d++]=b.y,_[d++]=b.z))}for(c=0;c<n;c++)o.normal&&(s[i++]=0,s[i++]=0,s[i++]=-1),o.tangent&&(m[u++]=1,m[u++]=0,m[u++]=0),o.bitangent&&(_[d++]=0,_[d++]=-1,_[d++]=0);for(c=0;c<n;c++)o.normal&&(s[i++]=0,s[i++]=0,s[i++]=1),o.tangent&&(m[u++]=1,m[u++]=0,m[u++]=0),o.bitangent&&(_[d++]=0,_[d++]=1,_[d++]=0)}const y=12*n-12,h=IndexDatatype_default.createTypedArray(d,y);let b=0,C=0;for(c=0;c<n-1;c++)h[b++]=C,h[b++]=C+2,h[b++]=C+3,h[b++]=C,h[b++]=C+3,h[b++]=C+1,C+=2;for(h[b++]=i-2,h[b++]=0,h[b++]=1,h[b++]=i-2,h[b++]=1,h[b++]=i-1,c=1;c<n-1;c++)h[b++]=i+c+1,h[b++]=i+c,h[b++]=i;for(c=1;c<n-1;c++)h[b++]=u,h[b++]=u+c,h[b++]=u+c+1;let A=0;if(o.st){const t=Math.max(r,a);for(c=0;c<d;c++){const e=Cartesian3_default.fromArray(f,3*c,positionScratch);l[A++]=(e.x+t)/(2*t),l[A++]=(e.y+t)/(2*t)}}const g=new GeometryAttributes_default;o.position&&(g.position=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:f})),o.normal&&(g.normal=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:s})),o.tangent&&(g.tangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:m})),o.bitangent&&(g.bitangent=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:3,values:_})),o.st&&(g.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:l})),radiusScratch.x=.5*e,radiusScratch.y=Math.max(a,r);const v=new BoundingSphere_default(Cartesian3_default.ZERO,Cartesian2_default.magnitude(radiusScratch));if(defined_default(t._offsetAttribute)){e=f.length;const r=t._offsetAttribute===GeometryOffsetAttribute_default.NONE?0:1,a=new Uint8Array(e/3).fill(r);g.applyOffset=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new Geometry_default({attributes:g,indices:h,primitiveType:PrimitiveType_default.TRIANGLES,boundingSphere:v,offsetAttribute:t._offsetAttribute})},CylinderGeometry.getUnitCylinder=function(){return defined_default(unitCylinderGeometry)||(unitCylinderGeometry=CylinderGeometry.createGeometry(new CylinderGeometry({topRadius:1,bottomRadius:1,length:1,vertexFormat:VertexFormat_default.POSITION_ONLY}))),unitCylinderGeometry};var CylinderGeometry_default=CylinderGeometry;export{CylinderGeometry_default};