/*! For license information please see chunk-VODWDCX6.js.LICENSE.txt */
import{ArcType_default}from"./chunk-235MRXLH.js";import{GeometryPipeline_default}from"./chunk-36ESDRIZ.js";import{PolygonPipeline_default,WindingOrder_default}from"./chunk-ZVUAJKAL.js";import{arrayRemoveDuplicates_default}from"./chunk-DTNN3ODA.js";import{EllipsoidRhumbLine_default}from"./chunk-6PWSSCRA.js";import{IntersectionTests_default}from"./chunk-HEROVJML.js";import{Plane_default}from"./chunk-4EYB62WJ.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{GeometryAttributes_default}from"./chunk-SJDXMQSP.js";import{GeometryAttribute_default,Geometry_default,PrimitiveType_default}from"./chunk-OTBRPBCC.js";import{Quaternion_default}from"./chunk-D4YHO4NZ.js";import{Cartesian2_default}from"./chunk-RSWBNJPT.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import{Cartesian3_default,Cartographic_default,Ellipsoid_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{Math_default}from"./chunk-IZED7ODV.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{defined_default}from"./chunk-YS4KPNLC.js";function PolygonHierarchy(e,t){this.positions=defined_default(e)?e:[],this.holes=defined_default(t)?t:[]}var PolygonHierarchy_default=PolygonHierarchy;function Queue(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(Queue.prototype,{length:{get:function(){return this._length}}}),Queue.prototype.enqueue=function(e){this._array.push(e),this._length++},Queue.prototype.dequeue=function(){if(0===this._length)return;const e=this._array;let t=this._offset;const n=e[t];return e[t]=void 0,t++,t>10&&2*t>e.length&&(this._array=e.slice(t),t=0),this._offset=t,this._length--,n},Queue.prototype.peek=function(){if(0!==this._length)return this._array[this._offset]},Queue.prototype.contains=function(e){return-1!==this._array.indexOf(e)},Queue.prototype.clear=function(){this._array.length=this._offset=this._length=0},Queue.prototype.sort=function(e){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(e)};var Queue_default=Queue,PolygonGeometryLibrary={computeHierarchyPackedLength:function(e,t){let n=0;const a=[e];for(;a.length>0;){const e=a.pop();if(!defined_default(e))continue;n+=2;const i=e.positions,o=e.holes;if(defined_default(i)&&i.length>0&&(n+=i.length*t.packedLength),defined_default(o)){const e=o.length;for(let t=0;t<e;++t)a.push(o[t])}}return n},packPolygonHierarchy:function(e,t,n,a){const i=[e];for(;i.length>0;){const e=i.pop();if(!defined_default(e))continue;const o=e.positions,r=e.holes;if(t[n++]=defined_default(o)?o.length:0,t[n++]=defined_default(r)?r.length:0,defined_default(o)){const e=o.length;for(let i=0;i<e;++i,n+=a.packedLength)a.pack(o[i],t,n)}if(defined_default(r)){const e=r.length;for(let t=0;t<e;++t)i.push(r[t])}}return n},unpackPolygonHierarchy:function(e,t,n){const a=e[t++],i=e[t++],o=new Array(a),r=i>0?new Array(i):void 0;for(let i=0;i<a;++i,t+=n.packedLength)o[i]=n.unpack(e,t);for(let a=0;a<i;++a)r[a]=PolygonGeometryLibrary.unpackPolygonHierarchy(e,t,n),t=r[a].startingIndex,delete r[a].startingIndex;return{positions:o,holes:r,startingIndex:t}}},distance2DScratch=new Cartesian2_default;function getPointAtDistance2D(e,t,n,a){return Cartesian2_default.subtract(t,e,distance2DScratch),Cartesian2_default.multiplyByScalar(distance2DScratch,n/a,distance2DScratch),Cartesian2_default.add(e,distance2DScratch,distance2DScratch),[distance2DScratch.x,distance2DScratch.y]}var distanceScratch=new Cartesian3_default;function getPointAtDistance(e,t,n,a){return Cartesian3_default.subtract(t,e,distanceScratch),Cartesian3_default.multiplyByScalar(distanceScratch,n/a,distanceScratch),Cartesian3_default.add(e,distanceScratch,distanceScratch),[distanceScratch.x,distanceScratch.y,distanceScratch.z]}PolygonGeometryLibrary.subdivideLineCount=function(e,t,n){const a=Cartesian3_default.distance(e,t)/n,i=Math.max(0,Math.ceil(Math_default.log2(a)));return Math.pow(2,i)};var scratchCartographic0=new Cartographic_default,scratchCartographic1=new Cartographic_default,scratchCartographic2=new Cartographic_default,scratchCartesian0=new Cartesian3_default,scratchRhumbLine=new EllipsoidRhumbLine_default;PolygonGeometryLibrary.subdivideRhumbLineCount=function(e,t,n,a){const i=e.cartesianToCartographic(t,scratchCartographic0),o=e.cartesianToCartographic(n,scratchCartographic1),r=new EllipsoidRhumbLine_default(i,o,e).surfaceDistance/a,u=Math.max(0,Math.ceil(Math_default.log2(r)));return Math.pow(2,u)},PolygonGeometryLibrary.subdivideTexcoordLine=function(e,t,n,a,i,o){const r=PolygonGeometryLibrary.subdivideLineCount(n,a,i),u=Cartesian2_default.distance(e,t),c=u/r,l=o;l.length=2*r;let s=0;for(let n=0;n<r;n++){const a=getPointAtDistance2D(e,t,n*c,u);l[s++]=a[0],l[s++]=a[1]}return l},PolygonGeometryLibrary.subdivideLine=function(e,t,n,a){const i=PolygonGeometryLibrary.subdivideLineCount(e,t,n),o=Cartesian3_default.distance(e,t),r=o/i;defined_default(a)||(a=[]);const u=a;u.length=3*i;let c=0;for(let n=0;n<i;n++){const a=getPointAtDistance(e,t,n*r,o);u[c++]=a[0],u[c++]=a[1],u[c++]=a[2]}return u},PolygonGeometryLibrary.subdivideTexcoordRhumbLine=function(e,t,n,a,i,o,r){const u=n.cartesianToCartographic(a,scratchCartographic0),c=n.cartesianToCartographic(i,scratchCartographic1);scratchRhumbLine.setEndPoints(u,c);const l=scratchRhumbLine.surfaceDistance/o,s=Math.max(0,Math.ceil(Math_default.log2(l))),d=Math.pow(2,s),f=Cartesian2_default.distance(e,t),h=f/d,p=r;p.length=2*d;let y=0;for(let n=0;n<d;n++){const a=getPointAtDistance2D(e,t,n*h,f);p[y++]=a[0],p[y++]=a[1]}return p},PolygonGeometryLibrary.subdivideRhumbLine=function(e,t,n,a,i){const o=e.cartesianToCartographic(t,scratchCartographic0),r=e.cartesianToCartographic(n,scratchCartographic1),u=new EllipsoidRhumbLine_default(o,r,e),c=u.surfaceDistance/a,l=Math.max(0,Math.ceil(Math_default.log2(c))),s=Math.pow(2,l),d=u.surfaceDistance/s;defined_default(i)||(i=[]);const f=i;f.length=3*s;let h=0;for(let t=0;t<s;t++){const n=u.interpolateUsingSurfaceDistance(t*d,scratchCartographic2),a=e.cartographicToCartesian(n,scratchCartesian0);f[h++]=a.x,f[h++]=a.y,f[h++]=a.z}return f};var scaleToGeodeticHeightN1=new Cartesian3_default,scaleToGeodeticHeightN2=new Cartesian3_default,scaleToGeodeticHeightP1=new Cartesian3_default,scaleToGeodeticHeightP2=new Cartesian3_default;PolygonGeometryLibrary.scaleToGeodeticHeightExtruded=function(e,t,n,a,i){a=defaultValue_default(a,Ellipsoid_default.WGS84);const o=scaleToGeodeticHeightN1;let r=scaleToGeodeticHeightN2;const u=scaleToGeodeticHeightP1;let c=scaleToGeodeticHeightP2;if(defined_default(e)&&defined_default(e.attributes)&&defined_default(e.attributes.position)){const l=e.attributes.position.values,s=l.length/2;for(let e=0;e<s;e+=3)Cartesian3_default.fromArray(l,e,u),a.geodeticSurfaceNormal(u,o),c=a.scaleToGeodeticSurface(u,c),r=Cartesian3_default.multiplyByScalar(o,n,r),r=Cartesian3_default.add(c,r,r),l[e+s]=r.x,l[e+1+s]=r.y,l[e+2+s]=r.z,i&&(c=Cartesian3_default.clone(u,c)),r=Cartesian3_default.multiplyByScalar(o,t,r),r=Cartesian3_default.add(c,r,r),l[e]=r.x,l[e+1]=r.y,l[e+2]=r.z}return e},PolygonGeometryLibrary.polygonOutlinesFromHierarchy=function(e,t,n){const a=[],i=new Queue_default;let o,r,u;for(i.enqueue(e);0!==i.length;){const e=i.dequeue();let c=e.positions;if(t)for(u=c.length,o=0;o<u;o++)n.scaleToGeodeticSurface(c[o],c[o]);if(c=arrayRemoveDuplicates_default(c,Cartesian3_default.equalsEpsilon,!0),c.length<3)continue;const l=e.holes?e.holes.length:0;for(o=0;o<l;o++){const c=e.holes[o];let l=c.positions;if(t)for(u=l.length,r=0;r<u;++r)n.scaleToGeodeticSurface(l[r],l[r]);if(l=arrayRemoveDuplicates_default(l,Cartesian3_default.equalsEpsilon,!0),l.length<3)continue;a.push(l);let s=0;for(defined_default(c.holes)&&(s=c.holes.length),r=0;r<s;r++)i.enqueue(c.holes[r])}a.push(c)}return a};var scratchRhumbIntersection=new Cartographic_default;function computeEquatorIntersectionRhumb(e,t,n){const a=n.cartesianToCartographic(e,scratchCartographic0),i=n.cartesianToCartographic(t,scratchCartographic1);if(Math.sign(a.latitude)===Math.sign(i.latitude))return;scratchRhumbLine.setEndPoints(a,i);const o=scratchRhumbLine.findIntersectionWithLatitude(0,scratchRhumbIntersection);if(!defined_default(o))return;let r=Math.min(a.longitude,i.longitude),u=Math.max(a.longitude,i.longitude);if(Math.abs(u-r)>Math_default.PI){const e=r;r=u,u=e}return o.longitude<r||o.longitude>u?void 0:n.cartographicToCartesian(o)}function computeEquatorIntersection(e,t,n,a){if(a===ArcType_default.RHUMB)return computeEquatorIntersectionRhumb(e,t,n);const i=IntersectionTests_default.lineSegmentPlane(e,t,Plane_default.ORIGIN_XY_PLANE);return defined_default(i)?n.scaleToGeodeticSurface(i,i):void 0}var scratchCartographic=new Cartographic_default;function computeEdgesOnPlane(e,t,n){const a=[];let i,o,r,u,c,l=0;for(;l<e.length;){i=e[l],o=e[(l+1)%e.length],r=Math_default.sign(i.z),u=Math_default.sign(o.z);const s=e=>t.cartesianToCartographic(e,scratchCartographic).longitude;if(0===r)a.push({position:l,type:r,visited:!1,next:u,theta:s(i)});else if(0!==u){if(c=computeEquatorIntersection(i,o,t,n),++l,!defined_default(c))continue;e.splice(l,0,c),a.push({position:l,type:r,visited:!1,next:u,theta:s(c)})}++l}return a}function wirePolygon(e,t,n,a,i,o,r){const u=[];let c=o;const l=e=>t=>t.position===e,s=[];do{const e=n[c];u.push(e);const t=a.findIndex(l(c)),i=a[t];if(!defined_default(i)){++c;continue}const{visited:d,type:f,next:h}=i;if(i.visited=!0,0===f){if(0===h){const e=a[t-(r?1:-1)];if(e?.position!==c+1){++c;continue}e.visited=!0}if(!d&&r&&h>0||o===c&&!r&&h<0){++c;continue}}if(!(r?f>=0:f<=0)){++c;continue}d||s.push(c);const p=a[t+(r?1:-1)];defined_default(p)?c=p.position:++c}while(c<n.length&&c>=0&&c!==o&&u.length<n.length);e.splice(t,i,u);for(const i of s)t=wirePolygon(e,++t,n,a,0,i,!r);return t}PolygonGeometryLibrary.splitPolygonsOnEquator=function(e,t,n,a){defined_default(a)||(a=[]),a.splice(0,0,...e),a.length=e.length;let i=0;for(;i<a.length;){const e=a[i],o=e.slice();if(e.length<3){a[i]=o,++i;continue}const r=computeEdgesOnPlane(o,t,n);o.length===e.length||r.length<=1?(a[i]=o,++i):(r.sort(((e,t)=>e.theta-t.theta)),i=wirePolygon(a,i,o,r,1,0,o[0].z>=0))}return a},PolygonGeometryLibrary.polygonsFromHierarchy=function(e,t,n,a,i,o){const r=[],u=[],c=new Queue_default;c.enqueue(e);let l=defined_default(o);for(;0!==c.length;){const e=c.dequeue();let s=e.positions;const d=e.holes;let f,h;if(a)for(h=s.length,f=0;f<h;f++)i.scaleToGeodeticSurface(s[f],s[f]);if(t||(s=arrayRemoveDuplicates_default(s,Cartesian3_default.equalsEpsilon,!0)),s.length<3)continue;let p=n(s);if(!defined_default(p))continue;const y=[];let g=PolygonPipeline_default.computeWindingOrder2D(p);if(g===WindingOrder_default.CLOCKWISE&&(p.reverse(),s=s.slice().reverse()),l){l=!1;let e=[s];if(e=o(e,e),e.length>1){for(const t of e)c.enqueue(new PolygonHierarchy_default(t,d));continue}}let _=s.slice();const m=defined_default(d)?d.length:0,C=[];let b;for(f=0;f<m;f++){const e=d[f];let o=e.positions;if(a)for(h=o.length,b=0;b<h;++b)i.scaleToGeodeticSurface(o[b],o[b]);if(t||(o=arrayRemoveDuplicates_default(o,Cartesian3_default.equalsEpsilon,!0)),o.length<3)continue;const r=n(o);if(!defined_default(r))continue;g=PolygonPipeline_default.computeWindingOrder2D(r),g===WindingOrder_default.CLOCKWISE&&(r.reverse(),o=o.slice().reverse()),C.push(o),y.push(_.length),_=_.concat(o),p=p.concat(r);let u=0;for(defined_default(e.holes)&&(u=e.holes.length),b=0;b<u;b++)c.enqueue(e.holes[b])}r.push({outerRing:s,holes:C}),u.push({positions:_,positions2D:p,holes:y})}return{hierarchy:r,polygons:u}};var computeBoundingRectangleCartesian2=new Cartesian2_default,computeBoundingRectangleCartesian3=new Cartesian3_default,computeBoundingRectangleQuaternion=new Quaternion_default,computeBoundingRectangleMatrix3=new Matrix3_default;PolygonGeometryLibrary.computeBoundingRectangle=function(e,t,n,a,i){const o=Quaternion_default.fromAxisAngle(e,a,computeBoundingRectangleQuaternion),r=Matrix3_default.fromQuaternion(o,computeBoundingRectangleMatrix3);let u=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,l=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY;const d=n.length;for(let e=0;e<d;++e){const a=Cartesian3_default.clone(n[e],computeBoundingRectangleCartesian3);Matrix3_default.multiplyByVector(r,a,a);const i=t(a,computeBoundingRectangleCartesian2);defined_default(i)&&(u=Math.min(u,i.x),c=Math.max(c,i.x),l=Math.min(l,i.y),s=Math.max(s,i.y))}return i.x=u,i.y=l,i.width=c-u,i.height=s-l,i},PolygonGeometryLibrary.createGeometryFromPositions=function(e,t,n,a,i,o,r){let u=PolygonPipeline_default.triangulate(t.positions2D,t.holes);u.length<3&&(u=[0,1,2]);const c=t.positions,l=defined_default(n),s=l?n.positions:void 0;if(i){const e=c.length,t=new Array(3*e);let n=0;for(let a=0;a<e;a++){const e=c[a];t[n++]=e.x,t[n++]=e.y,t[n++]=e.z}const a={attributes:{position:new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:t})},indices:u,primitiveType:PrimitiveType_default.TRIANGLES};l&&(a.attributes.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:Cartesian2_default.packArray(s)}));const i=new Geometry_default(a);return o.normal?GeometryPipeline_default.computeNormal(i):i}return r===ArcType_default.GEODESIC?PolygonPipeline_default.computeSubdivision(e,c,u,s,a):r===ArcType_default.RHUMB?PolygonPipeline_default.computeRhumbLineSubdivision(e,c,u,s,a):void 0};var computeWallTexcoordsSubdivided=[],computeWallIndicesSubdivided=[],p1Scratch=new Cartesian3_default,p2Scratch=new Cartesian3_default;PolygonGeometryLibrary.computeWallGeometry=function(e,t,n,a,i,o){let r,u,c,l,s,d,f,h,p,y=e.length,g=0,_=0;const m=defined_default(t),C=m?t.positions:void 0;if(i)for(u=3*y*2,r=new Array(2*u),m&&(p=2*y*2,h=new Array(2*p)),c=0;c<y;c++)l=e[c],s=e[(c+1)%y],r[g]=r[g+u]=l.x,++g,r[g]=r[g+u]=l.y,++g,r[g]=r[g+u]=l.z,++g,r[g]=r[g+u]=s.x,++g,r[g]=r[g+u]=s.y,++g,r[g]=r[g+u]=s.z,++g,m&&(d=C[c],f=C[(c+1)%y],h[_]=h[_+p]=d.x,++_,h[_]=h[_+p]=d.y,++_,h[_]=h[_+p]=f.x,++_,h[_]=h[_+p]=f.y,++_);else{const t=Math_default.chordLength(a,n.maximumRadius);let i=0;if(o===ArcType_default.GEODESIC)for(c=0;c<y;c++)i+=PolygonGeometryLibrary.subdivideLineCount(e[c],e[(c+1)%y],t);else if(o===ArcType_default.RHUMB)for(c=0;c<y;c++)i+=PolygonGeometryLibrary.subdivideRhumbLineCount(n,e[c],e[(c+1)%y],t);for(u=3*(i+y),r=new Array(2*u),m&&(p=2*(i+y),h=new Array(2*p)),c=0;c<y;c++){let a,i;l=e[c],s=e[(c+1)%y],m&&(d=C[c],f=C[(c+1)%y]),o===ArcType_default.GEODESIC?(a=PolygonGeometryLibrary.subdivideLine(l,s,t,computeWallIndicesSubdivided),m&&(i=PolygonGeometryLibrary.subdivideTexcoordLine(d,f,l,s,t,computeWallTexcoordsSubdivided))):o===ArcType_default.RHUMB&&(a=PolygonGeometryLibrary.subdivideRhumbLine(n,l,s,t,computeWallIndicesSubdivided),m&&(i=PolygonGeometryLibrary.subdivideTexcoordRhumbLine(d,f,n,l,s,t,computeWallTexcoordsSubdivided)));const b=a.length;for(let e=0;e<b;++e,++g)r[g]=a[e],r[g+u]=a[e];if(r[g]=s.x,r[g+u]=s.x,++g,r[g]=s.y,r[g+u]=s.y,++g,r[g]=s.z,r[g+u]=s.z,++g,m){const e=i.length;for(let t=0;t<e;++t,++_)h[_]=i[t],h[_+p]=i[t];h[_]=f.x,h[_+p]=f.x,++_,h[_]=f.y,h[_+p]=f.y,++_}}}y=r.length;const b=IndexDatatype_default.createTypedArray(y/3,y-6*e.length);let P=0;for(y/=6,c=0;c<y;c++){const e=c,t=e+1,n=e+y,a=n+1;l=Cartesian3_default.fromArray(r,3*e,p1Scratch),s=Cartesian3_default.fromArray(r,3*t,p2Scratch),Cartesian3_default.equalsEpsilon(l,s,Math_default.EPSILON10,Math_default.EPSILON10)||(b[P++]=e,b[P++]=n,b[P++]=t,b[P++]=t,b[P++]=n,b[P++]=a)}const L={attributes:new GeometryAttributes_default({position:new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.DOUBLE,componentsPerAttribute:3,values:r})}),indices:b,primitiveType:PrimitiveType_default.TRIANGLES};return m&&(L.attributes.st=new GeometryAttribute_default({componentDatatype:ComponentDatatype_default.FLOAT,componentsPerAttribute:2,values:h})),new Geometry_default(L)};var PolygonGeometryLibrary_default=PolygonGeometryLibrary;export{PolygonGeometryLibrary_default};