/*! For license information please see decodeDraco.js.LICENSE.txt */
import{require_draco_decoder_nodejs}from"./chunk-5NZTU5YL.js";import{createTaskProcessorWorker_default}from"./chunk-AI3KSNM6.js";import{IndexDatatype_default}from"./chunk-J3U6Z5YQ.js";import{ComponentDatatype_default}from"./chunk-Z6LPXA7S.js";import"./chunk-IZED7ODV.js";import"./chunk-VNRUVNIK.js";import{RuntimeError_default}from"./chunk-66CXKODF.js";import"./chunk-C53JYYKX.js";import"./chunk-7FEGZO3D.js";import{__toESM,defined_default}from"./chunk-YS4KPNLC.js";var draco,import_draco_decoder_nodejs=__toESM(require_draco_decoder_nodejs(),1);function decodeIndexArray(e,t){const r=e.num_points(),o=e.num_faces(),n=new draco.DracoInt32Array,a=3*o,d=IndexDatatype_default.createTypedArray(r,a);let c=0;for(let r=0;r<o;++r)t.GetFaceFromMesh(e,r,n),d[c+0]=n.GetValue(0),d[c+1]=n.GetValue(1),d[c+2]=n.GetValue(2),c+=3;return draco.destroy(n),{typedArray:d,numberOfIndices:a}}function decodeQuantizedDracoTypedArray(e,t,r,o,n){let a,d;o.quantizationBits<=8?(d=new draco.DracoUInt8Array,a=new Uint8Array(n),t.GetAttributeUInt8ForAllPoints(e,r,d)):o.quantizationBits<=16?(d=new draco.DracoUInt16Array,a=new Uint16Array(n),t.GetAttributeUInt16ForAllPoints(e,r,d)):(d=new draco.DracoFloat32Array,a=new Float32Array(n),t.GetAttributeFloatForAllPoints(e,r,d));for(let e=0;e<n;++e)a[e]=d.GetValue(e);return draco.destroy(d),a}function decodeDracoTypedArray(e,t,r,o){let n,a;switch(r.data_type()){case 1:case 11:a=new draco.DracoInt8Array,n=new Int8Array(o),t.GetAttributeInt8ForAllPoints(e,r,a);break;case 2:a=new draco.DracoUInt8Array,n=new Uint8Array(o),t.GetAttributeUInt8ForAllPoints(e,r,a);break;case 3:a=new draco.DracoInt16Array,n=new Int16Array(o),t.GetAttributeInt16ForAllPoints(e,r,a);break;case 4:a=new draco.DracoUInt16Array,n=new Uint16Array(o),t.GetAttributeUInt16ForAllPoints(e,r,a);break;case 5:case 7:a=new draco.DracoInt32Array,n=new Int32Array(o),t.GetAttributeInt32ForAllPoints(e,r,a);break;case 6:case 8:a=new draco.DracoUInt32Array,n=new Uint32Array(o),t.GetAttributeUInt32ForAllPoints(e,r,a);break;case 9:case 10:a=new draco.DracoFloat32Array,n=new Float32Array(o),t.GetAttributeFloatForAllPoints(e,r,a)}for(let e=0;e<o;++e)n[e]=a.GetValue(e);return draco.destroy(a),n}function decodeAttribute(e,t,r){const o=e.num_points(),n=r.num_components();let a,d=new draco.AttributeQuantizationTransform;if(d.InitFromAttribute(r)){const e=new Array(n);for(let t=0;t<n;++t)e[t]=d.min_value(t);a={quantizationBits:d.quantization_bits(),minValues:e,range:d.range(),octEncoded:!1}}draco.destroy(d),d=new draco.AttributeOctahedronTransform,d.InitFromAttribute(r)&&(a={quantizationBits:d.quantization_bits(),octEncoded:!0}),draco.destroy(d);const c=o*n;let i;i=defined_default(a)?decodeQuantizedDracoTypedArray(e,t,r,a,c):decodeDracoTypedArray(e,t,r,c);const u=ComponentDatatype_default.fromTypedArray(i);return{array:i,data:{componentsPerAttribute:n,componentDatatype:u,byteOffset:r.byte_offset(),byteStride:ComponentDatatype_default.getSizeInBytes(u)*n,normalized:r.normalized(),quantization:a}}}function decodePointCloud(e){const t=new draco.Decoder;e.dequantizeInShader&&(t.SkipAttributeTransform(draco.POSITION),t.SkipAttributeTransform(draco.NORMAL));const r=new draco.DecoderBuffer;if(r.Init(e.buffer,e.buffer.length),t.GetEncodedGeometryType(r)!==draco.POINT_CLOUD)throw new RuntimeError_default("Draco geometry type must be POINT_CLOUD.");const o=new draco.PointCloud,n=t.DecodeBufferToPointCloud(r,o);if(!n.ok()||0===o.ptr)throw new RuntimeError_default(`Error decoding draco point cloud: ${n.error_msg()}`);draco.destroy(r);const a={},d=e.properties;for(const e in d)if(d.hasOwnProperty(e)){let r;if("POSITION"===e||"NORMAL"===e){const n=t.GetAttributeId(o,draco[e]);r=t.GetAttribute(o,n)}else{const n=d[e];r=t.GetAttributeByUniqueId(o,n)}a[e]=decodeAttribute(o,t,r)}return draco.destroy(o),draco.destroy(t),a}function decodePrimitive(e){const t=new draco.Decoder,r=["POSITION","NORMAL","COLOR","TEX_COORD"];if(e.dequantizeInShader)for(let e=0;e<r.length;++e)t.SkipAttributeTransform(draco[r[e]]);const o=e.bufferView,n=new draco.DecoderBuffer;if(n.Init(e.array,o.byteLength),t.GetEncodedGeometryType(n)!==draco.TRIANGULAR_MESH)throw new RuntimeError_default("Unsupported draco mesh geometry type.");const a=new draco.Mesh,d=t.DecodeBufferToMesh(n,a);if(!d.ok()||0===a.ptr)throw new RuntimeError_default(`Error decoding draco mesh geometry: ${d.error_msg()}`);draco.destroy(n);const c={},i=e.compressedAttributes;for(const e in i)if(i.hasOwnProperty(e)){const r=i[e],o=t.GetAttributeByUniqueId(a,r);c[e]=decodeAttribute(a,t,o)}const u={indexArray:decodeIndexArray(a,t),attributeData:c};return draco.destroy(a),draco.destroy(t),u}async function decode(e,t){return defined_default(e.bufferView)?decodePrimitive(e):decodePointCloud(e)}async function initWorker(e,t){const r=e.webAssemblyConfig;return draco=defined_default(r)&&defined_default(r.wasmBinaryFile)?await(0,import_draco_decoder_nodejs.default)(r):await(0,import_draco_decoder_nodejs.default)(),!0}async function decodeDraco(e,t){const r=e.webAssemblyConfig;return defined_default(r)?initWorker(e,t):decode(e,t)}var decodeDraco_default=createTaskProcessorWorker_default(decodeDraco);export{decodeDraco_default as default};