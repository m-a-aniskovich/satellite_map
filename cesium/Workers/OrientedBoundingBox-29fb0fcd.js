define(["exports","./Transforms-e2d4a55a","./Matrix2-e1298525","./Matrix3-41c58dde","./Check-6ede7e26","./defaultValue-fe22d8c0","./EllipsoidTangentPlane-546c0d5e","./Math-0a2ac845","./Plane-4c3d403b"],(function(a,e,t,n,r,i,s,o,c){"use strict";function C(a,e){this.center=n.Cartesian3.clone(i.defaultValue(a,n.Cartesian3.ZERO)),this.halfAxes=n.Matrix3.clone(i.defaultValue(e,n.Matrix3.ZERO))}C.packedLength=n.Cartesian3.packedLength+n.Matrix3.packedLength,C.pack=function(a,e,t){return r.Check.typeOf.object("value",a),r.Check.defined("array",e),t=i.defaultValue(t,0),n.Cartesian3.pack(a.center,e,t),n.Matrix3.pack(a.halfAxes,e,t+n.Cartesian3.packedLength),e},C.unpack=function(a,e,t){return r.Check.defined("array",a),e=i.defaultValue(e,0),i.defined(t)||(t=new C),n.Cartesian3.unpack(a,e,t.center),n.Matrix3.unpack(a,e+n.Cartesian3.packedLength,t.halfAxes),t};const d=new n.Cartesian3,l=new n.Cartesian3,u=new n.Cartesian3,h=new n.Cartesian3,f=new n.Cartesian3,m=new n.Cartesian3,x=new n.Matrix3,p={unitary:new n.Matrix3,diagonal:new n.Matrix3};C.fromPoints=function(a,e){if(i.defined(e)||(e=new C),!i.defined(a)||0===a.length)return e.halfAxes=n.Matrix3.ZERO,e.center=n.Cartesian3.ZERO,e;let t;const r=a.length,s=n.Cartesian3.clone(a[0],d);for(t=1;t<r;t++)n.Cartesian3.add(s,a[t],s);const o=1/r;n.Cartesian3.multiplyByScalar(s,o,s);let c,M=0,w=0,g=0,b=0,y=0,O=0;for(t=0;t<r;t++)c=n.Cartesian3.subtract(a[t],s,l),M+=c.x*c.x,w+=c.x*c.y,g+=c.x*c.z,b+=c.y*c.y,y+=c.y*c.z,O+=c.z*c.z;M*=o,w*=o,g*=o,b*=o,y*=o,O*=o;const E=x;E[0]=M,E[1]=w,E[2]=g,E[3]=w,E[4]=b,E[5]=y,E[6]=g,E[7]=y,E[8]=O;const N=n.Matrix3.computeEigenDecomposition(E,p),T=n.Matrix3.clone(N.unitary,e.halfAxes);let P=n.Matrix3.getColumn(T,0,h),A=n.Matrix3.getColumn(T,1,f),I=n.Matrix3.getColumn(T,2,m),R=-Number.MAX_VALUE,S=-Number.MAX_VALUE,U=-Number.MAX_VALUE,L=Number.MAX_VALUE,D=Number.MAX_VALUE,q=Number.MAX_VALUE;for(t=0;t<r;t++)c=a[t],R=Math.max(n.Cartesian3.dot(P,c),R),S=Math.max(n.Cartesian3.dot(A,c),S),U=Math.max(n.Cartesian3.dot(I,c),U),L=Math.min(n.Cartesian3.dot(P,c),L),D=Math.min(n.Cartesian3.dot(A,c),D),q=Math.min(n.Cartesian3.dot(I,c),q);P=n.Cartesian3.multiplyByScalar(P,.5*(L+R),P),A=n.Cartesian3.multiplyByScalar(A,.5*(D+S),A),I=n.Cartesian3.multiplyByScalar(I,.5*(q+U),I);const v=n.Cartesian3.add(P,A,e.center);n.Cartesian3.add(v,I,v);const z=u;return z.x=R-L,z.y=S-D,z.z=U-q,n.Cartesian3.multiplyByScalar(z,.5,z),n.Matrix3.multiplyByScale(e.halfAxes,z,e.halfAxes),e};const M=new n.Cartesian3,w=new n.Cartesian3;function g(a,e,t,s,o,c,d,l,u,h,f){if(!(i.defined(o)&&i.defined(c)&&i.defined(d)&&i.defined(l)&&i.defined(u)&&i.defined(h)))throw new r.DeveloperError("all extents (minimum/maximum X/Y/Z) are required.");i.defined(f)||(f=new C);const m=f.halfAxes;n.Matrix3.setColumn(m,0,e,m),n.Matrix3.setColumn(m,1,t,m),n.Matrix3.setColumn(m,2,s,m);let x=M;x.x=(o+c)/2,x.y=(d+l)/2,x.z=(u+h)/2;const p=w;p.x=(c-o)/2,p.y=(l-d)/2,p.z=(h-u)/2;const g=f.center;return x=n.Matrix3.multiplyByVector(m,x,x),n.Cartesian3.add(a,x,g),n.Matrix3.multiplyByScale(m,p,m),f}const b=new n.Cartographic,y=new n.Cartesian3,O=new n.Cartographic,E=new n.Cartographic,N=new n.Cartographic,T=new n.Cartographic,P=new n.Cartographic,A=new n.Cartesian3,I=new n.Cartesian3,R=new n.Cartesian3,S=new n.Cartesian3,U=new n.Cartesian3,L=new t.Cartesian2,D=new t.Cartesian2,q=new t.Cartesian2,v=new t.Cartesian2,z=new t.Cartesian2,B=new n.Cartesian3,V=new n.Cartesian3,_=new n.Cartesian3,k=new n.Cartesian3,W=new t.Cartesian2,X=new n.Cartesian3,j=new n.Cartesian3,Z=new n.Cartesian3,Y=new c.Plane(n.Cartesian3.UNIT_X,0);C.fromRectangle=function(a,e,C,d,l){if(!i.defined(a))throw new r.DeveloperError("rectangle is required");if(a.width<0||a.width>o.CesiumMath.TWO_PI)throw new r.DeveloperError("Rectangle width must be between 0 and 2 * pi");if(a.height<0||a.height>o.CesiumMath.PI)throw new r.DeveloperError("Rectangle height must be between 0 and pi");if(i.defined(d)&&!o.CesiumMath.equalsEpsilon(d.radii.x,d.radii.y,o.CesiumMath.EPSILON15))throw new r.DeveloperError("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");let u,h,f,m,x,p,M;if(e=i.defaultValue(e,0),C=i.defaultValue(C,0),d=i.defaultValue(d,n.Ellipsoid.WGS84),a.width<=o.CesiumMath.PI){const r=t.Rectangle.center(a,b),i=d.cartographicToCartesian(r,y),o=new s.EllipsoidTangentPlane(i,d);M=o.plane;const w=r.longitude,B=a.south<0&&a.north>0?0:r.latitude,V=n.Cartographic.fromRadians(w,a.north,C,O),_=n.Cartographic.fromRadians(a.west,a.north,C,E),k=n.Cartographic.fromRadians(a.west,B,C,N),W=n.Cartographic.fromRadians(a.west,a.south,C,T),X=n.Cartographic.fromRadians(w,a.south,C,P),j=d.cartographicToCartesian(V,A);let Z=d.cartographicToCartesian(_,I);const Y=d.cartographicToCartesian(k,R);let G=d.cartographicToCartesian(W,S);const F=d.cartographicToCartesian(X,U),H=o.projectPointToNearestOnPlane(j,L),J=o.projectPointToNearestOnPlane(Z,D),K=o.projectPointToNearestOnPlane(Y,q),Q=o.projectPointToNearestOnPlane(G,v),$=o.projectPointToNearestOnPlane(F,z);return u=Math.min(J.x,K.x,Q.x),h=-u,m=Math.max(J.y,H.y),f=Math.min(Q.y,$.y),_.height=W.height=e,Z=d.cartographicToCartesian(_,I),G=d.cartographicToCartesian(W,S),x=Math.min(c.Plane.getPointDistance(M,Z),c.Plane.getPointDistance(M,G)),p=C,g(o.origin,o.xAxis,o.yAxis,o.zAxis,u,h,f,m,x,p,l)}const w=a.south>0,G=a.north<0,F=w?a.south:G?a.north:0,H=t.Rectangle.center(a,b).longitude,J=n.Cartesian3.fromRadians(H,F,C,d,B);J.z=0;const K=Math.abs(J.x)<o.CesiumMath.EPSILON10&&Math.abs(J.y)<o.CesiumMath.EPSILON10?n.Cartesian3.UNIT_X:n.Cartesian3.normalize(J,V),Q=n.Cartesian3.UNIT_Z,$=n.Cartesian3.cross(K,Q,_);M=c.Plane.fromPointNormal(J,K,Y);const aa=n.Cartesian3.fromRadians(H+o.CesiumMath.PI_OVER_TWO,F,C,d,k);h=n.Cartesian3.dot(c.Plane.projectPointOntoPlane(M,aa,W),$),u=-h,m=n.Cartesian3.fromRadians(0,a.north,G?e:C,d,X).z,f=n.Cartesian3.fromRadians(0,a.south,w?e:C,d,j).z;const ea=n.Cartesian3.fromRadians(a.east,F,C,d,Z);return x=c.Plane.getPointDistance(M,ea),p=0,g(J,$,Q,K,u,h,f,m,x,p,l)},C.fromTransformation=function(a,e){return r.Check.typeOf.object("transformation",a),i.defined(e)||(e=new C),e.center=t.Matrix4.getTranslation(a,e.center),e.halfAxes=t.Matrix4.getMatrix3(a,e.halfAxes),e.halfAxes=n.Matrix3.multiplyByScalar(e.halfAxes,.5,e.halfAxes),e},C.clone=function(a,e){if(i.defined(a))return i.defined(e)?(n.Cartesian3.clone(a.center,e.center),n.Matrix3.clone(a.halfAxes,e.halfAxes),e):new C(a.center,a.halfAxes)},C.intersectPlane=function(a,t){if(!i.defined(a))throw new r.DeveloperError("box is required.");if(!i.defined(t))throw new r.DeveloperError("plane is required.");const s=a.center,o=t.normal,c=a.halfAxes,C=o.x,d=o.y,l=o.z,u=Math.abs(C*c[n.Matrix3.COLUMN0ROW0]+d*c[n.Matrix3.COLUMN0ROW1]+l*c[n.Matrix3.COLUMN0ROW2])+Math.abs(C*c[n.Matrix3.COLUMN1ROW0]+d*c[n.Matrix3.COLUMN1ROW1]+l*c[n.Matrix3.COLUMN1ROW2])+Math.abs(C*c[n.Matrix3.COLUMN2ROW0]+d*c[n.Matrix3.COLUMN2ROW1]+l*c[n.Matrix3.COLUMN2ROW2]),h=n.Cartesian3.dot(o,s)+t.distance;return h<=-u?e.Intersect.OUTSIDE:h>=u?e.Intersect.INSIDE:e.Intersect.INTERSECTING};const G=new n.Cartesian3,F=new n.Cartesian3,H=new n.Cartesian3,J=new n.Cartesian3,K=new n.Cartesian3,Q=new n.Cartesian3;C.distanceSquaredTo=function(a,e){if(!i.defined(a))throw new r.DeveloperError("box is required.");if(!i.defined(e))throw new r.DeveloperError("cartesian is required.");const t=n.Cartesian3.subtract(e,a.center,M),s=a.halfAxes;let c=n.Matrix3.getColumn(s,0,G),C=n.Matrix3.getColumn(s,1,F),d=n.Matrix3.getColumn(s,2,H);const l=n.Cartesian3.magnitude(c),u=n.Cartesian3.magnitude(C),h=n.Cartesian3.magnitude(d);let f=!0,m=!0,x=!0;l>0?n.Cartesian3.divideByScalar(c,l,c):f=!1,u>0?n.Cartesian3.divideByScalar(C,u,C):m=!1,h>0?n.Cartesian3.divideByScalar(d,h,d):x=!1;const p=!f+!m+!x;let w,g,b;if(1===p){let a=c;w=C,g=d,m?x||(a=d,g=c):(a=C,w=c),b=n.Cartesian3.cross(w,g,K),a===c?c=b:a===C?C=b:a===d&&(d=b)}else if(2===p){w=c,m?w=C:x&&(w=d);let a=n.Cartesian3.UNIT_Y;a.equalsEpsilon(w,o.CesiumMath.EPSILON3)&&(a=n.Cartesian3.UNIT_X),g=n.Cartesian3.cross(w,a,J),n.Cartesian3.normalize(g,g),b=n.Cartesian3.cross(w,g,K),n.Cartesian3.normalize(b,b),w===c?(C=g,d=b):w===C?(d=g,c=b):w===d&&(c=g,C=b)}else 3===p&&(c=n.Cartesian3.UNIT_X,C=n.Cartesian3.UNIT_Y,d=n.Cartesian3.UNIT_Z);const y=Q;y.x=n.Cartesian3.dot(t,c),y.y=n.Cartesian3.dot(t,C),y.z=n.Cartesian3.dot(t,d);let O,E=0;return y.x<-l?(O=y.x+l,E+=O*O):y.x>l&&(O=y.x-l,E+=O*O),y.y<-u?(O=y.y+u,E+=O*O):y.y>u&&(O=y.y-u,E+=O*O),y.z<-h?(O=y.z+h,E+=O*O):y.z>h&&(O=y.z-h,E+=O*O),E};const $=new n.Cartesian3,aa=new n.Cartesian3;C.computePlaneDistances=function(a,t,s,o){if(!i.defined(a))throw new r.DeveloperError("box is required.");if(!i.defined(t))throw new r.DeveloperError("position is required.");if(!i.defined(s))throw new r.DeveloperError("direction is required.");i.defined(o)||(o=new e.Interval);let c=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY;const d=a.center,l=a.halfAxes,u=n.Matrix3.getColumn(l,0,G),h=n.Matrix3.getColumn(l,1,F),f=n.Matrix3.getColumn(l,2,H),m=n.Cartesian3.add(u,h,$);n.Cartesian3.add(m,f,m),n.Cartesian3.add(m,d,m);const x=n.Cartesian3.subtract(m,t,aa);let p=n.Cartesian3.dot(s,x);return c=Math.min(p,c),C=Math.max(p,C),n.Cartesian3.add(d,u,m),n.Cartesian3.add(m,h,m),n.Cartesian3.subtract(m,f,m),n.Cartesian3.subtract(m,t,x),p=n.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),n.Cartesian3.add(d,u,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.add(m,f,m),n.Cartesian3.subtract(m,t,x),p=n.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),n.Cartesian3.add(d,u,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.subtract(m,f,m),n.Cartesian3.subtract(m,t,x),p=n.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),n.Cartesian3.subtract(d,u,m),n.Cartesian3.add(m,h,m),n.Cartesian3.add(m,f,m),n.Cartesian3.subtract(m,t,x),p=n.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),n.Cartesian3.subtract(d,u,m),n.Cartesian3.add(m,h,m),n.Cartesian3.subtract(m,f,m),n.Cartesian3.subtract(m,t,x),p=n.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),n.Cartesian3.subtract(d,u,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.add(m,f,m),n.Cartesian3.subtract(m,t,x),p=n.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),n.Cartesian3.subtract(d,u,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.subtract(m,f,m),n.Cartesian3.subtract(m,t,x),p=n.Cartesian3.dot(s,x),c=Math.min(p,c),C=Math.max(p,C),o.start=c,o.stop=C,o};const ea=new n.Cartesian3,ta=new n.Cartesian3,na=new n.Cartesian3;C.computeCorners=function(a,e){r.Check.typeOf.object("box",a),i.defined(e)||(e=[new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3]);const t=a.center,s=a.halfAxes,o=n.Matrix3.getColumn(s,0,ea),c=n.Matrix3.getColumn(s,1,ta),C=n.Matrix3.getColumn(s,2,na);return n.Cartesian3.clone(t,e[0]),n.Cartesian3.subtract(e[0],o,e[0]),n.Cartesian3.subtract(e[0],c,e[0]),n.Cartesian3.subtract(e[0],C,e[0]),n.Cartesian3.clone(t,e[1]),n.Cartesian3.subtract(e[1],o,e[1]),n.Cartesian3.subtract(e[1],c,e[1]),n.Cartesian3.add(e[1],C,e[1]),n.Cartesian3.clone(t,e[2]),n.Cartesian3.subtract(e[2],o,e[2]),n.Cartesian3.add(e[2],c,e[2]),n.Cartesian3.subtract(e[2],C,e[2]),n.Cartesian3.clone(t,e[3]),n.Cartesian3.subtract(e[3],o,e[3]),n.Cartesian3.add(e[3],c,e[3]),n.Cartesian3.add(e[3],C,e[3]),n.Cartesian3.clone(t,e[4]),n.Cartesian3.add(e[4],o,e[4]),n.Cartesian3.subtract(e[4],c,e[4]),n.Cartesian3.subtract(e[4],C,e[4]),n.Cartesian3.clone(t,e[5]),n.Cartesian3.add(e[5],o,e[5]),n.Cartesian3.subtract(e[5],c,e[5]),n.Cartesian3.add(e[5],C,e[5]),n.Cartesian3.clone(t,e[6]),n.Cartesian3.add(e[6],o,e[6]),n.Cartesian3.add(e[6],c,e[6]),n.Cartesian3.subtract(e[6],C,e[6]),n.Cartesian3.clone(t,e[7]),n.Cartesian3.add(e[7],o,e[7]),n.Cartesian3.add(e[7],c,e[7]),n.Cartesian3.add(e[7],C,e[7]),e};const ra=new n.Matrix3;C.computeTransformation=function(a,e){r.Check.typeOf.object("box",a),i.defined(e)||(e=new t.Matrix4);const s=a.center,o=n.Matrix3.multiplyByUniformScale(a.halfAxes,2,ra);return t.Matrix4.fromRotationTranslation(o,s,e)};const ia=new e.BoundingSphere;C.isOccluded=function(a,t){if(!i.defined(a))throw new r.DeveloperError("box is required.");if(!i.defined(t))throw new r.DeveloperError("occluder is required.");const n=e.BoundingSphere.fromOrientedBoundingBox(a,ia);return!t.isBoundingSphereVisible(n)},C.prototype.intersectPlane=function(a){return C.intersectPlane(this,a)},C.prototype.distanceSquaredTo=function(a){return C.distanceSquaredTo(this,a)},C.prototype.computePlaneDistances=function(a,e,t){return C.computePlaneDistances(this,a,e,t)},C.prototype.computeCorners=function(a){return C.computeCorners(this,a)},C.prototype.computeTransformation=function(a){return C.computeTransformation(this,a)},C.prototype.isOccluded=function(a){return C.isOccluded(this,a)},C.equals=function(a,e){return a===e||i.defined(a)&&i.defined(e)&&n.Cartesian3.equals(a.center,e.center)&&n.Matrix3.equals(a.halfAxes,e.halfAxes)},C.prototype.clone=function(a){return C.clone(this,a)},C.prototype.equals=function(a){return C.equals(this,a)},a.OrientedBoundingBox=C}));