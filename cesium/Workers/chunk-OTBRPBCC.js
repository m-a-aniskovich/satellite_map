/*! For license information please see chunk-OTBRPBCC.js.LICENSE.txt */
import{Quaternion_default,Transforms_default}from"./chunk-D4YHO4NZ.js";import{Cartesian2_default,Matrix2_default,Matrix4_default,Rectangle_default}from"./chunk-RSWBNJPT.js";import{Cartesian3_default,Cartographic_default,Matrix3_default}from"./chunk-PHQVHDVI.js";import{WebGLConstants_default}from"./chunk-VNRUVNIK.js";import{defaultValue_default}from"./chunk-C53JYYKX.js";import{Check_default,DeveloperError_default}from"./chunk-7FEGZO3D.js";import{defined_default}from"./chunk-YS4KPNLC.js";var GeometryType={NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3},GeometryType_default=Object.freeze(GeometryType),PrimitiveType={POINTS:WebGLConstants_default.POINTS,LINES:WebGLConstants_default.LINES,LINE_LOOP:WebGLConstants_default.LINE_LOOP,LINE_STRIP:WebGLConstants_default.LINE_STRIP,TRIANGLES:WebGLConstants_default.TRIANGLES,TRIANGLE_STRIP:WebGLConstants_default.TRIANGLE_STRIP,TRIANGLE_FAN:WebGLConstants_default.TRIANGLE_FAN,isLines:function(t){return t===PrimitiveType.LINES||t===PrimitiveType.LINE_LOOP||t===PrimitiveType.LINE_STRIP},isTriangles:function(t){return t===PrimitiveType.TRIANGLES||t===PrimitiveType.TRIANGLE_STRIP||t===PrimitiveType.TRIANGLE_FAN},validate:function(t){return t===PrimitiveType.POINTS||t===PrimitiveType.LINES||t===PrimitiveType.LINE_LOOP||t===PrimitiveType.LINE_STRIP||t===PrimitiveType.TRIANGLES||t===PrimitiveType.TRIANGLE_STRIP||t===PrimitiveType.TRIANGLE_FAN}},PrimitiveType_default=Object.freeze(PrimitiveType);function Geometry(t){t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT),Check_default.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=defaultValue_default(t.primitiveType,PrimitiveType_default.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=defaultValue_default(t.geometryType,GeometryType_default.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}Geometry.computeNumberOfVertices=function(t){Check_default.typeOf.object("geometry",t);let e=-1;for(const a in t.attributes)if(t.attributes.hasOwnProperty(a)&&defined_default(t.attributes[a])&&defined_default(t.attributes[a].values)){const r=t.attributes[a],i=r.values.length/r.componentsPerAttribute;if(e!==i&&-1!==e)throw new DeveloperError_default("All attribute lists must have the same number of attributes.");e=i}return e};var rectangleCenterScratch=new Cartographic_default,enuCenterScratch=new Cartesian3_default,fixedFrameToEnuScratch=new Matrix4_default,boundingRectanglePointsCartographicScratch=[new Cartographic_default,new Cartographic_default,new Cartographic_default],boundingRectanglePointsEnuScratch=[new Cartesian2_default,new Cartesian2_default,new Cartesian2_default],points2DScratch=[new Cartesian2_default,new Cartesian2_default,new Cartesian2_default],pointEnuScratch=new Cartesian3_default,enuRotationScratch=new Quaternion_default,enuRotationMatrixScratch=new Matrix4_default,rotation2DScratch=new Matrix2_default;Geometry._textureCoordinateRotationPoints=function(t,e,a,r){let i;const n=Rectangle_default.center(r,rectangleCenterScratch),u=Cartographic_default.toCartesian(n,a,enuCenterScratch),o=Transforms_default.eastNorthUpToFixedFrame(u,a,fixedFrameToEnuScratch),l=Matrix4_default.inverse(o,fixedFrameToEnuScratch),f=boundingRectanglePointsEnuScratch,d=boundingRectanglePointsCartographicScratch;d[0].longitude=r.west,d[0].latitude=r.south,d[1].longitude=r.west,d[1].latitude=r.north,d[2].longitude=r.east,d[2].latitude=r.south;let s=pointEnuScratch;for(i=0;i<3;i++)Cartographic_default.toCartesian(d[i],a,s),s=Matrix4_default.multiplyByPointAsVector(l,s,s),f[i].x=s.x,f[i].y=s.y;const c=Quaternion_default.fromAxisAngle(Cartesian3_default.UNIT_Z,-e,enuRotationScratch),_=Matrix3_default.fromQuaternion(c,enuRotationMatrixScratch),m=t.length;let p=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,y=Number.NEGATIVE_INFINITY,T=Number.NEGATIVE_INFINITY;for(i=0;i<m;i++)s=Matrix4_default.multiplyByPointAsVector(l,t[i],s),s=Matrix3_default.multiplyByVector(_,s,s),p=Math.min(p,s.x),h=Math.min(h,s.y),y=Math.max(y,s.x),T=Math.max(T,s.y);const N=Matrix2_default.fromRotation(e,rotation2DScratch),I=points2DScratch;I[0].x=p,I[0].y=h,I[1].x=p,I[1].y=T,I[2].x=y,I[2].y=h;const P=f[0],E=f[2].x-P.x,b=f[1].y-P.y;for(i=0;i<3;i++){const t=I[i];Matrix2_default.multiplyByVector(N,t,t),t.x=(t.x-P.x)/E,t.y=(t.y-P.y)/b}const S=I[0],C=I[1],L=I[2],A=new Array(6);return Cartesian2_default.pack(S,A),Cartesian2_default.pack(C,A,2),Cartesian2_default.pack(L,A,4),A};var Geometry_default=Geometry;function GeometryAttribute(t){if(t=defaultValue_default(t,defaultValue_default.EMPTY_OBJECT),!defined_default(t.componentDatatype))throw new DeveloperError_default("options.componentDatatype is required.");if(!defined_default(t.componentsPerAttribute))throw new DeveloperError_default("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new DeveloperError_default("options.componentsPerAttribute must be between 1 and 4.");if(!defined_default(t.values))throw new DeveloperError_default("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=defaultValue_default(t.normalize,!1),this.values=t.values}var GeometryAttribute_default=GeometryAttribute;export{GeometryType_default,PrimitiveType_default,Geometry_default,GeometryAttribute_default};